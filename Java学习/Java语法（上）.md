# 1 Java 概述

> 程序：一系列有序指令的集合

## 1.1 Java 历史

- 目前 Java 版权属于甲骨文公司。

- 长期支持的版本只有 Java8 与 Java11。这两个版本也是最多使用的版本。

- Java SE：标准版

  Java EE：企业版（重要）

  Java ME：小型版（少）

## 1.2 Java 重要特点

1. Java 语言是**面向对象的（oop）**

   简单来说，面向对象是一种程序设计技术。其重点放在数据（对象）和对象的接口上。

   ***——何为面向对象？详见 [[ 6 面向对象编程 \]](# 6 面向对象编程（基础）)***

2. Java 语言是**健壮的**。其强类型机制、异常处理、垃圾自动收集是健壮性的保证。

   Java 强调早期问题检测、后期动态检测，及消除易出错的情况。其编译器能检测很多其他语言仅在运行时才会发现的问题。

   ***——异常见 [[ 11 异常 \]](# 11 异常（Exception）)***

3. Java 语言是**跨平台性**的：一个编译好的 `.class` 文件可以在多个不同系统下直接运行。

   Java 中没有 “依赖具体实现” 的地方。其基本数据类型大小、有关运算的行为等都有明确说明。其绝大多数库都能很好地支持平台独立性，而不用担心操作系统。

4. Java 语言是**解释型**的：解释型语言编译后需要解释器才能运行。相对的，编译型语言可以被直接执行。

   Java 解释器能在任何移植了解释器的机器上直接执行 Java 字节码。

## 1.3 Java 的开发工具

- javac：Java 编译器。将 Java 程序编译成字节码
- java：Java 解释器。执行已经转换为字节码的文件
- jdb：Java 调试器。调试 Java 程序
- javap：反编译。将类文件还原回方法和变量
- javadoc：文档生成器。创建 HTML 文件

## 1.4 Java 运行基础

> JVM：Java 虚拟机

- JVM 是–跨平台性的基础。被包含在 JDK 中。
- 不同平台有各自对应的不同 JVM
- JVM 屏蔽了底层平台的区别。能做到 ”一次编译，到处运行”

> JDK 全称：Java Development Kit（Java 开发工具包）

- JDK = JRE + Java 的开发工具（Java，Javac，Javadoc 等等）
- 给开发人员使用的，包含 JRE

> JRE：Java Runtime Enviroment（Java 运行环境）

- JRE = JVM + Java SE 标准类库（Java 的核心类库）
- 运行一个 Java 程序的基本条件

## 1.5 Java 执行流程分析

> `.Java` 文件（源文件） — javac（编译）— `.class` 文件（字节码文件） — java（运行）— 结果

### 1.5.1 编译

```
javac [选项] 源文件名.java			//[] 中是可选项
```

- 通过编译器将 Java 源文件编译成 JVM 可识别的字节码文件。字节码文件是二进制格式的，其格式是统一的。在源文件目录下使用 Javac 编译工具对 Java 文件进行编译。
- 如果没有错误将没有提示，当前目录会对应其中每一个类生成对应名称的 `.class` 文件，即字节码文件，也是可执行的 Java 程序。

### 1.5.2 运行

```
java [选项] 程序名 [参数列表]			//[] 中是可选项
```

- 有了可执行的 Java 程序（字节码文件）
- 通过运行工具` Java.exe` 对字节码文件进行执行，本质是将 `.class` 文件装载到 JVM 运行。

**注意，修改后的 .Java 源文件需要重新编译**

## 1.6 Java 开发注意事项和细节说明

1. 源文件以 `.java` 为扩展名，源文件的基本组成部分是类（class）

2. Java 应用程序的执行入口是 `main()` 方法。其有固定的**书写格式：**

   `public static void main(string[]args){…}`

3. Java 语言**严格区分大小写**。

4. Java 方法由一条条语句构成，**每个语句都以 `;` 结束**。

5. **大括号 `{` `}` 是成对出现的**，缺一不可。习惯先写 `{}` 再写代码

6. 一个源文件中**最多只有一个 public 类**，其余类不限。

7. **如果文件中包含 public 类，则文件名必须按该类命名。**

8. 也可以把 main 方法写在非 public 类中，然后运行指定非 public 类，这样入口方法是非 public 类的主方法。

9. ***在控制台按 tab 可以实现代码补齐。按方向键 ↑ 或 ↓ 可以调用历史代码。***

## 1.7 代码规范

1. 类、方法的注释要以 Javadoc 的方式来写

2. 非 Javadoc 的注释，往往是给维护者看的，着重告诉读者为什么这样写，如何修改，注意什么问题等。

3. 不要用 `a` `b`，这种名称命名变量，尽量写得清楚 `int age = 10;`

   另外，**Java 源代码使用的是 Unicode 码，因此汉语也能作为标识符**。但不推荐使用汉语做标识符。

4. 使用 tab 键操作，使代码右移。使用 shift+tab 键，使代码左移。

5. 运算符两边各加入空格。注意排版规范。

6. 源文件使用 UTF-8 编码。

7. 代码行宽度不要超过 80 个字符。超过时通过换行保持简洁。

8. 代码编写**次行风格**及**行尾风格**

   > 次行风格：换行输入`{` `}`，使其总在行头
   >
   > 行尾风格：在一行的末尾输入 `{`，换行输入 `}`

9. 一段代码完成一个小功能，尽量不要混合。这样更加灵活。

## 1.8 Java 转义字符

1. `\t`：一个制表位，实现对齐功能

2. `\n`：换行符

3. `\\`：一个 `\`

4. `\"`：一个 `"`

5. `\'`：一个 `'`

6. `\r`：一个回车（不是换行）

7. `\.`：一个小圆点 `.`

8. `\b`：退格键

9. `\u????`：一个具体的 Unicode 字符。其中 ??? 是 4 位 16 进制数

   `\???`：一个具体的 Unicode 字符。其中 ??? 是 3 位 8 进制数

## 1.9 注释

> 注释：用于注解说明程序的文字。其提高了代码的可读性，是一个程序员必须要具有的良好编程习惯。将自己的思想通过注释先整理出来，再用代码去体现。
>
> 被注释的文字不会被 JVM 解释执行。

### 1.9.1 注释类型

- **单行注释：**

  ```
  //这是一条单行注释
  ```

  选中文字按 `ctrl` + `/` 将选中文字变为单行注释

- **多行注释：**

  ```
  /*	
  	这
  	是一段
  	多行注释
  */
  ```

  多行注释中不允许多行注释嵌套。

- **文档注释：**

  ```
  /**
  *@auther Melody
  *@version 3.2.0
  */
  ```

  以下写法也同样合法：

  ```
  /**
  	就是说咱可以每行开头不加星号的
  */
  ```

### 1.9.2 文档注释

> 文档注释的注释内容可被 JDK 中的 Javadoc 工具解析，生成一套以 HTML 形式体现的说明文档。
>
> 抽取注释：`javadoc -d 生成目录 -author -.. 文档名.java`

文档注释包含 **标记** 和紧随其后的 **自由格式文本**：

- **标记：**

  以 `@` 开始，如 `@since`

  下面列出了一些 **通用注释**：

  - `@since 始于`：创建一个 **始于** 条目。其后文本可以是引入该特性的版本的任何描述

  - `@author 作者`：产生一个 **作者** 条目。可以使用多个 `@author` 标记

  - `@version 版本`：产生一个 **版本** 条目。这里的文本可以是对当前版本的任意描述

  - `@link 超链接`：产生一个 **超链接**，链接到 javadoc 相关部分或外部文档

    `@see 引用`：在 **see also** 部分增加一个超链接。可以添加多个 `@see` 标记，但必须放在一起。

    这里的 引用 有以下选择：

    ```
    /**
    *@see com.test.Example#act()
    *@see <a herf="../../../../../../">Melody's Box</a>
    *@see "一段文本"
    */
    ```

    > 1. 只提供类、方法或变量的名字。那个场合，使用 **#** 来分隔类名和方法名
    > 2. `@see` 后有一个 **<** 字符的场合，需要指定超链接。可以指向任何 URL
    > 3. `@see` 后有一个 **“** 字符的场合，文本会显示在 see alse 部分

- **自由格式文本：**

  第一句应该是一个概要性的句子。javadoc 会自动抽取这些语句生成概要页

  自由格式文本中，可以使用 HTML 修饰符

#### 注释的插入

javadoc 工具抽取文档注释时，会从以下位置抽取：

- 模块

- 包（包注释）

  **要想产生包注释，必须在每个包目录中添加一个单独的文件**

  有 2 种方法：

  - 提供一个名为 package-info.java 的文件。其中 **只能** 包含文档注释，以及后面的一个 package 语句。不能包含更多的代码或注释。
  - 提供一个名为 package.html 的 HTML 文件。此时会抽取 `<body>...</body>` 间的所有文本

- 公共类和接口（类注释）

  类注释必须放在 import 语句后，类定义之前

- 公共的和受保护的字段

  只需要对公共字段（通常是静态常量）建立文档

- 公共的和受保护的构造器和方法

  方法注释必须放在所描述的方法之前。除了通用标记外，还能使用如下标记：

  - `@param 变量描述`：该标记能给当前方法的 **参数** 部分添加一个条目。该描述可以占据多行。

    一个方法的所有 `@param` 标记必须放在一起

  - `@return 返回值描述`：该标记能给当前方法的 **返回值** 部分添加一个条目。该描述可以占据多行。

  - `@throws 异常描述`：该标记能给当前方法的可能抛出的 **异常** 添加一个条目。

## 1.10 JShell

> Java 9 中引入了一种使用 Java 的方法，即 JShell。
>
> JShell 程序提供了一个 “读取 - 计算 - 打印循环”。键入一个 Java 表达式，JShell 会评估你的输入，打印结果，并等待下一个输入。
>
> 在命令提示符中输入 `jshell` 以启动 JShell

```
C:\Users\Melody>jshell
```

在 cmd 中输入 jshell 以启动 JShell

```
|  欢迎使用 JShell -- 版本 11.0.12
|  要大致了解该版本, 请键入: /help intro

jshell>
```

JShell 会显示一个问候语，之后出现提示符

```
jshell> int n1 = 10;
n1 ==> 10

jshell> n1++;
$2 ==> 10
```

输入一条语句，JShell 会自动打印每条输入语句的值

其中的 $2 表示该值可以用于将来的计算。上面的 n1 是自己定义的标识符

```
jshell> Math.
E                 IEEEremainder(    PI                abs(              acos(             addExact(
asin(             atan(             atan2(            cbrt(             ceil(             class
copySign(         cos(              cosh(             decrementExact(   exp(              expm1(
floor(            floorDiv(         floorMod(         fma(              getExponent(      hypot(
incrementExact(   log(              log10(            log1p(            max(              min(
multiplyExact(    multiplyFull(     multiplyHigh(     negateExact(      nextAfter(        nextDown(
nextUp(           pow(              random()          rint(             round(            scalb(
signum(           sin(              sinh(             sqrt(             subtractExact(    tan(
tanh(             toDegrees(        toIntExact(       toRadians(        ulp(
```

输入不完整的语句后，按 tab 键实现方法补全。上面的场合，提示了所有方法的列表

```
jshell> Math.pow(
CMD
```

自动补全后的代码。可以手动填入剩余部分。

可以按 ↑ 键自动填充运行过的代码，以实现重复运行

##  1.11 JUnit

> 一个类有多个功能代码需要测试，为了测试，就要写入 `main` 方法中
>
> 如果有多个功能代码测试，需要反复撤销，过程繁琐

> JUnit 是一个 Java 语言单元测试框架
>
> 多数 Java 开发环境都已集成了 JUnit 作为单元测试工具
>
> [使用方法](https://www.bilibili.com/video/BV1fh411y7R8?p=566&t=259.3)
>
> ……总的来讲，方法就是加入 `@Test`，然后 `alt + enter` 引入 JUnit 5，最后运行

# 2 变量

> 变量：变量是程序的基本组成单位
>
> 变量的三个基本要素：类型 + 名称 + 值
>
> 示例：`int a = 1` 类型 int 名称 a 值 1

**如何声明变量：**

```java
int a;
a = 100;
int b = 100;
int c = 5, d;
```

## 2.1 变量使用注意事项

1. 变量表示内存中的一个存储区域。不同变量，不同类型，占用的空间大小不同。如 `int` 有 4 byte，而 `double` 有 8 byte。
2. 该区域有自己的名称 `变量名` 和类型 `数据类型`
3. 变量必须先声明，后使用。
4. 变量在同一作用域内不能重名。
5. 该区域的数据 · 值可以在同一类型范围内变化。
6. 变量的三个基本要素：类型 + 名称 + 值

## 2.2 程序中 `+` 的使用

1. 当左右两边都是数值型，做加法运算

2. 当左右两边任意一方为字符串，做拼接运算

3. 运算顺序是从左到右的

   ```
   System.out.println(1 + 1 + "a" + 1 + 1);		// 输出 2a11
   ```

## 2.3 Java 数据类型

#### #基本数据类型（本章）

- **数值型**
  - 整数类型：
    - byte：占用 1 字节
    - short：占用 2 字节
    - int：占用 4 字节
    - long：占用 8 字节
  - 浮点（小数）类型：
    - float：占用 4 字节
    - double：占用 8 字节
- **字符型**
  - char：存放单个字符，占用 2 字节
- **布尔型**
  - boolean：存放 true（真），false（假）。占用 1 字节

#### #引用数据类型（复合数据类型）

- **类**：class

  ***——详见 [[ 6 类与对象 \]](# 6.1 类与对象（OOP）)***

- **接口**：interface

  ***——详见 [[ 9.7 接口 \]](9.7 接口)***

- **数组**：`[]`

  ***——详见 [[ 5 数组、排序和查找 \]](# 5 数组、排序和查找)***

## 2.4 整数类型

> 用于存放整数值

- `byte` 占用 1 字节，范围 -128 ~ 127
- `short` 占用 2 字节，范围 -215 ~ 215 - 1
- `int` 占用 4 字节，范围 -231 ~ 231 - 1
- `long` 占用 8 字节，范围 -263 ~ 263 - 1

**使用细节：**

1. Java 各整数类型有固定的范围和字符长度，不受具体 OS（操作系统）影响，以保证 Java 程序的可移植性。
2. Java 默认整型常量为 `int` ，要声明 `long` 型常量必须后加 `l` 或 `L`。
3. 从 Java 7 开始，加上前缀 `0b` 或 `0B` 就可以写二进制数。
4. 从 Java 7 开始，可以为数字字面添加下划线。这不会影响数字的值，只是为了方便阅读。

```
int n = 0b0010;
n = 0b001;
n = 100_0_000000;
n = 0B0000_0010_1100;
float f = 1.0F;
```

如果基本的整数、浮点类型不能满足范围、精度的需求，可以使用 “大数”

***—— 大数，见 [[12.8 BigInteger 和 BigDecimal 类\]](./java语法（下）.md# 12.8 `BigInteger` 和 `BigDecimal` 类)***

## 2.5 浮点类型

> 可以表示一个小数

- `float` 单精度（6 ~ 7 位有效数字），占用 4 字节，范围约 -3.403E38 ~ 3.403E38
- `double` 双精度（15 位有效数字），占用 8 字节，范围约 -1.798E308 ~ 1.798E308

*浮点数在机器中存放形式为：浮点数 = 符号位 + 指数位 + 尾数位*

***因此，尾数部分可能丢失，造成精度损失。换言之，小数都是近似值***

### 2.5.1 使用细节

1. 与整数类型相似，有固定的范围和字符长度，不受具体 OS（操作系统）影响。

2. Java 默认浮点常量为 `double` ，要声明 `float` 型常量必须后加 ”f“ 或 ”F“

3. 浮点型常量有两种表示形式

   > 十进制数形式：`5.13`、`315.4F`、`.414`
   >
   > 科学计数法：`5.12e2` 即[5.12 × 102]、`5.12E-2` 即[5.12 / 102]

4. 通常情况下，应该使用 `double` 类型，以其更为精确。

5. 浮点数使用陷阱：当我们对运算结果是小数的进行相对判断时，要小心。（因为***小数都是近似值***）

   正确方法是：**以两个数差值的绝对值，在某个精度范围内判断**

   ```
   if (Math.abs(num1 - num2) < 0.00001) {
   	System.out.println("插值范围内认为相等");
   }
   ```

6. 特殊的浮点类型常量

   - 正无穷大：`Float.POSITIVE_INFINITY`、`Double.POSITIVE_INFINITY`

     （浮点数运算中）一个正数除以 0，会得到该值

   - 负无穷大：`Float.NEGATIVE_INFINITY`、`Double.NEGATIVE_INFINITY`

     （浮点数运算中）一个负数除以 0，会得到该值

   - 0 / 0：`Float.NaN`、`Double.NaN`

     （浮点数运算中）0 除以 0，会得到该值

   - 最大、最小值：`Float.MAX_VALUE`、`Double.MIN_VALUE`

7. 不能用运算符来比较特殊值，而要用特别的方法

   ```
   double num = 0.0 / 0;
   System.out.println(num == Double.NaN);			// <——— 始终为 false。不能如此比较
   System.out.println(Double.isNaN(num));			// <——— 判断是否是 NaN
   num = 1.0 / 0;
   System.out.println(Double.isInfinite(num));		// <——— 是否是无穷大
   ```

8. 由于不同处理器寄存浮点数的策略可能不同，浮点数运算的结果也可能不同。

   ***—— 见 [[12.1.4 strictfp 关键字\]](./java语法（下）.md# 12.1.4 strictfp 关键字)***

## 2.6 字符类型

> 可以表示单个字符。（可以存放一个数字，因为其字符是数字编号的。输出时会输出数字对应的字符。”编码的概念“）
>
> ```
> char c1 = 'a';
> char c2 = '\t';
> char c3 = '字';
> char c4 = 99;
> ```

### 2.6.1 使用细节

1. 字符常量用单引号括起 `‘字’

2. `char` 的本质是一个整数，输出时，输出的是 unicode 码对应的字符。

   要输出那个整数，用 `int`

   ```
   char c1 = 'a';
   System.out.println((int)c1);JAVA
   ```

3. `char` 是可以进行运算的，其相当于一个整数。***注意与 [[2.2 示例\]](#2.2 程序中 `+` 的使用) 的区别***

   ```
   // 注：(int)'a' = 97
   char c1 = 'a' + 1;				// 相当于 char c1 = 'b'
   System.out.println('a' + 1);	// 这个代码输出 98
   System.out.println("a" + 1);	// 这个代码输出 a1
   ```

4. 字符允许使用转义符（*见 [1.8 Java 转义字符]*）

   ```
   char c = '\u0041';
   ```

   **转义序列 \u 能出现在引号外。所有这些转义序列会在解析代码前得到处理**

   - 以下字符串是空串：

     ```
     String s = "\u0022+\u0022";
     ```

     因为 \u0022 表示引号。该代码等同于以下代码

     ```
     String s = "" + "";
     ```

   - 以下注释会报错：

     ```
     // \u000A is a newline
     ```

     因为 \u000A 是换行符。在解析前会得到处理。在程序看来，上述注释等于以下写法

     ```
     // 
     is a newline
     ```

   - 以下注释也会报错：

     ```
     // look inside c:\users
     ```

     因为程序认为，\users 不是一个合法的转义字符

   - 在某些场合下这种写法似乎也能实现：

     ```
     int\u005B\u005D a;			// int[] a; 一个数组
     ```

### 2.6.2 字符本质与编码表

- 字符类型的本质，是把字符对应的码值编程二进制，存储。显示时将二进制代码转化为码值，找到对应的字符。

- 字符与码值的对应关系是字符编码表规定的。

  > ASCII 编码表，占用 1 byte，共有 128 个字符。
  >
  > Unicode 编码表，占用 2 byte，字母汉字都占用 2 byte，这样可能浪费空间。0 - 127 的字符与 ASCII 相同，所以兼容 ASCII。
  >
  > UTF-8 编码表，根据不同符号大小可变（1 - 6 byte），字母占用 1 byte，汉字占用 3 byte。是 Unicode 的改进，是互联网上使用最广的 Unicode 实现方式。
  >
  > GBK 编码表，可以表示汉字，字母占用 1 byte，汉字占用 2 byte。
  >
  > GB2312 编码表，可以表示汉字（GB2312 < GBK）
  >
  > BIG5 编码表，可以存放繁体中文（香港，台湾）

- UTF-16 编码采用不同长度的编码表示所有 Unicode 码点。包含从 U+0000 到 U+FFFF 的经典 Unicode 代码（16位，1 个代码单元），以及 U+10000 到 U+10FFFF 的辅助字符（32位，2 个代码单元）

- 在 Java 中，char 类型描述的是 UTF-16 编码中的 1 个代码单元。

  字符串中的一个辅助字符（如 🎶）可能占用 2 个代码单元。这个场合，使用 char 可能会导致错误

  ```
  String str = "🎶Melody🎶";
  char c = str.charAt(1);			// <———— 这个场合，c 是 🎶 符号的第二个代码单元而非 'M'
  ```

  **因此，一般不建议在程序中使用 char 类型**

## 2.7 布尔类型

> `boolean` 只允许取值 `ture` 或 `false` ，没有 `null`。适用于逻辑运算，通常用于程序流程控制
>
> `if` `while` `do-while` `for`

**使用细节：**

1. 不可以用 0 或 非0 的整数替代 `false` 或 `ture` 。这点和 C语言 不同。

2. 不能让布尔类型转换为其他类型。如需转换，请使用如下方法：

   ```
   boolean b = true;
   int n = b ? 0 : 1;
   ```

   ***——见 [[3.5 三元运算符\]](#3.5 三元运算符)***

## 2.8 基本数据类型转换

### 2.8.1 自动类型转换

> 自动类型转换：Java 在进行赋值或运算时，精度（容量）小的类型自动转换为精度（容量）大的类型。
>
> `char` > `int `> `long` > `float` > `double`
> `byte` > `short` > `int `> `long` > `float` > `double`
>
> 例子：`int a = 'c'` 或者 `double b = 80`

#### #2.8.1.1 使用细节

1. 有多种类型数据混合运算时，系统会将所有数据转换成容量最大的那种，再进行运算。

2. 如若把大精度（容量）数据赋值给小精度（容量）类型，就会报错（小数由于精度原因，大赋小会丢失精度，必不可用。但整数大赋小时：1.赋予具体数值时，判断范围。2.变量赋值时，判断类型。反之进行自动类型转换。

3. `byte` `short` `char` 三者不会相互自动转换，但可以计算。计算时首先转化为 `int`。

   > `byte a = 1;`
   >
   > `byte b = 1;`
   >
   > `a + b` 结果是 `int` 类型

4. `boolean` 类型不参与自动转换

5. 自动提升原则：表达式结果的类型自动提升为操作数中最大的类型。

### 2.8.2 强制类型转换

> 强制类型转换：自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时加上强制转换符 `( )` ，但**可能造成精度降低或溢出**，要格外注意。

#### #2.8.2.1 使用细节

1. 当进行数据从大到小转换时，用强制转换。

2. 强制转换只能对最近的操作数有效，往往会使用 `( )` 提升优先级。

   ```
   int a = (int)(3 * 2.5 + 1.1 * 6);
   ```
   
3. `char` 可以保留 `int` 的常量值，但不能保存其变量值。此时需要强制类型转换。

   ```
   int a = 10;
   char b = 10;
   char c = (char)a;
   ```

4. `byte` `short` `char` 在进行运算时，当作 `int` 处理。

### 2.8.3 基本数据类型和 `String` 的转换

- 基本类型转 `String`：基本数据类型加上 `" "`。即利用了 ***[[2.2\]](#2.2 程序中 `+` 的使用)*** 中的方法。

  ```
  int n1 = 100;
  String s = n1 + "";
  System.out.println(n1 + "" + n1 + "" + n1 + "");
  ```

- `String` 转基本数据类型：通过基本数据类型的包装类调用 `parseXX` 方法。

  ```
  String s = "100";
  int n1 = Interger.parseInt(s);
  ```

  特别的，把 `String` 转换为 `char`

  ```
  char c = s.charAt(0);		// 得到 s 字符串中的第一个字符。
  ```

#### #2.8.3.1 使用细节

1. 将 `String` 转成基本数据类型时，要保证其能转换为有效数据。即不能把 `"Hello"` 转换成 `int`。
2. 如果格式不正确，会抛出[异常](./java语法（下）.md#11 异常（Exception）)，程序会中止。

# 3 运算符

> 运算符：一种特殊的符号，用于表示数据的运算、赋值和比较等。

## 3.1 算数运算符

> 算术运算符是对数值类型的变量进行运算的运算符，在 Java 程序中使用得非常多。其运算结果是一个数值量。

- `+` ; `-` ; `*` ; `/` ：加（正）、减（负）、乘、除

  > `5 / 2 = 2;` 因为是 `int`。同理 `5.0 / 2 = 2.5`

- `%` ：取模（求余数），结果和被取模数同号。其实 `a % b == a - (int)a / b * b;`

  > `11 % 9 = 2;`
  >
  > `-11 % 9 = -2;`
  >
  > `11 % -9 = 2;`
  >
  > `-11 % -9 = -2;`

- `++` ：自增。

  `++i` 先自增后赋值；`i++` 先赋值后自增

  ```
  int i = 10;
  int j = ++i; 	//等价于 i = i + 1; j = i; 此时 i = 10; j = 10`
  int k = i++; 	//等价于 k = i; i = i + 1; 此时 i = 11; k = 10`
  i = i++; 		//系统会先后执行 int temp = i;     i = i + 1;     i = temp
  i = ++i; 		//系统会先后执行 i = i + 1;     int temp = i;     i = temp
  ```

- `--` ：自减。和 `++` 同理。

- `+` ：字符串相加

## 3.2 关系运算符（比较运算符）

> 关系运算符结果都为 `boolean` 型，要么是 `ture` 要么是 `false`。其关系表达式经常用在 `if` 结构的条件中或循环结构的条件中。

- `==` ：相等于。`8 == 7` 结果 `false`
- `!=` ：不等于
- `<` `>` ：小于、大于
- `<=` `>=` ：小于等于、大于等于
- `instanceof` ：检查是否是类的对象。`"a" istanceof String` 结果 `ture`

### 3.2.1 使用细节

1. 关系运算符结果都是 `boolean` 型，要么是 `ture` ，要么是 `false`
2. 关系运算符的表达式，称为*关系表达式*
3. 比较运算符 `==` 不要误写为 `=`
4. Java 允许将 `==`、`!=` 两种运算用于任何数据类型

## 3.3 逻辑运算符

> 用于连接多个条件（多个关系表达式），最终的结果也是一个 `boolean` 值。

- `&&` ：短路与。`a` `b` 同时为 `ture`，则结果为 `ture`，否则为 `false`。

- `&` ：逻辑与。`a` `b` 同时为 `ture`，则结果为 `ture`，否则为 `false`。

  `&&` 与 `&` 的区别，在于 `a && b` 的场合，`a = false` 时，则 `b` 不判断。而 `&` 会完成判断。开发中多用 `&&` ，因为其效率更高。

  ```
  int a = 1;
  int b = 1;
  
  if (a++ > 1 && ++b < 1) System.out.println("Nothing happened");
  /*
      此时 a 经历了先判断后自增，返回 false 并且 a = 2
      但此时 b = 1; 因为 a = false; 所以 ++b 不执行。
  */
  ```

- `||` ：短路或。`a` `b` 任一为 `ture`，则结果为 `ture`，否则为 `false`。

- `|` ：逻辑或。`a` `b` 任一为 `ture`，则结果为 `ture`，否则为 `false`。

  > 两者的区别和`&&` 与 `&` 相似，若第一个为 `ture` ，则 `||` 不会判断第二个。

- `!` ：取反。`a` 为 `ture`，则结果为 `false`。反之为 `ture`。

- `^`：逻辑异或。`a` `b` 不同时，结果为 `ture`，否则为 `false`。

## 3.4 赋值运算符

> 将某个运算后的值，赋给指定变量

- 基本赋值运算符：`=`

- 符合赋值运算符：`+=` ; `-=` ; `*=` ; `/=` ; `%=` 等

  > `a += b` 等价于 `a = a + b`。其余同理。

### 3.4.1 使用细节

1. 运算顺序从右往左。

   ```
   int num = a + b + c;	// 先运行(a + b + c)，再结算int num =
   ```

2. 运算符左边只能是变量，右边可以是变量、表达式、常量值。

3. 复合赋值运算符会进行类型转换。

   ```
   byte b = 2; b += 3;		// 此时 b += 3 等价于 b = (byte)(b + 3)
   b++;					// 同理
   ```

## 3.5 三元运算符

> 基本语法：`条件表达式 ? 表达式1 : 表达式2;`
>
> 运算规则：如果条件表达式为 `ture` ，运算的结果是表达式1；反之为表达式2。
>
> ```
> int a = 10;
> int b = 11;
> int result = (a == b ? a++ : b++);		// 此时 a = 10  result = 11  b = 12
> ```

### 3.5.1 使用细节

1. 表达式1 和 表达式2 要为可以赋给接受变量的类型（或可以自动转换，或进行强制转换）

2. 三元运算符可以转成 `if--else`

3. 三元运算符是一个整体。

   ```
   Object obj = true ? new Integer(1) : new Double(2.2);
   System.out.print(obj)
   ```

   上例中，系统将会输出 `1.0`

   因为 三元运算符 是一个整体，所以根据 [2.8.1.1.1] 发生了类型转换。

## 3.6 运算符优先级

[一个网页，可以查看详细优先级](http://c.biancheng.net/view/794.html)

| 运算符（优先级从高到低）                                     | 结核性   |
| :----------------------------------------------------------- | -------- |
| `[]`、`()` 方法调用                                          | 从左向右 |
| `!`、`~`、`++`、`--`、`+`（一元运算）、`-`（一元运算）、强制类型转换、new | 从右向左 |
| `*`、`/`、`%`                                                | 从左向右 |
| `+`、`-`                                                     | 从左向右 |
| `<<`、`>>`、`>>>`                                            | 从左向右 |
| `<`、`>`、`<=`、`>=`、instanceof                             | 从左向右 |
| `==`、`!=`                                                   | 从左向右 |
| `&`                                                          | 从左向右 |
| `^`                                                          | 从左向右 |
| `|`                                                          | 从左向右 |
| `&&`                                                         | 从左向右 |
| `||`                                                         | 从左向右 |
| `?:`（三元运算符）                                           | 从左向右 |
| `=`、`+=`、`-=`、`*=`、`/=`、`%=`、`&=`、`^=`、`|=`、<<=`、`>>=`、`>>>=` | 从右向左 |

1. 运算符有不同优先级。优先级高的总是优先于低的。
2. 只有单目运算符、赋值运算符是从右向左运算的。

## 3.7 标识符

> Java 对各种变量、方法和类等命名时使用的字符序列称为标识符
>
> 凡是自己可以起名字的地方都叫标识符 `double height = 0.0;`

### 3.7.1 命名规则

1. 标识符由 26 个大、小写英文字母，0 - 9 阿拉伯数字，_ 或 $ 符号组成。

2. **数字不能开头**。 错误示范：`int 3a = 1;`

3. 不能使用关键字和保留字（可以包含）。

4. 严格区分大小写，长度无限制。

5. 不能包含空格。

6. 与多数编程语言不同。Java 可以用任何 Unicode 字符（特殊字符除外）作为标识符。但不推荐这么做

   > **来 String 一只猫：**

   ```
   String ᓚᘏᗢ = "✪ ω ✪";				// 喵？
   ```

### 3.7.2 命名规范

1. 包名：多单词组成时所有字母都小写：aaa.bbb.ccc
2. 类名、接口名：多单词组成时，采用大驼峰法，所有单词的首字母大写：XxxYyyZzz
3. 变量名、方法名：多单词组成时，采小驼峰法（驼峰法），第一个单词首字母小写，第二个开始每个单词首字母大写：xxxYyyZzz
4. 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ
5. 更详细的规则查看 [Java 编码规范](https://developer.aliyun.com/article/709470)

## 3.8 输入与输出

> 为满足读取用户输入、输出的需求，Java 提供了几个基本类

### 3.8.1 Scanner 类

> 在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取。
>
> `Input.java` ，需要一个 扫描器（对象），就是 Scanner
>
> Scanner 属于 java.util 包。其包含许多方法

**示例：**

```
import java.util.Scanner;		//[1] 导入
    public class Code3_8_1{
    public static void main(String[] args){
        Scanner aScannerName = new Scanner(System.in);	//[2] 创建 Scanner 对象
        System.out.println("\n输入点什么吧！");
        String pointSomething = aScannerName.next();	//[3] 接收用户输入
        System.out.println("\n接下来，输入一个数字吧！");
        double aNumber = aScannerName.nextDouble();		//[3] 接收用户输入
        System.out.println("\n你输入的\"点什么\"是:\"" 
        	+ pointSomething + "\"\n你输入的\"一个数字\"是：\"" 
        	+ aNumber + "\"");
    }
}
```

> 1. 导入该类所在的包
> 2. 创建该类对象（声明变量）
> 3. 调用里面的功能，接收用户输入

构造方法：

- `new Scanner(System.in)`：该方法接收一个参数（输入源）。其中 `System.in` 代表标准输入流。默认情况指键盘。

  ***—— 见 [[17.2.3.4 标准输入 / 输出流\]](./java语法（下）.md# #17.2.2.4 转换流 `InputStreamReader` 和 `OutputStreamWriter`)***

常用方法：

- `String next()`：读取下一个输入对象

  Scanner 对象用空白（空格、水平制表符或回车换行符）作为输入的分隔元素

- `Double nextDouble()`：读取下一个 double

  `Int nextInt()`：读取下一个 int

- `String nextLine()`：读入当前行的所有输入，直到行尾

- `boolean hasNext()`：输入中是否还有其他单词

  `boolean hasNextInt()`、`boolean hasNextDouble()`

### 3.8.2 格式化输出

> System.out 标准输出流。调用该流方法以输出内容至控制台窗口

- `println(String s)`：输出字符，结束后换行

  `print(String s)`：输出字符，结束后不换行

  `println(int n)`、`println(char c)`、`println(Object obj)`……

- `printf(String format, Object ... args)`：格式化输出

  ```
  System.out.printf("%s，你来啦，给你 %d 拳", "柏枝凪斗", 1);	// <———— 给了柏枝凪斗一拳
  ```

  以 % 开头的 *格式说明符* 都用相应参数替换。格式说明符尾部的转换符表示要格式化的数值类型

  | 转换符 | 类型           |      | 转换符   | 类型                  |
  | ------ | -------------- | :--: | -------- | --------------------- |
  | d      | 十进制整数     |      | s        | 字符串                |
  | x      | 十六进制整数   |      | c        | 字符                  |
  | o      | 八进制整数     |      | b        | 布尔值                |
  | f      | 定点浮点数     |      | h        | 散列码                |
  | e      | 指数浮点数     |      | tx 或 Tx | 日期时间（T强制大写） |
  | g      | 通用浮点数     |      | %        | 百分号                |
  | a      | 十六进制浮点数 |      | n        | 行分隔符              |

  也能指定控制格式化输出外观的各种标志

  ```
  System.out.printf("% (4.12f", Math.PI);	// <————— 保留 12 位，正数添加空格，负数添加括号
  ```

  | 标志                  | 目的                                                         |
  | --------------------- | ------------------------------------------------------------ |
  | +                     | 打印正数和负数的符号                                         |
  | （空格）              | 在正数前添加空格                                             |
  | 0                     | 数字前面补 0                                                 |
  | -                     | 左对齐                                                       |
  | (                     | 负号被括号环绕                                               |
  | ,                     | 添加分组分隔符                                               |
  | #（对于 f 格式）      | 包含小数点                                                   |
  | #（对于 x 或 0 格式） | 添加前缀 0x 或 0                                             |
  | $                     | 指定要格式化的参数索引：%1$d 以十进制打印第 1 个参数         |
  | <                     | 格式化前面说明的数值：%d%<x 十进制打印后，再以十六进制打印一遍 |

### 3.8.3 NumberFormat 类

> Java 提供的格式化输出功能，能使打印或显示是信息更美观
>
> NumberFormat 类属于 Java 标准类库，在 java.text 包中
>
> NumberFormat 类不能直接创建对象。利用类中的静态方法获取一个对象实例

获取实例：

- `NumberFormat.getInstance()`：返回当前默认语言环境的默认数值格式
- `NumberFormat.getCurrnecyInstance()`：返回当前默认语言环境的通用格式
- `NumberFormat.getNumberInstance()`：返回当前默认语言环境的通用数值格式
- `NumberFormat.getPercentInstance()`：返回当前默认语言环境的百分比格式

常用方法：

- `format(num)`：获取 num 的格式化语句

- `setMaximunFactionDigits(n)`：将该格式的小数部分允许的最大位数设置为 n

  `setMinimunFactionDigits(n)`：将该格式的小数部分允许的最小位数设置为 n

- `setMaximunIntegerDigits(n)`：将该格式的整数部分允许的最大位数设置为 n

  `setMinimunIntegerDigits(n)`：将该格式的整数部分允许的最小位数设置为 n

### 3.8.4 DecimalFormat 类

> 与 NumberFormat 类不同，DecimalFormat 类可以直接实例化对象。

实例化：

- `new DecimalFormat(pattern)`

  其中 pattern 是一个 String，代表格式化处理模式。如

  ```
  DecimalFormat df = new DecimalFormat("0.###");		//格式对象，保留 3 位小数
  JAVA
  ```

常用方法：

- `format(num)`：获取 num 的格式化语句
- `applyPattern(pattern)`：变更要使用的格式

## 3.9 进制

- 二进制：数字有 0 - 1，满 2 进 1，以 `0b` 或 `0B` 开头
- 十进制
- 八进制：0 - 7，满 8 进 1，以 `0` 开头表示
- 十六进制：0 - 9 及 A - F，满 16 进 1，以`0x` 或 `0X` 开头。此处的 A - F 不分大小写。

### 3.9.1 进制的转换

- 其他进制 转 十进制：略
- 十进制 转 其他进制：将该数不断除以对象进制数，直到商为0为止，将每步得到的余数倒过来。
- 二进制 与 八进制 或 十六进制 互相转换：二进制 从低位开始，每 3 位一组，转成对应的 八进制 即可。反之同理。十六进制亦同理（每 4 位一组）。

### 3.9.2 原码、反码、补码

对于有符号数而言：

1. 二进制的最高位是符号位：0表示正数，1表示负数。
2. 正数的原码、反码、补码都一样。
3. 负数的反码 = 原码符号位不变，其他位取反（0 变 1，1 变 0）
4. **负数的补码 = 反码 + 1。也就是说，负数的反码 = 补码 - 1。**
5. 0 的反码、补码都是 0。
6. Java 没有无符号数。换言之，Java 的数都是有符号的。
7. **计算机运算时，都是以补码的方式来运算的。**
8. **当我们看运算结果时，要看其原码。**

## 3.10 位运算符

- `&` 按位与：两位都为 1，结果为 1，否则为 0

- `|` 按位或：两位有一个为 1，结果为 1，否则为 0

- `^` 按位异或：两位不同，结果为 1，否则为 0

- `~` 按位取反：把 0 变 1，1 变 0

  以下是几个示例：

  - `2 & 3`：

    > 2 的原码：00000000 00000000 00000000 00000010
    >
    > 2 的补码：00000000 00000000 00000000 00000010
    >
    > 3 的原码：00000000 00000000 00000000 00000011
    >
    > 3 的补码：00000000 00000000 00000000 00000011
    >
    > 补码运算结果：00000000 00000000 00000000 00000010
    >
    > 结果转成原码：00000000 00000000 00000000 00000010
    >
    > 运算结果：2

  - `~-2`：

    > 得到 -2 的原码：10000000 00000000 00000000 00000010
    >
    > 得到 -2 的反码：11111111 11111111 11111111 11111101
    >
    > 得到 -2 的补码：11111111 11111111 11111111 11111110
    >
    > 补码运算结果：00000000 00000000 00000000 00000001
    >
    > 结果转成原码：00000000 00000000 00000000 00000001
    >
    > 运算结果：1

  - `~2`：

    > 2 的原码：00000000 00000000 00000000 00000010
    >
    > 2 的补码：00000000 00000000 00000000 00000010
    >
    > 补码运算：11111111 11111111 11111111 11111101
    >
    > 结果转成反码：11111111 11111111 11111111 11111100
    >
    > 反码转成原码：10000000 00000000 00000000 00000011
    >
    > 运算结果：-3

- `>>` 算术右移：低位溢出，符号位不变，用符号位补溢出的高位

- `<<` 算数左移：符号位不变，低位补 0

- `>>>` 逻辑右移（无符号右移）：低位溢出，高位补 0

  下面是示例：

  - 将数字 1 算术右移 2 位：`int a = 1 >> 2`

    > 1 的补码：00000000 00000000 00000000 00000001
    >
    > 补码结果：00000000 00000000 00000000 00000000
    >
    > 结果：00000000 00000000 00000000 00000000

  - 将数字 1 算术左移 2 位：`int b = 1 << 2`

    > 1 的补码：00000000 00000000 00000000 00000001
    >
    > 补码结果：00000000 00000000 00000000 00000100
    >
    > 结果：00000000 00000000 00000000 00000100

  也就是说，`1 << 2` 本质是 `1 * 2 * 2 = 4`

  而 `1 >> 2` 本质是 `1 / 2 / 2 = 0`

**使用细节：**

1. 位运算符只对整型、字符类型有效

2. 移位运算中，左侧操作 int 的场合，右侧操作数以 32 取模；long 的场合，右侧操作数以 64 取模。

   ```
   int n = 20;
   n >>= 32;			//这个场合，n 不改变。这样能保证左侧数字不被全部移走
   ```

# 4 程序控制结构

> 程序运行的流程控制决定程序是如何执行的，是我们必须掌握的。主要分为：顺序控制、分支控制、循环控制。

## 4.1 顺序控制

> 程序从上到下逐行执行，中间没有任何判断和跳转（默认的控制顺序）
>
> 比如：Java 定义变量时采用合法的前向引用。

```
graph LR
A(A语句)-->B(B语句)-->C(C语句)-->D(D语句)-->E(...)
```

语句：Java 中最小的执行单位。语句分为 单语句 和 复合语句。

- 单语句：通常意义的一条语句。语句间以分号 `;` 分隔。

- 复合语句：一对大括号括起来的语句组。也称为 “块”

  ```
  {
      语句1; 
      语句2;
      ...
  }
  ```

  块中可以有多条语句。块后没有分号 `;`

## 4.2 分支控制 `if-else`

> 让程序有选择的执行。主要分为：单分支控制、双分支控制

### 4.2.1 单分支控制

```
if (条件表达式) 语句;
```

特别地，把代码块（复合语句）作为语句的场合也能这样写：

```
if (条件表达式) {
 执行代码块;
}
```

当条件表达式为 `ture`，就会执行 `{执行代码块;}`；如果为 `false` 则不执行。特别地：如果 `{执行代码块;}` 中只有一条代码，也可以不写 `{ }`（但还是建议写上）

### 4.2.2 双分支控制

```
if (条件表达式) {
 执行代码块;
} else {
 执行代码块2;
}
```

当条件表达式为 `ture`，就会执行 `{执行代码块1;}`；如果为 `false` 则执行 `{执行代码块2;}`。

### 4.2.3 多分支控制

```
if (条件表达式) {
 执行代码块;
} else if (条件表达式2) {
 执行代码块2;
} else if (条件表达式3) {
 执行代码块3;
}
...
else {
 执行代码块n；
}
```

特别地：多分支可以没有 `else`。此时如果条件都不成立，则无执行入口

### 4.2.4 嵌套分支

> 在一个分支结构中又完整嵌套了另一个完整的分支结构。里面的分支称为内层分支，外面的分支称为外层分支。

Java 规定，else 子句属于逻辑上距其最近，且没有匹配 else 的 if 语句：

> ```
> int n = 0;
> if (n > 0) n++;
> if (n > 1) n++;
> else n--;			//属于上面这个 if 语句
> ```
>
> 这个场合，这个 else 语句属于上面的 `if (n > 1)` 这个语句

要想改变那个匹配关系，要使用 `{ }` 改变语句结构：

> ```
> int n = 0;
> if (n > 0) {
>     n++;
> 	if (n > 1) n++;  
> } else n--;JAVA
> ```

**规范：嵌套尽量不超过 3 层（可读性不好）**

## 4.3 `switch` 分支结构

```
switch(表达式){
	case 常量1:
		语句块1;
		break;			//break 语句可选
	case 常量2:
		语句块2;
		break;			//break 语句可选
	...
	default:			//default 语句可选
		default语句块;
		break;			//break 语句可选
}
```

1. `switch` 关键字，表示 switch 分支。
2. `表达式` 对应一个值。**该值必须是 int 或 char**（char 可以转化为 int）。如果是 byte 或 short 的场合，要提升为 int。不允许 long、double 或 float。
3. `case 常量1;` 表示：当 `表达式` 的值等于 `常量1` ，则执行 `语句块1`。
4. `break;` 表示退出 switch 分支。
5. 当 `表达式` 的值匹配 `常量1` ，则执行 `语句块1`，如果不匹配，则继续匹配 `常量2` ，以此类推。
6. 如果全都不匹配，则执行 `default`。
7. 如果不写 `break;` ，则会发生**穿透**，即不进行判断而继续执行下一语句块。

### 4.3.1 使用细节

1. `表达式;` 数据类型，应和 `case` 后的 `常量` 类型一致，或者是可以自动转换成可以比较的类型。如：输入的是 `char` 而 `常量` 是 `int`

2. switch 中 `表达式` 的返回值必须是：`byte` `short` `int` `char enum` `String`

   ***——`enum` 是什么？详见 [[10.1 枚举 \]](#10.1 枚举)***

3. `case` 语句中的值必须是 常量 或 常量表达式，不能是 变量。

4. `default` 是可选的。没有就不执行。

5. `break;` 用来跳出 switch 分支。如果不写，会持续执行语句，直到分支结束或遇到下一个 `break;`

### 4.3.2 与 `if-else` 分支结构的取舍

- 如果判断的具体数值比较分散，且符合 ***[[4.3.1中的使用细节\]](#4.3.1 使用细节 )*** ，推荐使用 switch。
- 对区间判断的场合，对结果为 boolean 类型的判断，使用 `if-else`。

## 4.4 `for` 循环控制

> 让代码可以循环执行。

```
for(循环变量初始化;循环条件;循环变量迭代){
循环操作（代码块）;
}
```

- `for` 关键字，表示循环控制
- 四个要素：1. 循环变量初始化 2. 循环的条件 3. 循环的操作 4. 循环变量迭代

所有循环开始前仅一次进行初始化。直到循环条件变为 false 前，执行循环操作。每轮循环结束后，进行循环变量迭代。

- 循环操作可以有多条语句
- 如果循环操作只有一条语句，可以省略 `" "`，但建议不省略

### 4.4.1 使用细节

1. 循环条件是返回一个 boolean 值（`ture` 或 `false`）的公式。

   循环条件可以为空。这个场合，默认为真（true）

2. `for(;循环条件;){ }` 其中的初始化和变量迭代可以写在别处，但 `;` 不能省略。如果不写在别处，那个 `循环变量初始化` 中声明的变量只能在该 for 循环中使用。

3. 控制台用 ctrl + c 强制结束一个流程

4. 循环初始值可以有多条初始化语句，但要求类型一样，并用 `,` 隔开。

   变量迭代也可以有多条代码，用 `,` 隔开。

### 4.4.2 for each（泛型 for 循环）

> 泛型 for 循环（增强 for 循环）能用来依次处理数组（或其他元素集合）中的每个元素，而不必考虑下标值

```
for(int i : nums){						//其中 nums 是一个一维 int 数组
	System.out.println(i);
}
```

上述写法（增强 `for` 写法）类似于以下写法

```
for(int i = 0; i < nums.length; i++){
	System.out.println(nums[i]);
}
```

泛型 for 循环适用于数组或一个实现了 Iterable 接口的对象。泛型 for 循环的本质是一个 Iterator（迭代器）

***—— 迭代器，见 [[用 Iterator 遍历元素\]](# 迭代器 Iterator)***

## 4.5 `while` 循环控制

```
while(循环条件){
 循环体(代码块);
 循环变量迭代;
}
```

`while` 也有四要素，只是位置和 `for` 不同

### 4.5.1 使用细节

1. 循环条件是返回一个 boolean 值（`ture` 或 `false`）的公式。

   while 循环中，循环条件不能为空。

2. `while` 循环是先判断再执行语句。

## 4.6 `do..while` 循环控制

```
do{
循环体;
循环变量迭代;
}while(循环条件);
```

1. `do` `while` 是关键字
2. 也有四要素，位置不同
3. 先执行，再判断。也就是说，一定会至少执行一次
4. **最后有一个 `;`**
5. `while` 与 `do..while` 区别：“要账”

### 4.6.1 使用细节

1. 循环条件是返回一个 boolean 值（`ture` 或 `false`）的公式。
2. `do..while` 循环是先执行再判断的语句。因此至少执行一次。

## 4.7 多重循环控制

将一个循环放在另一个循环体内，就形成了嵌套循环。建议一般使用两层，最多不超过三层。

嵌套循环 是把 内层循环 当成 外层循环 的 循环体。只有内层 `false` 时才可能结束当层循环。

若内层执行 n 次，外层 m 次，则合计会循环 n*m 次

> 以下是一个示例（乘法口诀）
>
> ```
> public class Code4_7{
>    	public static void main(String[] args){
>           int a = 1;	//声明第一个乘数
>           int b = 1;	//声明第二个乘数
>               do{
>                   //直到 a > b 为止，a 不断增长，并让两数相乘，输出公式
>                   do{
>                       System.out.print(a + " * " + b + " = " + a * b + "\t");
>                       a++;
>                   } while (a <= b);
>                   //把 a 重置为 1，让 b 增长，然后循环
>                   a = 1;
>                   System.out.println();
>                   b++;
>               } while (b <= 9);
>        }
> }
> ```

## 4.8 跳转控制语句

> 跳转控制语句用于分支或循环中，以便程序员更好控制程序执行方向

### 4.8.1 标签

```
a:{
b:	{
c:		{
   ...
		 berak b;
		}
	}
}
```

1. `a:` `b:` `c:` 是标签，名字由程序员指定
2. `break` 后指定哪个标签就退出到哪里
3. **实际开发中，尽量不要使用标签**

### 4.8.2 break

> 用于中止一个语句块的执行

语法：`break;`

break 可以被用在三种场合中

- switch 语句中，以跳出判断（结束穿透）

- for、while、do…while 循环语句中，以跳出循环

- 语句块中，以跳过本块中所有剩余语句

  `break` 语句出现在多层嵌套的语句块中时，可以通过 **标签** 指明要终止的时哪一层语句块。

### 4.8.3 continue

> 在循环中出现。用于结束本次循环，继续下一次循环

语法：`continue;`

进行下次循环前，仍会判断循环条件是否满足

在多层嵌套循环中，可以通过标签指出跳出哪次循环（同 `break`）

### 4.8.4 return

> 用于方法。表示跳出所在的方法

语法：`return;`

方法有返回值的场合，将返回值写在 return 后：`return 值;`

***——见 [[6.2 成员方法\]](#6.2 成员方法)***

如果写在 主方法 则跳出程序

# 5 数组、排序和查找

> 数组：可以存放多个同一类型的数据。数组也是一种数据，是引用类型。
>
> 即：数组就是一组数据。

## 5.1 一维数组

> 数组可以是多个相同类型数据的组合，实现对这些数据的统一管理。
>
> 数组中的元素可以是任何数据类型。包括基本类型和引用类型。
>
> 数组的下标从 0 开始。且必须在指定范围内使用，否则报错。
>
> 数组属于 引用类型，数组型数据是 对象（Object）
>
> 数组创建后，如果没有赋值，有默认值：int（0），short（0），byte（0），long（0L），float（0.0F），double（0.0），char（\u0000），boolean（false），String（null），Object（null）

**数组的构造方法：**

使用数组的步骤：1.声明数组并开辟空间 2.给数组各个元素赋值 3.使用数组

- 构造方式1：动态初始化

  ```
  int[] ints = new int[5];				// 创建了数组 name，存放5个int
  int ints2[] = new int[1];				// 这种写法也行
  ints[2] = 15;							// 访问数组第3个数
  ```

- 构造方式2：动态初始化

  ```
  char[] chars;							// 先声明数组 name，此时数组是 null
  chars = new char[2];					// 分配内存空间，可以存放数据了
  chars[1] = '\t';
  ```

- 构造方式3：静态初始化

  ```
  boolean[] bools = {true, false, true, false};
  String[] strs = new String[]{"阿伟，你又在打电动噢", "烦啦"};
  ```

  确切知道数组每个元素的场合可以用这个方法。

**数组的使用方法：**

- 访问数组元素：`数组名[元素下标]`

  其中，元素下标从 0 开始编号。如：访问 strs 数组的第一个元素 `strs[0]`

- 数组长度：`数组名.length`

  是一个 int 值。不能通过试图改变该值来改变数组容量

### 5.1.1 数组赋值机制

1. 基本数据类型赋值，赋值方式是值拷贝。这个值就是具体的数据，且互不影响

2. 数组在默认情况下是引用传递，赋的值是地址，赋值方式为引用传达。

   ```
   int[] array1 = {0, 0, 0};
   int[] array2 = array1;
   array2[0] = 100;
   ```

   上述情况下，`array1[0]` 也会变成 `100`。因为数组在 JVM 的 栈 里是一个地址，指向 堆 里的一个空间。这两个数组在上述情况下指向同一空间。

   ```
   int[] array1 = {0, 0, 0};
   int[] array2 = new int[array1.length];
   for (int i = 0;i < array1.length;i++) {
       array2[i] = array1[i];
   }
   ```

   上述方式拷贝后，两数组相互独立。

### 5.1.2 数组的扩容

当数组达到上限时，创建一个容量更大的新数组。将旧数组的元素依次放入，之后替换旧数组。

以下是一个扩容方法([方法来源](./数据结构.md))：

```
	private void grow(){
        if (size == maxSize){
            maxSize *= 2;
            int[] newArr = new int[maxSize];
            System.arraycopy(arr, 0, newArr, 0, size);
            arr = newArr;
        }
    }
```

## 5.2 二维数组

```
int[][] ints;					// 声明一个二维数组
int[] ints2[];					// 也能这样声明
int ints3[][];					// 这样也行
int[] x,y[];					// 声明了两个数组，一个是 int[] x 一个是 int[][] y
								// 把 int[] 视作一个类型，就能很好地理解这个写法
```

二维数组实际是由多个一维数组组成的，它的各个元素的长度可以相同，也可以不同。

数组是一个对象，所以二维数组的元素存放的是一维数组的地址。

**二维数组构造方法：**

- 构造方法1：动态初始化

  ```
  int[][] many_ints = new int[3][4]	// 创建 有3个 包含4个元素的一维数组 的二维数组
  ```
  
- 构造方法2：动态初始化

  ```
  double[][] many_doubles;			// 先声明变量
  many_doubles = new double[3][4];	// 再开辟空间
  ```

- 构造方法3：动态初始化-列数不确定

  ```
  char[][] many_chars = new char[3][];	// 创建一个三行列数不确定的二维数组
  for (int i = 0; i < 3; i++) {
      many_chars[i] = new char[i + 1];	// 此时，每个数组空间依次增大
  }
  ```

- 构造方法4：静态初始化

  ```
  int[][] many_many = {{1, 3}, {4, 10, 2}, {95}};
  ```

**二维数组使用方法：**

- `ints.length`：该二维数组的长度，这里是 3
- `ints[0]`：该二维数组的第一个子数组
- `ints[0].length`：该二维数组的第一个子数组的长度，这里是 4
- `ints[1][0]`：该二维数组第二个子数组的第一个元素的值，这里是 21

~~这是一维数组：int[] a、这是二维数组：int[][] b。好了，现在来写一个堆排序吧~~

## 5.3 查找算法

在 Java 中，常用的查找有 4 种：

- 顺序查找（遍历）
- 二分查找
- 插值查找
- 斐波那契查找

### 5.3.1 线性查找

逐一比对，直到发现目标值

```
public static int seqSearch(int[] array, int target) {
    for (int i = 0; i < array.length; i++) {
        if (array[i] == target) return i;
    }
    return -1;
}
```

### 5.3.2 二分查找

二分查找要求数组必须是有序数组。

每次取出那个中位数。目标值小于中位数的场合，则在较小一侧的范围内继续二分查找。否则在那个较大一侧查找。

递归方式二分查找：

```
public static int binarySearch(int[] array, int target) {
    return binarySearch(array, target, 0, array.length);
}

public static int binarySearch(int[] array, int target, int l, int r) {
    if (l >= r) return -l - 1;
    int p = (l + r) / 2;
    if (target == array[p]) return p;
    else if (target > array[p]) {
        return binarySearch(array, target, p + 1, r);
    } else return binarySearch(array, target, l, p - 1);
}
```

非递归方式二分查找：

```
public static int binarySearch2(int[] array, int target) {
    int l = 0;
    int r = array.length;
    while (r > l) {
        int p = (r + l) / 2;
        if (target == array[p]) return p;
        else if (target > array[p]) l = p + 1;
        else r = p - 1;
    }
    return -l - 1;
}
```

### 5.3.3 插值查找

插值查找类似于二分查找，但其不是取出中位数，而是从自适应的位置取出一个元素

那个自适应的取出位置 $pos=low+(high-low)\times\dfrac{target-arr[low]}{arr[high]-arr[low]}$

上面的 $low$是查找范围的下界，$high$是查找范围的上界，$targett$ 是目标值，$arr[i]$ 是数组第 $i$ 个元素的值

可见，如若那个目标值更靠近某一端，这个自适应的取出位置也会更接近那一端

```
public static int insertSearch(int[] array, int target) {
    if (target > array[array.length - 1]) return -array.length;
    else if (target < array[0]) return 0;
    int l = 0;
    int r = array.length;
    int p = 0;
    while (r >= l) {
        p = l + (target - array[l]) * (r - 1 - l) / (array[r - 1] - array[l]);
        if (target == array[p]) return p;
        else if (target > array[p]) l = p + 1;
        else r = p - 1;
    }
    return -p;
}
```

### 5.3.4 斐波那契查找

斐波那契查找原理与前两种类似，仅仅改变了中间节点的位置。

其中间节点不是中位或插值，而是位于黄金分割点附近。

## 5.4 [排序算法](./数据结构.md#排序算法)



# 6 面向对象编程（基础）

> 面向对象是一种开发软件的方法，使分析、设计和实现一个系统的方法尽可能接近人们认识一个系统的方法。包括三个方面：面向对象分析、面向对象设计、面向对象程序设计。
>
> Java 语言是纯面向对象的语言。其所有数据类型都有相应的类，程序可以完全基于对象编写。

## 6.1 类与对象（OOP）

> 类 就是数据类型。可以是 `int` 也可以是 `人类`
>
> 对象 就是其中具体的实例。可以是 `100` 也可以是 `韩顺平`
>
> 从 类 到 对象，可以称为 创建一个对象，也可以说 实例化一个对象，或者 把对象实例化
>
> 1. 类 是抽象的、概念的，代表一类事物
> 2. 对象 是具体的、实际的，代表一个个具体事物
> 3. 类 是 对象 的模板，对象 是 类 的一个个体，对应一个实例

下面，我们定义了一个类 `Cat` 并创建了一些 对象 `cat1` `cat2`：

```
public class Code6_1{
	public static void main(String[] args){

		Cat cat1 = new Cat();
		cat1.name = "福福";
		cat1.age = 2;
		Cat cat2 = new Cat();
		cat2.name = "妞子";
		cat2.age = 1;
		System.out.println(cat1.name);
	}
}

class Cat{
	String name;
	int age;
}
```

### 6.1.1 属性/成员变量

> 从概念或叫法上看：成员变量 = 属性 = field（字段）

```
class Cat{
	String name;
	int age;
}
```

其中，`String name;` 就是一个成员变量（属性）。

属性可以是基本数据类型，也可以是引用数据类型。

1. 属性的定义语法同变量。

   ```
   访问修饰符 属性类型 属性名
   ```

   - 访问修饰符：控制属性的访问范围。有四种：`publie` `protected` `默认(空)` `private`

2. 属性的定义类型可以为任意类型，包含 基本类型 或 引用类型

3. 属性如果不赋值，有默认值。规则同 *[[5.1 一维数组 \]](#5.1 一维数组)*

### 6.1.2 创建对象

- 先声明再创建：

  ```
  Cat cat1;  				    //声明对象cat1
  cat1 = new Cat();			//创建对象
  ```

- 直接创建：

  ```
  Cat cat2 = new Cat();
  ```

注意事项：

1. 声明对象的场合，只是在内存中建立了一个引用。此时，该地址引用不指向任何内存空间。

   对象的引用，也被称为对象的句柄。

2. 使用 new 运算符创建对象实例时，会为对象分配空间，就会调用类的构造方法。那之后，会将该段内存的首地址赋给刚才建立的引用。

### 6.1.3 访问对象

基本语法：`对象名.属性名`

```
System.out.println(cat1.name);
```

### 6.1.4 类与对象的内存访问机制

> 栈：一般存放基本数据类型（局部变量）
>
> 堆：存放对象（如`Cat cat1 = new Cat()`，是在这里开辟的空间）
>
> 方法区：常量池（常量，比如字符串），类加载信息

1. 创建对象时，先加载 类 信息，然后在 堆 中分配空间，栈 中的对象名被赋予指向那个空间的地址。
2. 之后进行指定初始化。该对象的 属性 中，是 基本数据类型 的直接记录在 堆 中；是 字符串 的记录一个地址，该地址指向 方法区，那里的常量池有该字符串。

## 6.2 成员方法

在某些情况下，我们需要定义成员方法。比如 `Cat` 除了有属性（`name` `age`）外，还可以有一些行为比如玩耍。

```
修饰符 返回数据类型 方法名(形参列表){
	方法体语句;
	returen 返回值;			//返回数据类型是 void 的场合，return语句不是必须的
}
```

1. 方法名必须是一个合法的标识符

2. 返回类型即返回值的类型。如果方法没有返回值，应声明为 void

3. 修饰符段可以有几个不同的修饰符。

   比如

   ```
   public static strictfp final void method() {
           System.out.println("哎咿呀~ 哎咿呀~");
       }
   ```

   其中 public（访问修饰符）、static（static 关键字）、final（final 关键字）

   ***—— 访问修饰符见 [[7.3 访问修饰符\]](#7.3 访问修饰符)***

   ***—— static 关键字见 [[9.1.1 类变量\]](#9.1.1 类变量)***

   ***—— final 关键字见 [[9.5 final 关键字\]](#9.5 final 关键字)***

   ***—— strictfp 关键字见 [[12.1.4 strictfp 关键字\]](./Java语法（下）.md#12.1.4 strictfp 关键字)***

4. 参数列表是传递给方法的参数表。各个元素间以 `,` 分隔。每个元素由一个类型和一个标识符表示的参数组成。

   特别地，`参数类型... 标识符` 这样的参数被称为可变参数

   ***—— 可变参数见 [[6.5 可变参数\]](#6.5 可变参数)***

5. 方法体是实际要执行的代码块。方法体一般用 return 作为方法的结束。

使用 成员方法，能提高代码的复用性。而且能把实现的细节封装起来，供其他用户调用。

```
class Cat{
	String name;				//属性 name
	int age;					//属性 age

	public void speak(){		//方法 speak()
  		System.out.println("喵~");
	}
}
```

> 1. 方法写好后，不去调用就不会输出
> 2. 先创建对象，然后调用方法即可

下面，展示一个含有成员方法的代码：

```
public class Code6_2{
    public static void main(String[] args){
       Cat cat1 = new Cat();
       cat1.speak(10, 15);				//调用 speak 方法，并且给 n1 = 10, n2 = 15
       int r = cat1.speak2(15, 135);	//调用 speak2 方法,返回值赋给 r
    }
}

class Cat{
    public void speak(int n1, int n2){	//(int n1, int n2)形参列表，当前有两个形参 n1,n2
       int res = n1 + n2;
       System.out.println("喵~" + n1 + " + " + n2 +" 的值是：" + res);
    }

    public int speak2(int n1, int n2){	//int 表示方法执行后，返回一个 int 值
       int res = n1 + n2;
       return res;						//返回 res 的值
    }
}
```

### 6.2.1 方法的调用机制

以前文代码为例：

```
...
		int r = cat1.speak2(15, 135);		
...
public int speak2(int n1, int n2){	
   int res = n1 + n2;
   return res;
}
...
```

1. 当程序执行到方法时，在 栈 中开辟一个新的 栈空间。该空间里储存 `n1 = 15` `n2 = 135`，之后计算并储存结果 `res = 150`
2. 当方法执行完毕，或执行到 `return` 语句时，就会返回
3. 把 新栈空间 中的 `res = 150` 返回 main栈 中调用方法的地方
4. 返回后，继续执行该方法的后续代码

### 6.2.2 使用细节

1. 访问修饰符：作用是控制方法的使用范围。

   - 不写（默认访问控制范围）
   - public：公共
   - protected：受保护
   - private：私有

   ***—— 访问修饰符见 [[7.3访问修饰符\]](#7.3 访问修饰符)***

2. 返回数据类型：

   - 一个方法最多有一个返回值。要返回多个结果可以使用 数组。
   - 返回类型为任意类型。包括 基本数据类型 和 引用数据类型。
   - 如果方法要求有返回数据类型，则方法体中最后的执行语句必为 `return 值`，且返回类型必须和 return 的值一致。
   - 如果 返回数据类型 为 `void`，则可以不写 `return` 语句

3. 方法名：

   - 遵循驼峰命名法，最好见名知意，表达出该功能的意思。

4. 参数列表（形参列表）：

   - 一个方法可以有 0 个参数，也可以有多个参数。参数间用 `,` 间隔。
   - 参数类型可以为任意类型，包含 基本类型 和 引用类型。
   - 调用带参数的方法时，一定对应着 参数列表 传入 相同类型 或 兼容类型 的参数。
   - 方法定义时的参数称为 形式参数 ，简称 形参；方法调用时的参数（传入的参数）称为 实际参数，简称 实参。实参 与 形参 的类型、个数、顺序必须一致。

5. 方法体：

   - 写完成功能的具体语句。方法中不能再定义方法。即：方法不能嵌套定义。

6. 调用细节：

   - 同一个类中的方法调用，可以直接调用。

   - 跨类的方法调用，需要创建新对象，然后再调用方法。

     ```
     class C1{
     public void m1(){
     }
     public void m2(){
        m1();					//同一个类中的方法调用，可以直接调用。
     }
     }
     
     class C2{
     public void m3(){
        C1 c = new C1();
        c.m2();					//跨类的方法调用，需要创建新对象，然后再调用方法。
     }
     }
     ```

### 6.2.3 成员方法传参机制

Java 语言对对象采用的是 **值传递**，方法得到的总是那个传入对象的副本。

- 方法不能修改基本数据类型的参数。基本数据类型传递的是一个值，形参不影响实参。

- 方法可以改变对象参数的状态。

  引用类型传递的是一个地址，形参和实参指向一处，两者总会相关。

  但改变那个形参地址指向的场合，实参的指向不会改变。

## 6.3 方法递归调用

> 递归：即方法自己调用自己，每次调用时传入不同变量。递归有助于编程者解决复杂问题，同时可以让代码变得简洁。

> 下面，示范一个斐波那契数列方法
>
> ```
> class T{
>    public int fib(int n){
>        if(n == 1 || n == 2){
>            return 1;
>        }else{
>            return (fib(n - 1)) + (feb(n - 2));
>        }
>    }
> }
> ```

### 6.3.1 使用细节

1. 执行一个方法时，就创建一个新的受保护的独立 栈空间。
2. 方法的局部变量是独立的，不会相互影响。
3. 如果方法中使用的是引用变量，就会共享数据。（因为 [[6.2.3 成员方法传参机制\]](#6.2.3 成员方法传参机制)）
4. 递归必须向退出递归的条件逼近，否则就是无限递归，会提示 `StackOverflowError` “死龟”
5. 当一个方法执行完毕，或遇到 `return` 就会返回。遵守谁调用就返回给谁。同时当方法执行完毕或返回时，该方法也执行完毕。

## 6.4 方法重载

> 方法重载（Overload）：Java 中允许同一类中，多个同名方法的存在，但要求 形参列表 不一致。
>
> 这样，减轻了起名和记名的麻烦。

**使用细节：**

1. 方法名：必须相同
2. 形参列表：必须不同（参数的类型、个数、顺序，这其中至少一个不同）
3. 返回值：无要求

**签名：**

由于重载的存在，要完整的描述一个方法，要指定方法名及参数类型。这叫做方法的签名。

如：

```
public void act() {}
public int act(int n) {
    return n;
}
```

两个方法的签名分别是：`act()` 和 `act(int n)`

## 6.5 可变参数

> Java 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。

语法：`访问修饰符 返回类型 方法名（数据类型... 形参名）{代码块;}`

```
public void m(int... n){
	//此时，n 相当于一个 数组。
	int length = n.length;
	int num1 = n[0];
}
```

### 6.5.1 使用细节

1. 可变参数 的实参可以是 0 个，也可以是 任意多 个。

2. 可变参数 的实参可以是数组

3. 可变参数 本质就是数组

   因此，出现：

   ```
   public void met(int... n){				//这个方法与下面的方法不能构成重载
   }
   ```

   的场合，不能有方法：

   ```
   public void met(int[] n){				//这个方法与上面的方法不能构成重载
   }
   ```

4. 可变参数 和 普通参数 可以一起放在形参列表，但必须保证 可变参数 在最后

   ```
   public void m(double dou, int... n) {}
   ```

5. 一个形参列表最多出现 一个 可变参数。

## 6.6 作用域

1. 在 Java 编程中，主要的变量就是 属性（成员变量）和 局部变量。
2. 我们说的 局部变量 一般是指在成员方法中定义的变量。
3. 作用域的分类
   - 全局变量：也就是 属性，作用域为整个类体
   - 局部变量：除了属性外的其他变量。作用域为定义它的代码块中
4. 全局变量（属性）可以不赋值直接使用，那个场合有默认值。局部变量必须赋值使用

### 6.6.1 使用细节

1. 属性 和 局部变量 可以重名，访问时遵循就近原则

2. 在同一作用域中，两个局部变量不能重名

3. 属性 的生命周期较长。其伴随对象的创建而创建，伴随对象的销毁而销毁。

   局部变量 生命周期较短。其伴随代码块的执行而创建，伴随代码块的结束而销毁。

4. 全局变量/属性 可以被本类使用，也可以被其他类（通过对象）使用。

   局部变量 只能被本类的对应方法中调用

5. 全局变量/属性 **可以加** 修饰符

   局部变量 **不能加** 修饰符

## 6.7 构造方法、构造器

> 构造方法又叫构造器（constructor），是类的一种特殊的方法。它的主要作用是完成对新对象的初始化。

语法：`[修饰符] 方法名(形参列表){方法体}`

1. 构造器的修饰符可以是默认。也可以是别的
2. 参数列表 规则同 成员方法

以下示范一个构造器：

```
class T{
	String name;
	int mun;
    //下面这块就是构造器
	public T(String str, int i){
		name = str;
		num = i;
	}
}
```

### 6.7.1 使用细节

1. 构造器本质也是方法。所以，可以 构造器重载。
2. 构造器名 和 类名 相同
3. 构造器无返回值
4. 构造器是完成对象的初始化，而不是创建
5. 创建对象时，系统自动调用构造器
6. 如果程序员没有定义构造器，系统会自动给类生成一个无参构造器（默认构造器）
7. 一旦定义了自己的构造器，就不能用无参构造器了。除非显式的定义一个无参构造器

### 6.7.2 流程分析

```
Person p1 = new Person("Amy", 10);

...
    
class Person{
	String name;
	int age = 20;
	public Person(String pName, int pAge){
		name = pName;
		age = pAge;
	}
}
```

1. 加载 类信息（方法区）

2. 在 堆 中开辟空间（地址）

3. 完成对象初始化

   - 首先默认初始化。`age = 0; name = null`

   - 之后显式初始化。`age = 20; name = null`

     其中，显式初始化和代码块初始化按编写的先后顺序依次进行。

   - 之后构造器的初始化。`age = 10; name = "Amy"`

4. 把对象在 堆 中的 地址，返回给 `p1`

## 6.8 `this` 关键字

> JVM 会给每个对象分配 this 代表当前对象。
>
> 相当于在 堆 中，this 指向自己（对象）
>
> 在类定义的方法中，Java 会自动用 this 关键字把所有变量和方法引用结合在一起。
>
> 遇到有同名的局部变量的场合，需要程序员加入 this 关键字进行区分。不加入 this 关键字的场合，Java 遵循就近原则。

```
class Example{
    int n = 0;
	public void act(int n) {}
}
```

上面这个类的 `act()` 方法实际有 2 个参数。对其调用：

```
Example e = new Exmaple();
e.act(100);
```

可见，出现在方法名前的参数 `e`，以及出现在方法名后的括号中的参数 `100`

出现在方法名前的参数被称为 **隐式参数**（也称为 方法调用的 目标 或 接收者）

出现在方法名后的参数被称为 **显式参数**，就是所谓的实参

在每一个方法中，用 this 指代隐式参数。

```
public void act(int n) {
    this.n = n;
}
```

此时，再以相同方式调用方法：

```
e.act(100);					// <———— 相当于 e.n = 100;
```

### 6.8.1 使用方法

1. `this` 关键字可以用来访问本类的属性、方法、构造器

2. `this` 用于区分当前类的 属性 和 局部变量

3. 访问本类中成员方法的语法：`this.方法名`

4. 访问构造器的语法：`this(参数列表);`

   注意：只能在构造器中访问另一个构造器。而且，如果有这个语法，必须放置在第一条语句。

5. `this` 不能在类定义的 外部 使用，只能在类定义的 方法中 使用

# 7 面向对象编程（中级）

> IDE：集成开发环境
>
> - IDEA
> - Eeclipse：一个开源的、基于 Java 的可扩展开发平台。是由 IBM 公司开发，在 2001 年 11 月贡献给开源社区的，目前最优秀的 Java 开发 IDE 之一。

## 7.1 IDEA 的使用

> IDEA：全程 IntelliJ IDEA。在业界被公认为最好的 Java 开发工具。是捷克 JetBrains 公司的产品。除了 Java 开发，还支持 HTML，CSS，PHP，MySQL，Python 等。[下载地址](https://www.jetbrains.com/zh-cn/idea/download/#section=windows)

### 7.1.1 常用快捷键

- 删除当前行：`ctrl + Y`
- 复制当前行：`ctrl + D`
- 补全代码：`alt + /`
- 添加 / 取消注释：`ctrl + /`
- 导入该行需要的类：`alt + enter`
- 快速格式化代码：`ctrl + alt + L`
- 快速运行程序：`shift + F10`（我改成了`alt + R`）
- 生成构造器：`alt + insert`
- 查看一个类的层级关系：`ctrl + H`
- 定位一个方法：把光标放在一个方法上，按 `ctrl + B`
- 自动分配变量名：在后面加上 `.var`
- 查看模板快捷键：`ctrl + J`
- 快速环绕代码：`ctrl + alt + T`

### 7.1.2 模板快捷键

- `main`：`public static void main(String[] args) {}`
- `sout`：`System.out.println();`
- `fori`：`for (int i = 0; i < ; i++) {}`
- `xxx.for`：`for(int i = 0; i < xxx; i++) {}`

更多的请在 File - Settings - Editor - Live template 中查看或添加

或者，通过下列快捷键查看

- `ctrl + J`：查看模板快捷键

## 7.2 包

> 包的作用：1. 区分相同名字的类 2. 当类很多时，便于管理 3. 控制访问范围
>
> 语法：`package com.name` 其中 `com` `name` 分别是 一级 和 二级目录，用 `.` 分隔
>
> 包的本质：就是创建不同 文件夹/目录 来保存 类 文件

如何使用包中的对象：

1. 先引入包，之后创建对象

   ```
   import com.name.T;
   ...
   T tools = new T();
   ```

2. 不引入包，而在创建对象时写全路径

   ```
   com.name.T tools = new com.name.T();
   ```

**命名规则：**

- 只能包含 数字 `1 2 3`、字母 `a b A b`、下划线 `_`、小圆点 `.`
- 不能用 数字 开头。每级目录都不能。

**命名规范：**

- 全小写字母 + 小圆点
- `com.公司名.项目名.业务模块名`

**常用的包：**

`java.lang`：基本包，默认引入，不需要再引入

`java.util`：系统提供的工具包。工具类。

`java.net`：网络包，网络开发。

`java.awt`：Java 的界面开发，GUI。

**引入包：**

- 只引入该包下的一个类：`import java.util.Scanner`
- 引入该包的所有内容（不建议）：`import java.util.*`

**使用细节：**

1. `package` 的作用是声明当前类所在的包，要放在 类 的 最上面。一个 类 中最多有一句 `package`

2. `import` 放在 `package` 下面，类定义 前面。可以有多条语句，且没有顺序要求

3. 编译器编译时 **不会** 检查目录结构。

   即使一个包处于错误的目录下（只要其不依赖其他包）也可能通过编译。

   但是，虚拟机会找不到该包，最终程序无法运行。

4. 从 1.2 版本开始，用户不能再把包放在 java. 开头的目录下了。若如此做，这些包会被禁止加载。

### 7.4.1 静态导入

> 有一种 import 语句允许导入静态方法和字段，而不只是类

比如：

```
import static java.lang.Math.*;
```

这个场合，使用 Math 包内的静态方法、字段时，不需要再添加类名前缀。

```
double n = pow(10, 5);					// <———— 本来是 double n = Math.pow(10, 5);
double pi = PI;							// <———— 本来是 double pi = Math.PI;
```

***—— 上述方法、字段见 [[12.5 Math 类\]](./Java语法（下）.md#12.5 Math 类)***

## 7.3 访问修饰符

### 7.3.1 访问权限特点

Java 提供 4 种 访问控制修饰符号，用于控制方法和属性（成员变量）的访问权限（范围）

- 公开级别：`public`，对外公开。

- 受保护级别：`protected`，对 子类 和 同一个包中的类 公开。

  ***——什么是 子类？详见 [[ 7.5 继承 \]](#7.5 继承)***

- 默认级别：没有修饰符号，向 同一个包的类 公开。

- 私有级别：`private`，只有 同类 可以访问，不对外公开。

| (⌐■_■)         | 默认（无修饰符） | private | protected | public |
| -------------- | :--------------: | :-----: | :-------: | :----: |
| 本类           |        可        |   可    |    可     |   可   |
| 同包中的子类   |        可        | 不可以  |    可     |   可   |
| 同包的非子类   |        可        | 不可以  |    可     |   可   |
| 其他包的子类   |      不可以      | 不可以  |    可     |   可   |
| 其他包的非子类 |      不可以      | 不可以  |  不可以   |   可   |

### 7.3.2 使用说明

1. 修饰符可以修饰类中的 属性、成员方法 及 类
2. 只有 默认 和 `public` 才能修饰 类，并遵循上述访问权限特点
3. 成员方法 的访问规则和 属性 相同
4. private 修饰的变量可以被 任意本对象同类的对象访问

## 7.4 封装

> 封装（encapsulation）就是把抽象出的 数据[属性] 和对数据的 操作[方法] 封装在一起。数据 被保护在内部，程序的其他部分只有通过被授权的 操作[方法]，才能对数据进行操作。

封装的好处：

- 隐藏实现细节
- 可以对数据进行验证，保证安全合理

**实现步骤：**

1. 将属性私有化 `private`
2. 提供一个公共的 `set` 方法，用于对属性判断并赋值
3. 提供一个公共的 `get` 方法，用于获取属性的值

**编译多个源文件：**

```
javac MyClass.java
```

该文件中使用了其他类时，Java 编译器会查找对应名称的 .class 文件。没有找到的场合，转而寻找 .java 文件，并对其编译。倘若 .java 文件相较原有 .class 文件更新，编译器也会自动重新编译该文件。

### 7.4.1 静态导入

> 有一种 import 语句允许导入静态方法和字段，而不只是类

比如：

```
import static java.lang.Math.*;
```

这个场合，使用 Math 包内的静态方法、字段时，不需要再添加类名前缀。

```
double n = pow(10, 5);					// <———— 本来是 double n = Math.pow(10, 5);
double pi = PI;							// <———— 本来是 double pi = Math.PI;
```

***—— 上述方法、字段见 [12.5 Math 类]***

### 7.4.2 JAR 文件

> 为了避免向用户提供包含大量类文件的复杂目录结构，可以将 Java 程序打包成 JAR （Java 归档）文件。
>
> 一个 JAR 文件既可以包含类文件，也可以包含诸如图像和声音等其他类型的文件。
>
> JAR 文件是压缩的。其使用了 ZIP压缩格式。

**创建 JAR：**

使用 jar 工具以制作 JAR 文件。该工具在 jdk/bin 目录下

```
jar cvf 包名 文件名1 文件名2 ...
```

关于 jar 工具的各种指令，还是自己去百度一下吧

## 7.5 继承

> 继承：能解决代码复用，让我们的编程更接近人类思维。当多个类存在相同的 属性（变量）和 方法 时，可以从这些类中抽象出 父类（基类/超类）。在 父类 中定义这些属性·方法，所有的子类不需要重新定义这些属性和方法，只需要通过 `extends` 来声明继承父类即可。
>
> 通过继承的方法，代码的复用性提高了，代码的维护性和拓展性也提高了。

```
public class Son extends Father {};				// Son 类继承了 Father 类
```

定义类时可以指明其父类，也能不指明。不指明的场合，默认继承 Object 类。

所有类有且只有一个父类。Object 是所有类的直接或间接父类。只有 Object 本身没有父类。

### 7.5.1 使用细节

1. 子类 继承了所有属性和方法，但私有（`private`）的 属性·方法 不能在 子类 直接访问。要调用父类提供的 公共（`public`）等方法 访问。
2. 子类 必须调用 父类 的 构造器，完成 父类 的 初始化。
3. 当创建 子类对象 时，不管使用 子类的哪个构造器，默认情况下总会调用 父类的无参构造器。如果 父类 没有提供 无参构造器，则必须在 子类的构造器 中用 `super` 去指定使用 父类的哪个构造器 完成 对父类的初始化。否则编译不能通过。
4. 如果希望指定调用 父类的某构造器，则显式地调用一下：`super(形参列表);`
5. `super` 在使用时，必须放在构造器第一行。`super` 只能在构造器中使用。
6. 由于 `super` 与 `this` 都要求放在第一行，所以此两个方法不能同时存在于同一构造器。
7. Java 所有的类都是 `Object` 的子类。换言之，`Object` 是所有类的父类。
8. 父类构造器的调用不限于直接父类，将持续向上直至追溯到顶级父类 `Object`
9. 子类 最多只能直接继承 一个 父类。即，Java 中是 单继承机制。
10. 不能滥用继承。子类 和 父类 之间必须满足 is - a 的逻辑关系。

### 7.5.2 继承的本质

- 内存布局：
  1. 在 方法区，自顶级父类起，依次加载 类信息。
  2. 在 堆 中开辟一个空间，自顶级父类起，依次创建并初始化各个类包含的所有属性信息。
  3. 在 栈 中存放该空间的 地址。
- 如何查找信息？
  1. 查看该子类是否有该属性。如果该子类有这个属性且可以访问，则返回信息。
  2. 子类没有该属性的场合，查看父类是否有该属性。如有且可访问，则返回信息。如不可访问，则报错。
  3. 父类也没有该属性的场合，继续查找上级父类，直到顶级父类（Object）。
  4. 如需调用某个特定类包含的特定信息，可以调用该类提供的方法。

### 7.5.3 `super` 关键字

> `super` 代表父类的引用。用于访问父类的 属性、方法、构造器。

**super 的使用：**

- `super.属性名`：访问父类的属性。不能访问父类的私有（private）属性。
- `super.方法名(形参列表)`：访问父类的方法。不能访问父类的私有（private）方法。
- `super(参数列表);`：访问父类的构造器。此时，super 语句必须放在第一句。

**使用细节：**

1. 调用父类构造器，好处是分工明确。父类属性由父类初始化，子类由子类初始化。
2. 子类中由和父类中成员（属性和方法）重名时，要调用父类成员必须用 `super`。没有重名的场合，`super`、`this` 及直接调用的效果相同。
3. `super` 的访问不限于直接父类。如果爷爷类和本类中都有同名成员也能使用。如果多个基类中都有同名成员，则遵循就近原则。

### 7.5.4 方法重写 / 覆盖

> 方法重写/覆盖（Override）：如若子类有一个方法，和父类的某方法的 名称、返回类型、参数 一样，那么我们就说该子类方法 覆盖 了那个父类方法。

**使用细节：**

1. 子类方法的参数，方法名称，要和父类方法完全一致。
2. 子类方法的返回类型需和父类方法 一致，或者是父类返回类型的子类。
3. 子类方法 **不能缩小** 父类方法的访问范围（访问修饰符）。

## 7.6 多态

> 多态：方法 或 对象 有多种形态。多态 是面向对象的第三大特征，是建立在 封装 和 继承 的基础之上的

### 7.6.1 多态的体现

1. 方法的多态：重写 和 重载 体现了 方法的多态。

2. **对象的多态：**

   - 一个对象的 编译类型 和 运行类型 可以不一致。

     `Animal animal = new Dog();`

     上例，编译类型是 `Animal`，运行类型是子类 `Dog`。要理解这句话，请回想 [[6.1.4 类与对象的内存访问机制\]](#6.1.4 类与对象的内存访问机制)：`animal` 是对象的**引用**。

   - 编译类型在定义对象时就确定了，不能改变。

   - 运行类型是可以变化的。

     上例中，再让 `animal = new Cat();`，这样，运行类型变为了 `Cat`

   - 编译类型看定义时 `=` 的左边，运行类型看 `=` 的右边。

### 7.6.2 使用细节

1. 多态的前提：两个对象 / 类存在继承关系。

2. 多态的向上转型：

   - 本质：父类的引用指向了子类的对象。（如 [ 7.6.1.2 ]）
   - 语法：`父类类型 引用名 = new 子类类型(参数列表);`
   - 编译类型看左边，运行类型看右边。
   - 可以调用父类中的所有成员，但不能调用子类特有的成员，而且需要遵守访问权限。因为在编译阶段，能调用哪些成员是由编译类型决定的。
   - 最终的运行结果要看子类的具体实现。即从子类起向上查找方法调用（与 [ 7.5.2 ] 规则相同）。

3. 多态的向下转型：

   - 语法：`子类类型 引用名 = (子类类型)父类引用;`

     [7.6.2.2] 的例子里，向下转型。这个语法其实和 [2.8.2 强制类型转换] 很像。

     `Dog dog = (Dog)animal;`

   - 只能强转父类的引用，不能强转父类的对象。

   - 要求父类的引用必须指向的是当前目标类型的对象。即上例中的 `animal` 运行类型需是 `Dog`

   - 向下转型后，可以调用子类类型中的所有成员。

4. 属性没有重写一说。**和 方法 不同，属性的值 看编译类型。**

5. `instanceof` 比较操作符。用于判断对象类型是否是某类型或其子类型。此时判断的是 **运行类型**。

### 7.6.3 理解方法调用

在对象上调用方法的过程如下：

1. 编译器查看对象的声明类型和方法名。该类和其父类中，所有同名方法（包括参数不同的方法）都被列举。

   至此，编译器已经知道所有可能被调用的方法。

2. 编译器确认方法调用中提供的参数类型。

   那些列举方法中存在参数类型完全匹配的方法时，即调用该方法。

   没有发现匹配方法，抑或是发现经过类型转换产生了多个匹配方法时，就会报错

   至此，编译器已经知道要调用方法的名字和参数类型

3. 如若是 private 方法、static 方法、final 方法、构造器，那么编译器将能准确知道要调用哪个方法。这称为 **静态绑定**

   与之相对的，如果调用方法依赖于隐式参数类型，那么必须在运行时 **动态绑定**

4. 程序运行并采取动态绑定方法时，JVM 将调用那个 **实际类型** 对应的方法。

倘若每次调用方法都进行以上搜索，会造成庞大的时间开销。为此，JVM 预先为每个类计算了 **方法表**。

方法表中列举了所有方法的签名与实际调用的方法。如此，每次调用方法时，只需查找该表即可。

特别地，使用 super 关键字时，JVM 会查找其父类的方法表。

**动态绑定机制：**

- 当调用对象方法的时候，该方法和该对象（隐式参数）的内存地址/运行类型绑定。
- 当调用对象属性时，没有动态绑定机制。于是哪里声明，哪里调用。

## 7.7 Object 类

Object 类是所有类的超类。Java 中所有类默认继承该类。

### equals 方法

```
boolean equals(Object obj)
```

用于检测一个对象是否等于另一对象。

在 Object 中，该方法的实现是比较 形参 与 隐式参数 的对象引用是否一致。

**与 `==` 的区别：**

- `==`：既可以判断基本类型，也可以判断引用类型。如果判断基本类型，判断的是值是否相等。如果判断引用类型，判断的是地址是否相等。

- equals 方法：是 Object 中的方法，只能判断引用类型。默认判断地址是否相等，但子类中往往重写该代码，以判断内容是否相等。

  在子类中定义 equals 方法时，首先调用超类的 equals 方法。那个一致时，再比较子类中的字段。

**Java 语言规范要求 equals 方法具有如下特性：**

- *自反性*：对于任何非空引用 x，`x.equals(x)` 应返回 true

- *对称性*：对于任何引用 x 和 y，当且仅当 `x.equals(y)` 为 true 时，`y.equals(x)` 为 true

  如果所有的子类具有相同的相等性语义，可以使用 `instanceof` 检测其类型。否则，最好使用 `getClass` 方法比较类型。

- *传递性*：对于任何引用 x、y、z，如果 `x.equals(y)` 为 true ，`y.equals(z)` 为 true，那么 `x.equals(z)` 也应该为 true

- *一致性*：如果 x 和 y 的引用没有发生变化，反复调用 `x.equals(y)` 应该返回相同的结果

- 对于任何非空引用 x，`x.equals(null)` 应该返回 false

### hashCode 方法

```
int hashCode()
```

返回对象的 散列码值。

散列码值是由对象导出的一个整型值。散列码是无规律的。如果 x 与 y 是不同对象，两者的散列码基本上不会相同。

字符串的散列码是由其内容导出的，而其他引用对象的散列码是根据存储地址得出的。

**散列码的作用：**

1. 提高哈希结构的容器的效率。
2. 两个引用，若是指向同一对象，则哈希值一般不同。
3. 哈希值是根据地址生成的，因而，哈希值不能等同于地址

**相关方法：**

- `Objects.hashCode(Object obj)`

  这是一个 null 安全的返回散列值的方法。传入 null 时会返回 0

- `Objects.hash(Object... values)`

  组合所有传入参数的散列值

- `Integer.hashCode(int value)`

  返回给定基本数据类型的散列值。所有包装类都有该静态方法

- `Arrays.hashCode(xxx[] a)`

  计算数组的散列码。数组类型可以是 Object 或基本数据类型

空对象调用 hashCode 方法会抛出异常。

hashCode 与 equals 的定义必须相符。如果 `x.equals(y)` 返回 true，那么 `x.hashCode()` 与 `y.hashCode()` 应该返回相同的值。

### toString 方法

```
String toString()
```

返回表示对象的一个字符串。Object 的默认实现如下

```
public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}JAVA
```

- `Class getClass()`

  返回包含对象信息的 Class 对象。

- `String getName()`

  由 Class 类实例调用。返回这个类的全类名

  全类名：即包名 + 类名。比如 `com.prictice.codes.Person`

- `Class getSuperClass()`

  由 Class 类实例调用。以 Class 形式返回其父类

  Object 使用时返回 null

- `Integer.toHexString(int val)`

  返回一个数字的十六进制表示的字符串

toString 方法非常实用。Java 标准类库中的很多类重写了该方法，以便用户能获得一些有关对象状态的信息。

打印对象 或 使用 **+** 操作符拼接对象 时，都会自动调用该对象的 toString 方法。

当直接调用对象时，也会默认调用该方法。

### finalize 方法

1. 当对象被回收时，系统会自动调用该对象的 `finalize` 方法。子类可以重写该方法，做一些释放资源的操作。
2. 何时被回收：当某对象没有任何引用时，JVM 就认为该对象是一个垃圾对象，就会（在算法决定的某个时刻）使用垃圾回收机制来销毁该对象。在销毁该对象前，会调用 `finalize` 方法。
3. 垃圾回收机制的调用，是由系统决定。也可以通过 `System.gc();` 主动触发垃圾回收机制。这个方法一经调用就会继续执行余下代码，而不会等待回收完毕。
4. 实际开发中，几乎不会运用该方法。

# 8 面向对象编程（高级）

## 8.1 类变量和类方法

### 8.1.1 类变量

> 类变量：也叫 静态变量/静态属性。是该类所有对象共享的变量。任何一个该类对象访问时都是相同的值，任何一个该类对象修改时也是同一个变量。
>
> 语法（推荐）：`访问修饰符 static 数据类型 变量名;`
>
> 或者也可以：`static 访问修饰符 数据类型 变量名;`
>
> 根据 JDK 版本的不同，类变量存放在 堆 中或 方法区 中。

1. 什么时候需要用类变量：

   当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量（静态变量）

2. 类变量 与 实例变量（普通属性）的区别：

   类变量 是该类所有对象共享的，而 实例变量 是每个对象独享的

3. 加上 `static` 称为 类变量 或 静态变量。否则称为 实例变量/普通变量/非静态变量

4. 静态变量 可以通过 `类名.类变量名;` 或 `对象名.类变量名;` 来访问。但 Java 设计者推荐我们用 `类名.类变量名;` 来访问。（需满足访问权限和范围）

5. 类变量 是在加载类时就初始化了。所以，没有创建对象实例也能访问。

6. 类变量 的生命周期是随着 类的加载 开始，随着 类的消亡 而销毁。

7. 特别地：**一个 null 对象也可以访问静态变量 / 静态方法**

   ```
   public class Test{
       static int n = 0;
       static void met() {
           System.out.println(++n);
       }
       
       public static void main(String[] args){
           Test t = null;
           System.out.println(t.n);			//这样不会报错
           t.met();							//这样也不会报错
       }
   }
   ```

### 8.1.2 类方法

> 当方法使用 `static` 修饰后，就是 静态方法。静态方法就能访问静态属性。如果我们不希望创建实例，也能调用方法，这个场合把方法做成静态方法是合适的。开发工具类时就可以如此做。

1. 类方法和普通方法都是随着类的加载而加载，将结构信息存储在 方法区。
2. 类方法中不允许使用和对象有关的关键字。所以，类方法没有 `this` 或 `super`
3. 类方法可以通过类名调用，也能通过对象名调用。普通方法不能通过类名调用。
4. 类方法 中只能访问 类变量 或 类方法
5. 普通方法既可以访问普通方法也可以访问类方法

## 8.2 理解 `main` 方法语法

> ```
> public static void main(String[] args){...}
> ```

1. `main` 方法 是 JVM 调用的方法。所以该方法的 访问权限 必须为 `public`

2. JVM 在执行 `main` 方法时不必创建对象，所以 `main`方法 必须为 `static`

3. 该方法接收 `String` 类型的数组参数。该数组中保存执行 Java 命令 时传递给所运行的类的参数。

   > 工作台中：`javac 执行的程序.java`
   >
   >  `java 执行的程序 参数1(arg[0]) 参数2(arg[1]) 参数3(arg[2]) ..`
   >
   > [IDEA中怎么做？](https://www.bilibili.com/video/BV1fh411y7R8?p=385&t=129.5)

4. 在 `main` 方法 中，我们可以直接调用 `main` 方法 所在类的静态方法或静态属性。

   但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例后才能通过该实例访问非静态成员。

## 8.3 代码块

> 代码块：又称为 初始化块。属于类中的成员。类似于方法，将逻辑语句封装在方法体中，通过 `{ }` 包围起来。
>
> 和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类 显式调用，而是加载类时，或创建对象时 隐式调用。
>
> 语法：`[修饰符]{代码};`

1. 修饰符 是可选项，可不写。要写的话，只能写 `static`
2. 代码块分为两类：
   - 静态代码块：有 `static`
   - 普通代码块：无 `static`
3. 逻辑语句可以为任意的逻辑语句。
4. `;` 可以写，也可以省略。建议写上。
5. 代码块相当于另一种形式的构造器（构造器的补充机制），可以做初始化操作
6. 如果多个构造器中都有重复语句，就可以抽取到初始化块中，提高代码复用率。这样，不管用哪个构造器，都会执行代码块。

### 8.3.1 使用细节

1. `static` 代码块：作用是对类进行初始化。**随着 类的加载 会且只会执行一次**。相对的：普通代码块每创建一个对象就执行一次。

- **类什么时候被加载？ **

  - 创建对象实例时（new）
  - 创建子类对象实例，父类也会加载
  - 使用类的静态成员时（父类也会加载）

  以上情况下类会被加载。加载后不需要再次加载，所以，静态代码块也只会执行一次。

1. 创建一个对象时，在 **一个类里** 调用顺序是：

   - 调用静态代码块 和 静态属性初始化。这两者优先级相同，多个存在时按照定义的顺序依次执行。
   - 调用普通代码块 和 普通属性初始化。这两者优先级也相同。
   - 调用构造器。

2. `构造器` 的最前面其实隐含了 `super();` 和 `调用普通代码块`。而静态相关的代码块，属性初始化，在类加载时就执行完毕了。

   这样，创建一个对象时，在 **有继承关系的多个类里** 调用顺序是：

   - 父类 静态代码块 和 静态初始化
   - 子类 静态代码块 和 静态初始化
   - 父类 普通代码块 和 普通初始化
   - 父类 构造器
   - 子类 普通代码块 和 普通初始化
   - 子类 构造器

3. 静态代码块 只能调用 静态成员。普通代码块 能调用 任意成员。

## 8.4 单例设计模式

> 什么是设计模式：设计模式是在大量的实践中总结和理论化后优选的代码结构、编程风格、解决问题的思考方式。设计模式就像是经典的棋谱，免去我们自己再思考和摸索。

单例设计模式：采取一定的方法，保证再整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法

### 8.4.1 应用实例

> 后面会学更多，这里先展示两种：饿汉式、懒汉式

#### #8.4.1.1 饿汉式

步骤如下：

1. 构造器私有化（防止用户直接 new）

2. 类的内部创建对象

3. 向外暴露一个静态的公共方法

4. 代码实现

   > ```
   > class GF{
   >        private String name;
   >     private static GF gf = new GF("萝茵");
   >        private GF(String name){
   >            this.name = name;
   >        }
   >        public static GF getGF(){
   >            return gf;
   >        } 
   > }
   > ```
   >
   > 对象，通常都是重量级的对象
   >
   > 有时，我们用不到这个创建的对象，那个场合，会造成资源浪费。

#### #8.4.1.2 懒汉式

步骤如下：

1. 构造器私有化

2. 定义一个静态属性对象

3. 提供一个静态的公共方法，可以返回对象。如果静态对象为空，则创建对象

4. 代码实现

   > ```
   > class GF{
   >     private String name;
   >     private static GF gf;
   >     private GF(String name){
   >     	this.name = name;
   >     }
   >     public static GF getGF(){
   >         if(gf == null){
   >             gf = new GF("萝茵");
   >         }
   >         return gf;
   >     } 
   > }
   > ```

#### #8.4.1.3 两种方法对比

1. 二者创建对象的时机不同。饿汉式在加载类信息时创建，懒汉式在使用时才创建
2. 饿汉式可能造成资源浪费，懒汉式可能存在线程安全问题（学习[线程]后会进行完善）。
3. Java SE 标准类中 java.lang.Runtime 就是一个单例模式。

## 8.5 `final` 关键字

> `final` 可以修饰 类、属性、方法、局部变量
>
> 以下情况下，可能用到 `final`
>
> 1. `final` 修饰类：该类不能被继承
> 2. `final` 修饰方法：该方法不能被重写
> 3. `final` 修饰值：该值不能被修改

### 8.5.1 使用细节

1. `final` 修饰的属性又叫常量，一般用 XX_XX_XX 来命名（全大写字母+下划线）

2. `final` 修饰的属性在定义时，必须赋初始值，且之后不能再修改。赋值可以在下列位置之一：

   - 定义时
   - 构造器中
   - 代码块中

   注意：如果 `final` 修饰的属性是静态的，则只能在以下位置赋值。

   - 定义时
   - 静态代码块中

3. `final` 类不能继承，但能实例化对象。对的，是可以的。

4. 如果不是 `final` 类，但含有 `final` 方法，虽然该方法不能重写，但能被继承。

5. `final` 类可以有 `final` 方法。可以，但没必要。

6. `final` 不能修饰构造方法。

7. `final` 和 `static` 搭配使用，效率更高（那个场合，虽然顺序不限，还是推荐 `static` 在前）。底层编译器做了优化处理。这样做，调用 **属性（定义时赋值）** 时居然 **不会造成类的加载！**

8. 包装类（Integer、Double、Float、Boolean、String等）都是 `final` 类，都不能被继承。

## 8.6 抽象类

> 当父类的某些方法需要声明，却不知道如何实现时，可以将其声明为抽象方法。那个场合，要将该类声明为 `abstract` 类。
>
> 抽象类的价值更多是用于设计。设计者设计好后，让子类继承并实现。也是考官爱问的考点。

> 定义抽象类：`访问修饰符 abstract 类名{...}`
>
> 定义抽象方法（注意：无方法体）：`访问修饰符 abstract 返回值 方法名(形参列表);`

### 8.6.1 使用细节

1. 抽象类不能被实例化
2. 抽象类不一定包含抽象方法。也就是说，抽象类可以没有 `abstract`方法
3. 一旦包含 `abstract` 方法，则该类一定要声明为 `abstract`
4. `abstract` 只能修饰 类 和 方法，不能修饰其他。
5. 抽象类可以有任意成员（非抽象方法、构造器、静态属性等）。即，抽象类本质还是类。
6. 抽象方法不能有主体。即，抽象方法不能实现。
7. 如果一个类继承了 `abstract` 类，则其必须实现所有 `abstract` 方法，除非其自己也是 `abstract` 类。
8. 抽象方法不能用 `private` `final` `static` 来修饰。因为，这些关键词都和 重写 相违背。

### 8.6.2 模板设计模式

## 8.7 接口

> 接口就是给出一些没有实现的方法，封装到一起，到某个类要用的时候，再根据具体情况把这些方法写出来。
>
> 语法：`interface 接口名{...}`
>
> ```
> class 类名 implements 接口名{...必须实现接口的抽象方法...}
> ```
>
> 注意：JDK 7.0 以前，接口中只能是抽象方法。而 JDK 8.0 后，接口可以有静态（`static`）方法、默认（`default`）方法。
>
> 在接口中，抽象方法可以省略 `abstract`

接口中可以存在：

- 属性（只有静态 `static` 属性，可以不加 `static` 关键字）
- 方法（抽象 `abstract` 方法、默认 `default` 实现方法、静态 `static` 方法）

### 8.7.1 使用细节

1. 接口 不能被实例化。
2. 接口中所有方法都是 `public` 方法。接口中的 抽象方法 可以不用 `abstract` 修饰。
3. 一个普通类实现接口，就必须把该接口所有方法都实现。（用快捷键吧 `alt + enter`）
4. 抽象类实现接口，可以不用实现接口的方法。
5. 一个类可以同时实现多个接口。`class Name implements In1,In2{...}`
6. 接口中的属性只能是 `final` 的，并且是 `public static final` 修饰符。修饰符就算不写，还是这样。
7. 接口中属性的访问形式：`接口名.属性名`
8. 接口不能 **继承** 其他的类，但可以 **继承** 多个别的接口。（不是也不能 实现 别的接口）
9. 接口的修饰符只能是 `public` 和 默认。这点和类的修饰符相同。

### 8.7.2 实现接口 vs 继承类

1. 当子类继承父类，就自动拥有父类的所有功能。如果需要扩展功能，可以通过接口方式扩展。
2. 可以认为，接口 是对于 Java 单继承机制的补充。
3. 继承的价值主要在于：解决代码的复用性和可维护性。
4. 接口的价值主要在于：设计。设计好各种规范，让其他类去实现这些方法。
5. 接口比继承更加灵活。继承需要满足 is - a 的关系，而接口只需要满足 like - a 关系。
6. 接口在一定程度上实现代码解耦。（即：接口规范性 + 动态绑定机制）

### 8.7.3 接口的多态特性

1. 多态参数（接口的引用可以指向实现了接口的类的对象）

   > `viod work(Inerface01 i1){...}` 参数可以传入任意实现该接口的类

2. 多态数组

3. 接口存在多态传递现象

## 8.8 内部类

> 一个类的内部又完整的嵌套了另一个类结构。被嵌套的类被称为 内部类。
>
> ```
> class Outer{		//外部类
> 	class Inner{	//内部类	
> 	}
> }
> class Other{		//外部其他类
> }
> ```
>
> 内部类的最大特点是可以直接访问私有属性，并且可以体现类与类之间的包含关系。

### 8.8.1 四种内部类

分别是：

- 定义在外部类的局部位置上
  - 局部内部类：有 类名
  - **匿名内部类：无 类名**
- 定义在外部类的成员位置上
  - 成员内部类：无 `static` 修饰
  - 静态内部类： `static` 修饰的类

### 8.8.2 局部内部类

> 局部内部类：定义在外部类的局部位置上，并且有类名。（局部位置？比如：方法/代码块里）
>
> ```
> class Outer {				//外部类
>     public void tools01() {
>         class Inner {		//局部内部类
>         }
>     }
> }
> ```

#### #8.8.2.1 使用细节

1. 定义在外部类的局部位置上，并且有类名。

2. 可以访问外部类的所有成员，包含私有成员

3. 局部内部类可以 直接访问 外部类的成员。

4. 不能添加 访问修饰符，因为其地位相当于局部变量。但，可以使用 `final`，因为局部变量也能用 `final`

5. 作用域 仅仅在定义它的方法或代码块中

6. 外部类 在方法中，可以创建 局部内部类 的对象实例，然后调用方法。

7. 外部其他类 不能访问 局部内部类

8. 如果外部类和局部内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用 `外部类名.this.变量名`

   `外部类名.this` 本质就是 外部类的对象。即，调用了该方法（上例的 `tools01` ）的对象

   还不懂的话，看一下 [这个视频](https://www.bilibili.com/video/BV1fh411y7R8?p=415&t=289.9) 悟一悟

### 8.8.3 匿名内部类

> 匿名内部类：定义在外部类的局部位置，且没有类名
>
> ```
> new 类/接口 (参数列表) {
>    类体
> }
> ```
>
> 匿名内部类本质是没有名字的类，而且是内部类。同时，还是一个对象。
>
> 可以用匿名内部类简化开发

> 一个例子
>
> ```
> class Outer {							//外部类
>    public void tools01() {
>        Inter whatEver = new Inter(){	//匿名内部类            
>        };						
>    }
> }
> interface Inter{
> }
> ```
>
> 其实，这个匿名内部类 `new Inter(){}` 的运行类型就是 `class XXXX implements Inter`。系统自动分配的名字是 `Outer$1`（`whatEver.getClass = "Outer$1"`）
>
> JDK 在创建匿名内部类 `Outer$1` 时，立即创建了一个对象实例，并将地址返回给了 `whatEver`
>
> 匿名内部类使用一次后就不能再次使用（`Outer$1` 就这一个了）

#### #8.8.3.1 使用细节

1. 匿名内部类语法比较独特。其既是一个类的定义，也是一个对象。因此，从语法上看，其既有 定义类的特征，也有 创建对象的特征。
2. 可以访问外部类的所有成员，包括私有的。
3. 局部内部类可以 直接访问 外部类的成员。
4. 不能添加 访问修饰符，因为其地位相当于局部变量。但，可以使用 `final`，因为局部变量也能用 `final`
5. 作用域：仅仅在定义它的方法或方法快中
6. 外部其他类 不能访问 匿名内部类
7. 如果外部类和匿名内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用 `外部类名.this.变量名`

#### #8.8.3.2 使用场景

1. 当作实参直接传递，简洁高效

   > ```
   > public class Homework1 {
   >     public static void main(String[] args) {		
   >         new Cellphone().clock(new Bell() {				//看这里看这里
   >             @Override
   >             public void belling() {
   >                 System.out.println("小懒猪起床了！");
   >             }
   >         });
   >     }
   > }
   > 
   > interface Bell {
   >     void ringing();
   > }
   > 
   > class Cellphone{
   >     public void clock(Bell bell){
   >         bell.ringing();
   >     }
   > }
   > ```

### 8.8.4 成员内部类

> 成员内部类：定义在外部类的成员位置，并且没有 `static` 修饰。
>
> ```
> class Outer{
> 	class Inner{
> 	}
> }
> ```

#### #8.8.4.1 使用细节

1. 可以直接访问外部类的所有成员，包括私有的
2. 可以添加任意访问修饰符。因为，成员内部类的地位就是一个成员。
3. 作用域 和外部类其他成员相同，为整个类体。
4. 局部内部类可以 直接访问 外部类的成员。
5. 外部类可以通过创建对象的方式访问成员内部类
6. 外部其他类访问成员内部类
   - `Outer.Inner name = Outer.new Inner(); `下个方法的缩写
   - `Outer.Inner name = new Outer().new Inner();`
   - 在外部类中编写一个方法，返回一个 `Inner` 的对象实例（就是对象的 getter）
7. 如果外部类和匿名内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用 `外部类名.this.变量名`

### 8.8.5 静态内部类

> 静态内部类：定义在外部类的成员位置，经由 `static` 修饰。
>
> ```
> class Outer{
> 	static class Inner{
> 	}
> }
> ```

#### #8.8.5.1 使用细节

1. 可以直接访问外部类的所有 **静态** 成员，包括私有的。但不能访问非静态成员
2. 可以添加访问修饰符。因为，静态内部类的地位就是一个成员。
3. 作用域 和其他成员相同，为整个类体。
4. 静态内部类可以 直接访问 外部类的成员。
5. 外部类可以通过创建对象的方式访问静态内部类
6. 外部其他类访问静态内部类
   - `Outer.Inner name = new Outer.Inner();` 即通过类名直接访问
   - 在外部类中编写一个方法，返回一个 `Inner` 的对象实例
   - 如果外部类和匿名内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用 `外部类名.变量名`。*（怎么不一样了呢？因为静态内部类访问的都是静态成员）*

# 9 Java 中的数据结构

## 9.1. 什么是数据结构?

> 数据结构分为两种：线性结构、非线性结构

**线性结构：**

- 最常用的数据结构。数据元素间存在一对一线性关系。

- 线性结构有 2 种不同的存储结构：顺序储存结构，链式储存结构

  顺序存储结构中元素存储在连续的内存空间中。

  链式储存结构中元素储存在非连续的空间中，元素节点中存放数据元素及相邻元素的地址信息

- 常见的线性结构有：数组、队列、链表、栈等

**非线性结构：**

- 非线性结构包括：二维数组、多维数组、广义表、树结构、图结构


### 9.1.1 数组

**定义**

在计算机科学中，数组是由一组元素（值或变量）组成的数据结构，每个元素有至少一个索引或键来标识

>In computer science, an **array** is a data structure consisting of a collection of *elements* (values or variables), each identified by at least one *array index* or *key*

因为数组内的元素是**连续存储**的，所以数组中元素的地址，可以通过其索引计算出来

**随机访问性能**

即根据索引查找元素，时间复杂度是 $O(1)$

### 9.1.2 链表

**定义**

在计算机科学中，链表是数据元素的线性集合，其每个元素都指向下一个元素，元素存储上并不连续

> In computer science, a **linked list** is a linear collection of data elements whose order is not given by their physical placement in memory. Instead, each element points to the next. 

可以分类为

* 单向链表，每个元素只知道其下一个元素是谁

![image-20221110083407176](D:/College_life/Journal/images/image-20221110083407176.png)

* 双向链表，每个元素知道其上一个元素和下一个元素

![image-20221110083427372](D:/College_life/Journal/images/image-20221110083427372.png)

* 循环链表，通常的链表尾节点 tail 指向的都是 null，而循环链表的 tail 指向的是头节点 head

![image-20221110083538273](D:/College_life/Journal/images/image-20221110083538273.png)

链表内还有一种特殊的节点称为哨兵（Sentinel）节点，也叫做哑元（ Dummy）节点，它不存储数据，通常用作头尾，用来简化边界判断，如下图所示

![image-20221110084611550](D:/College_life/Journal/images/image-20221110084611550.png)


**随机访问性能**

根据 index 查找，时间复杂度 $O(n)$

**插入或删除性能**

* 起始位置：$O(1)$

* 结束位置：如果已知 tail 尾节点是 $O(1)$，不知道 tail 尾节点是 $O(n)$

* 中间位置：根据 index 查找时间 + $O(1)$

## 9.2 集合

> Java 提供了一系列集合容器，以方便程序员动态保存元素。并提供了一系列方便的操作对象的方法。
>
> Java 集合主要分为两组：单列集合（Collection）、双列集合（Map）

![](D:/College_life/Journal/images./集合体系图.jpg)

- **Collection 接口**（单列集合）：可以存放多个元素。每个元素可以是 Object

  Collection 接口有两个重要子接口：List（有序集合）和 Set（无序集合）

- **Map 接口**（双列集合）：用于保存具有映射关系的数据：key - value（双列元素）

  key 和 value 可以是任何类型的引用数据类型。其中 key 不能重复，value 可以重复

  key 和 value 存在单一对应关系。通过特定的 key 一定能找到指定的 value

### 9.2.1 单列集合接口 Collection

```
public interface Collection<E> extends Lterable<E>
```

> Collection 实现子类可以存放多个元素。每个元素可以是 Object
>
> 有些 Collection 实现子类能存放重复的元素，有些不能
>
> 有些 Collection 实现子类是有序的（List） ，有些不是（Set）
>
> Collection 接口没有直接的实现子类，都是通过其子接口实现的

**常用方法：**

- `add`：添加单个元素

  ```
  ArrayList list = new ArrayList();
  list.add("哈哈啊");
  list.add(10);				// 相当于List.add(new Integer(10));
  list.add(true);				// 同上
  ```

- `remove`：删除单个元素

  ```
  list.remove(0)				// 删除编号 0 的元素。上例中会删除 "哈哈啊"
  list.remove((Integer)10);	// 删除上例的 10 要这样写
  ```

- `contains`：检查元素是否存在

- `size`：获取元素个数

- `isEmpty`：判断是否为空

- `clear`：清空

- `addAll`：添加多个元素

  ```
  ArrayList list2 = new ArrayList();
  list2.add(111);
  list2.add("idea");
  list.addAll(list2);			// 这里可以输入所有实现了 Collection 接口的集合
  ```

- `containsAll`：检查多个元素是否存在

  ```
  list.contaionsAll(list2);	// 同上，放一个实现了 Collection 接口的集合
  ```

- `removeAll`：删除多个元素

  ```
  list.removeAll(list2);		// 同上
  ```

- `Iterator iterator()`：返回指向集合开始位置的迭代器

#### 迭代器 Iterator

> Iterator 对象称为迭代器，主要用于遍历 Collection 集合中的元素。
>
> Collection 继承的 Iterable 接口中，提供了 `iterator()` 方法，会返回一个新的迭代器。
>
> Iterator 对象仅用于遍历集合，本身不存放元素
>
> IDEA 中，迭代器 while 循环的模板快捷键：`itit`

**常用方法：**

- `boolean hasNext()`：该方法判断是否有下一个元素。
- `T next()`：该方法会将指针下移，然后返回下移后的位置上的元素

**用迭代器遍历元素：**

```
Collection<Object> c = new LinkedList<>();
Iterator<Object> iterator = c.iterator();		// [1]
while (iterator.hasNext()){						// [2]
	Object obj = iterator.next();				// [3]
	System.out.println(obj);
}
```

1. 获取迭代器

2. 判断有无下一元素

3. 将迭代器后移，并返回那个后移位置上的元素

   while 循环结束后，指针指向最后元素的位置。再次 `next()` 会报错。如果需要再使用，需要重置迭代器。

   ```
   iterator = list.iterator();				// 重置了迭代器
   ```

#### for each（增强 for 循环）：

> for each 的语法与 for 循环相似，但是可以遍历 Collection 和 数组 中的元素
>
> IDEA 中，增强 for 循环的模板快捷键：`I`

```
for (Object o : list){
	...
}
```

- for each 可在 Collection 集合中使用。
- for each 的底层在本质上也是 `Iterator`。可以理解为简化版本的迭代器遍历。

### 9.2.2 有序集合接口 List

```
public interface List<E> extends Collection<E>
```

> List 是 Collection 接口的子类接口
>
> List 是有序（添加顺序和取出顺序一致）的，可重复的
>
> List 中的每个元素都有其对应的顺序索引（从 0 开始编号）

**常用方法：**

- `add(int, obj)`：在 int 位置插入 obj 元素。返回 true

  `add(obj)`：在末尾插入 obj。返回 true

  ```
  list.add(111);
  list.add(0, 110);						// 在第 1 个位置插入数字 110
  ```

  `addElement(obj)`：在末尾插入 obj。无返回值。你说要这方法有啥用？名字还长一截

- `addAll(int, collection)`：在 int 位置插入 collection 中的所有元素

- `get(int)`：返回 int 位置的元素

- `indexOf(obj)`：返回 obj 首次出现时的位置

- `lastIndexOf(obj)`：返回 obj 最后一次出现时的位置

- `remove(int)`：移除 int 位置的元素，并返回那个被移除的元素

- `set(int, obj)`：设置 int 位置的元素为 obj。相当于替换。返回那个被替换元素的下标

  `setElement(obj, int)`：设置 int 位置的元素为 obj。无返回值

- `subList(int1, int2)`：返回 [int1, int2) 范围的元素构成的子集合

### 9.2.3 可变数组 ArrayList

```
public class ArrayList<E> extends AbstractList<E>
     implements List<E>, RandomAccess, Cloneable, java.io.Serializable
```

> ArrayList 是 List 的实现子类。其底层由数组来实现存储。
>
> ArrayList 可以存放 null

#### ArrayList 的源码：

1. ArrayList 中维护了一个 Object 类型的数组 elementData。该数组就是用来存放元素的数组

   ```
   transient Object[] elementData;
   ```

2. 创建 ArrayList 对象时，如果使用无参构造器，则 elementData[] 初始容量为 0

   ```
   private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
   
   public ArrayList() {
       this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
   }
   ```

3. 如果使用指定大小构造器，则初始容量为指定大小。

   ```
   private static final Object[] EMPTY_ELEMENTDATA = {};
   
   public ArrayList(int initialCapacity) {
       if (initialCapacity > 0) {
           this.elementData = new Object[initialCapacity];
       } else if (initialCapacity == 0) {
   	/* 这个场合，与默认构造器的不同之处在于
   		扩容时，该 0 容量变为 1，而默认构造器会变为 10 */
           this.elementData = EMPTY_ELEMENTDATA;
       } else {
           throw new IllegalArgumentException(...);
       }
   }
   ```

4. 扩容的场合：

   如果是 **无参构造器生成的初始 0 长度的 elementData**，则将其容量置为 10。

   否则容量扩容为 1.5 倍。

   ```
   /* 扩容方法，传入的参数 minCapacity 是容器现有元素数量 + 1 的值
   	如果是无参构造器生成的默认数组，此时传入固定值 10 */
   private void grow(int minCapacity) {
       int oldCapacity = elementData.length;
       /* 计算新的容量（旧容量的 1.5 倍）
       	此处 >> 为位运算符，等同于 newC = oldC + oldC / 2; */
       int newCapacity = oldCapacity + (oldCapacity >> 1);
       /* 这里如果原容量是特殊值（1 或 0），容量会变为那个 minCapacity 的值 */
       if (newCapacity - minCapacity < 0)
           newCapacity = minCapacity;
       if (newCapacity - MAX_ARRAY_SIZE > 0)
           newCapacity = hugeCapacity(minCapacity);
       elementData = Arrays.copyOf(elementData, newCapacity);
   }
   ```

### 9.2.4 可变数组 Vector

```
public class Vector<E>
    extends AbstractList<E>
    implements List<E>, RandomAccess, Cloneable, java.io.Serializable
```

> Vector 是 List 的实现子类。其底层由数组来实现存储
>
> Vector 与 ArrayList 基本等同。ArrayList 效率更高，Vector 线程安全。
>
> 在开发中，需要考虑线程安全时，建议使用 Vector ，而非 ArrayList。

#### Vector 的源码：

1. 底层维护了一个 Object 类型的数组 elementData。用以存放元素

   ```
   protected Object[] elementData;
   ```

2. 使用无参构造器创建对象时，默认大小是 10

   使用有参构造器的场合，默认是那个指定大小（initialCapaticy）

   也能在构造器中指定那个扩容的增长速度（capacityIncrement）

   ```
   public Vector() {
       this(10);
   }
   
   public Vector(int initialCapacity) {
       this(initialCapacity, 0);
   }
   
   public Vector(int initialCapacity, int capacityIncrement) {
       super();
       if (initialCapacity < 0)
           throw new IllegalArgumentException(...);
       this.elementData = new Object[initialCapacity];
       this.capacityIncrement = capacityIncrement;
   }
   ```

3. 扩容的场合，容量变成 2 倍

   使用有参构造器改变了 capacityIncrement 的场合，增量是那个指定数值

   ```
   private void grow(int minCapacity) {
       int oldCapacity = elementData.length;
       /* 计算新的容量（按照指定的增速扩容）
       	那个指定无效或未指定时，容量变为 2 倍 */
       int newCapacity = oldCapacity + ((capacityIncrement > 0) ?
                                        capacityIncrement : oldCapacity);
       if (newCapacity - minCapacity < 0)
           newCapacity = minCapacity;
       if (newCapacity - MAX_ARRAY_SIZE > 0)
           newCapacity = hugeCapacity(minCapacity);
       elementData = Arrays.copyOf(elementData, newCapacity);
   }
   ```

#### 缺点

1. 由于Vector是一个古老的集合。(从jdk1.0开始)，那时候Java还没有提供系统的集合框架，所以在Vector里提供了一些方法名很长的方法。例如:addElement(Object obj)，实际上这个方法和add(Object obj)没什么区别；
2. Vector空间满了之后，扩容是一倍，而ArrayList仅仅是一半；
3. Vector分配内存的时候需要连续的存储空间，如果数据太多，容易分配内存失败；
4. 因为vector是线程安全的，所以效率低，同时只能在尾部进行插入和删除操作，更加造成效率低；

**从jdk1.2以后，Java提供了系统的集合框架，就将Vector改为实现List接口，作为List的实现之一**，从而导致Vector里有一些重复的方法。Vector里有一些功能重复的方法，这些方法中方法名更短的是属于后来新增的方法。更长的是原先vector的方法。而后来[ArrayList](# 2.3 可变数组 ArrayList)是作为List的主要实现类。尽量少用Vector实现类。

### 9.2.5 链表 LinkedList

```
public class LinkedList<E>
    extends AbstractSequentialList<E>
    implements List<E>, Deque<E>, Cloneable, java.io.Serializable
```

> 在 Java 中，LinkedList 是 List 的实现子类，底层以链表形式存储元素。
>
> 链表是一种**非线性结构**：其以节点方式存储，节点间在内存上的位置不连续。
>
> 链表是有序的列表。单向链表每个节点包含 data 域和 next 域。那些 next 域指向下一节点的位置。
>
> 双向链表在单向链表的基础上，每个节点加入 prev 区域以指示其前方节点。这样，就能实现双向查找。双向链表可以不依靠辅助节点而实现自我删除。
>
> LinkedList 底层实现了 双向链表 和 双端队列 特点。在 Java 中，LinkedList 也实现了 Deque 接口。
>
> LinkedList 可以添加 null，可添加重复元素。但没有实现同步，因此线程不安全。

[![img](https://i-melody.github.io/img/Java_InputImage/%E9%93%BE%E8%A1%A8%E5%9B%BE_13.3.3.webp)](https://i-melody.github.io/img/Java_InputImage/链表图_13.3.3.webp)

**常用方法：**

- `void addLast(E e)`：尾插一个新的元素

  LinkedList 的 add 方法即调用该方法

- `void addFirst(E e)`：头插一个新的元素

- `E removeLast()`：移除并返回尾部元素。为空时报错

  `E poll()`：移除并返回尾部元素。为空时返回 null

  `E removeFirst()`：移除并返回头部元素。为空时报错

- `E getLast()`：仅返回尾部元素。为空时报错

  `E peek()`：返回尾部元素。为空时返回 null

  `E element()`：返回头部元素。为空时返回 null

  `E getFirst()`

#### LinkedList 的源码

1. LinkedList 只有默认构造器和一个拷贝构造器

   ```
   public LinkedList() {
   }
   
   public LinkedList(Collection<? extends E> c) {
       this();
       addAll(c);
   }
   ```

2. LinkedList 底层维护了一个 双向链表

   两个属性 first、last 分别指向 首节点 和 尾节点

   每个节点（Node 对象），里面又维护了 prev、next、item 属性。

   其中通过 prev 指向前一个节点，通过 next 指向后一个节点。最终实现双向链表。

   ```
   transient Node<E> first;
   transient Node<E> last;
   
   private static class Node<E> {
       E item;
       Node<E> next;
       Node<E> prev;
   
       Node(Node<E> prev, E element, Node<E> next) {
           this.item = element;
           this.next = next;
           this.prev = prev;
       }
   }
   ```

3. LinkedList 不需要扩容。其增删元素时只要改变节点的指向即可。

   也因此，其添加、删除元素效率比数组更高

#### ArrayList 和 LinkedList 的比较：

|              | 底层结构 | 增删效率       | 改查效率 |
| ------------ | -------- | -------------- | -------- |
| `ArrayList`  | 可变数组 | 低（数组扩容） | 高       |
| `LinkedList` | 双向链表 | 高（链表追加） | 低       |

应该根据实际情况来选择使用的集合：

- 如果改查操作多，选择 ArrayList。一般来说，在程序中，80% - 90% 都是查询。大部分情况下，选择 ArrayList。
- 如果增删操作多，选择 LinkedList

### 9.2.6 稀疏数组

> 二维数组的很多值是默认值 0，因此记录了很多没有意义的数据。因此，可以使用稀疏数组。

稀疏数组的处理方法：

1. 记录数组共有几行几列，有多少个不同的值
2. 把具有不同值的元素的行列及值记录在一个小规模数组中，从而缩小程序规模

**二维数组转换为稀疏数组：**

下面用 ArrayList 模拟一个稀疏数组。

二维数组：

```
int[][] map = {{0, 2, 0, 0, 0, 0 ,0 , 0},
              {0, 0, 3, 0, 0, 0, 0, -1},
              {15, 0, 0, 0, 0, 4, 0, 0},
              {0, 2, 0, 0, 0, 0, 0, 0},
              {0, 0, 0, 0, 0, 0, 0, 0},
              {0, 0, 0, 0, 0, 0, 0, 1},
              {0, 0, 0, 0, 0, 0, 0, 0}};
```

遍历原始的二维数组，得到有效数据的个数 sum，并将二维数组的有效数据存入稀疏数组

```
List<int[]> sparseArray = new ArrayList();

sparseArray.add(new int[]{map.length, map[0].length, 0});	//

for (int y = 0; y < map.length; y++) {
    for (int x = 0; x < map[0].length; x++) {
        if (map[y][x] != 0) {
            sparseArray.add(new int[]{y, x, map[y][x]});
            sparseArray.get(0)[2]++;
        }
    }
}
```

**稀疏数组转化为二维数组：**

读取稀疏数组的每一行，按照其第一行数据，创建原始的二维数组。

读取后几行数据，将值赋给二维数组

### 9.2.7 栈 Stack

```
public class Stack<E> extends Vector<E>
```

> Stack 是 Vector 的子类。以数组模拟了栈的数据结构。
>
> 栈是一个先入后出的有序列表。其元素之插入删除只能在该线性表的同一端进行。
>
> 其允许增删的一端称为栈顶，另一端即为栈底。
>
> 最先放入的元素位于栈底，最后放入的元素位于栈顶。
>
> 放入元素称为入栈（push），取出元素称为出栈（pop）

![](D:/College_life/Journal/images/stack.png "")

**栈的应用场景：**

- 子程序的调用
- 处理递归调用
- 表达式的转换与求值
- 二叉树的遍历
- 图形的深度优先搜索法

**常用方法：**

- `E push(E item)`：将元素 item 压入栈。返回值是 item 自己

- `E pop()`：让栈顶元素出栈

- `E peek()`：仅获取栈顶元素

- `int search(Object o)`：查找该元素最后出现的位置。

  栈底为 1，栈顶为 size()，不存在返回 -1

#### 缺点

由于在Java中Stack继承自Vector，因此Stack也是通过数组实现的，而非链表。同时Stack也继承了Vector的缺点（重复的方法、即使多线程也并不安全）。而且由于Stack类表示后进先出（LIFO）的对象堆栈，而Vector的很多方法背离了Stack的宗旨。因此推荐使用[ArrayDeque](# 3.3 双端队列接口 Deque)作为替代。

#### 栈模拟计算器

> 使用栈结构完成对计算器的实现

要进行计算，需要获得表达式。

表达式分为三种：

- **中缀表达式：**

  中缀表达式即生活中常见的运算表达式。比如：(3 + 4) * 5 - 6

  中缀表达式是人最熟悉的。但是对于计算机来说却不好操作。因此，计算时常将其转化为其他表达式进行操作。

- **前缀表达式：**

  前缀表达式（波兰表达式）是一种没有括号的表达式。其将运算符写在前面，操作数写在后面

  > (3 + 4) * 5 - 6 的前缀表达式为： + 3 * 4 - 5 6
  >
  > (1 + 2) * (3 + 4) 的前缀表达式为：* + 1 2 + 3 4

  前缀表达式的计算机求值：

  - 从**右**向**左**扫描表达式
  - 将数字压入堆栈
  - 遇到运算符的场合，对数字栈顶元素与次顶元素进行计算，并把那个结果入栈
  - 重复该操作，最终数字栈的唯一剩余数字即为运算结果

- **后缀表达式：**

  后缀表达式（逆波兰表达式）与前缀表达式相似。但其运算符位于操作数之后

  > (3 + 4) * 5 - 6 的后缀表达式为： 3 4 + 5 * 6 -
  >
  > (1 + 2) * (3 + 4) 的后缀表达式为：1 2 + 3 4 + *

  后缀表达式的计算机求值：

  - 从**左**向**右**扫描表达式
  - 将数字压入堆栈
  - 遇到运算符的场合，对数字栈顶元素与次顶元素进行计算，并把那个结果入栈
  - 重复该操作，最终数字栈的唯一剩余数字即为运算结果

对于人类来说，中缀表达式最为熟悉。但对于计算机来说，前缀、后缀表达式更容易识别。

我们可以将中缀表达式转化为后缀表达式，再进行运算。

**中缀表达式转换为后缀表达式：**

1. 初始化两个栈：运算符栈 operator_stack、表达式栈 formula_stack

2. 从左到右扫描中缀表达式

3. 遇到操作数时，将其压入表达式栈 formula_stack

4. 遇到运算符时，比较其与 operator_stack 栈顶运算符的优先级。

   - operator_stack 为空，或栈顶为 `(` 的场合，让运算符入栈
   - 优先级高于栈顶运算符的场合，让其入栈
   - 优先级低于或等于栈顶运算符的场合，将那个堆顶运算符弹出并压入 formula_stack。之后，重复该步骤。

5. 遇到括号时：

   - 遇到 `(` 时，压入 operator_stack
   - 遇到 `)` 时，直到遇到 `(` 前，依次弹出 operator_stack 堆顶的运算符，并压入 formula_stack。之后将这一对括号丢弃。

6. 到达表达式最右边时，依次弹出 operator_stack 堆顶的运算符，压入 formula_stack。

7. 此时，formula_stack 即为后缀表达式。

   使用 Java 的 toArray 方法将其转为数组。或将其依次弹出，并逆序输出。

**计算器的实现：**

```
class Calculator {
    private static final Map<Character, Integer> priority = new HashMap<>();

    static {
        priority.put('+', 1);
        priority.put('-', 1);
        priority.put('*', 2);
        priority.put('/', 2);
        priority.put('×', 2);
        priority.put('÷', 2);
        priority.put('(', -100);
        priority.put(')', -10);
    }

    public static double calculate(String formula) {
        String[] ss = formula.split(" ");
        Stack<String> operator_stack = new Stack<>();
        Stack<String> formula_stack = new Stack<>();
        for (String s : ss) {
            if (s.matches("\\d+([.]\\d+)?")) {
                formula_stack.push(s);
                continue;
            } else if (operator_stack.empty() || s.equals("(")) {
                operator_stack.push(s);
                continue;
            }
            String temp = operator_stack.peek();
            while (priority.get(s.charAt(0)) <= priority.get(temp.charAt(0))) {
                formula_stack.push(operator_stack.pop());
                if (operator_stack.empty()) break;
                temp = operator_stack.peek();
            }
            if (s.equals(")")) {
                operator_stack.pop();
            } else operator_stack.push(s);

        }
        while (!operator_stack.empty()) {
            formula_stack.push(operator_stack.pop());
        }
        return anti_Poland(String.join(" ", formula_stack.toArray(new String[]{})));
    }

    private static double anti_Poland(String formula) {
        String[] ss = formula.split(" ");
        Stack<Double> ns = new Stack<>();
        for (String s : ss) {
            try {
                double num = Double.parseDouble(s);
                ns.push(num);
            } catch (Exception e) {
                switch (s) {
                    case "+":
                        ns.push(ns.pop() + ns.pop());
                        break;
                    case "*":
                    case "×":
                        ns.push(ns.pop() * ns.pop());
                        break;
                    case "/":
                    case "÷":
                        ns.push(1 / ns.pop() * ns.pop());
                        break;
                    case "-":
                        ns.push(-ns.pop() + ns.pop());
                        break;
                    default:
                        throw new RuntimeException("Illegal operator");
                }
            }
        }
        return ns.pop();
    }
}
```

### 9.2.8 跳表 SkipList

跳表是一种特殊的链表。普通的链表虽然添加、删除节点的速度很快（O(1)），但是要查找节点却很慢（O(n)）。跳表是一个多层次的链表，其在链表的基础上增加了多级索引，实现了 O(㏒n) 的查找速度。

[![img](https://i-melody.github.io/img/Java_InputImage/13_3_6%20%E8%B7%B3%E8%A1%A8%E5%9B%BE.webp)](https://i-melody.github.io/img/Java_InputImage/13_3_6 跳表图.webp)

*（13_3_6 跳表图）*

跳表将原本数据层的数据按照一定间隔抽取节点形成索引层，之后再从索引层抽取节点形成第二级索引，以此类推形成多层索引。

跳表的查询速度得到了优化，但占用空间更大。本质上是一种空间换时间的做法。

**查询**

从最稀疏的索引层（最上层）开始，确定那个待查找数据所在的范围，逐层向下并确定范围，直至数据层。

**增删**

删除元素时，如果那个元素是索引元素，那些索引也会被删除。同时，如果只向数据层中增加元素，可能使索引间隔过大，从而降低查找效率。如果在增加元素时还能保持索引数量的动态平衡，就能防止跳表退化，保持跳表效率。

跳表给出的解决方案是：在增加元素时产生一个随机值，让这个随机值决定该新节点是否成为索引节点，以及成为几级索引节点。

**实现跳表**

```
class Skiplist {
    private final int level;					// 该跳表的合计层数，包括数据层和索引层
    private final Random seed;					// 随机数种子
    private final Node root;					// 链表开头
    private final Node end;						// 链表结尾

    private static class Node {					// 链表节点类
        int val;				// 值
        int count;				// 储存的值的数量
        Node[] next;			// 指向的下一节点
        Node[] prev;			// 指向的上一节点
        						// 需要指出的是：next 和 prev 的长度指示了节点所在的最高层级
        						// 长度为 1 时仅处在数据层，2 时也位于一级索引，以此类推
        						// 也就是说，next 和 prev 里，下标 0 的位置位于数据层，1 位于一级索引层

        /* 三个参数是：值 val，节点的层级 rand，节点储存值的数量 count */
        Node(int val, int rand, int count) {
            this.val = val;
            this.count = count;
            next = new Node[rand];
            prev = new Node[rand];
        }
    }

    /* 构造器 */
    public Skiplist() {
        this(4);
    }
	
    /* 有参构造器。输入的值是索引层数量。该值至少应为 1 */
    public Skiplist(int level) {
        if (level < 1 || level > 30)
            throw new RuntimeException(level == 0 ?
                    "Why not choose a LinkedList?" :
                    "SkipList level out of range: given " + level + " out of range [1, 30]");
        this.level = level + 1;
        this.seed = new Random(System.currentTimeMillis());
        root = new Node(Integer.MIN_VALUE, this.level, 0);
        end = new Node(Integer.MAX_VALUE, this.level, 0);
        for (int n = 0; n < this.level; n++) {
            root.next[n] = end;
            end.prev[n] = root;
        }
    }
	
    /* 查询一个值是否存在 */
    public boolean search(int target) {
        Node find = position(target);
        return find.val == target && find.count > 0;
    }
	
    /* 搜索一个值的位置。不存在时会返回数据层中前一个节点的位置 */
    private Node position(int target) {
        Node see = root;
        while (true) {
            if (see.val == target) return see;
            for (int n = see.next.length - 1; ; n--) {
                if (n < 0) return see;
                else if (see.next[n].val <= target) {
                    see = see.next[n];
                    break;
                }
            }
        }
    }
	
    /* 添加一个值 */
    public void add(int num) {
        Node pos = position(num);
        if (pos.val == num) {		// 如果这个节点已经建立，就仅使该节点计数增加
            pos.count++;
            return;
        }
        int rand = 1 + level - Integer.toBinaryString(seed.nextInt(1 << level)).length();
        			// level 的值等于总层数。seed 是一个随机数种子，nextInt(int n) 方法返回 [0, n) 的数值
        			// Integer.toBinaryString(int n) 方法是将一个数字转化成二进制表示的字符串
        			// seed.nextInt(1 << level) 保证了返回值的二进制长度在 [1, level] 之间，并且概率合意
        Node add = new Node(num, rand, 1);
        for (int t = 0; t < rand; ) {			// 将新节点添加到链表中。
            for (; t < pos.next.length && t < rand; t++) {
                Node next = pos.next[t];
                add.next[t] = next;
                next.prev[t] = add;
                pos.next[t] = add;
                add.prev[t] = pos;
            }
            pos = pos.prev[pos.prev.length - 1];
        }
    }
	
    /* 删除节点（的值） */
    public boolean erase(int num) {
        Node pos = position(num);
        if (pos.val == num && pos.count > 0) {
            pos.count--;
            return true;
        } else return false;
    }
}
```

### 9.2.9 CopyOnWriteArrayList 

CopyOnWriteArrayList可以用来代替Vector进行并发操作。CopyOnWrite容器即写时复制的容器。通俗的理解是**当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。**这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。

CopyOnWriteArrayList在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。而读的时候不需要加锁，如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据，因为开始读的那一刻已经确定了读的对象是旧对象。因此**CopyOnWriteArrayList适用于读多写少的场景**。

**CopyOnWriteArrayList读取时不加锁，只是写入、删除、修改时加锁**，所以一个线程X读取的时候另一个线程Y可能执行remove操作。remove操作首先要获取独占锁，然后进行写时复制操作，就是复制一份当前的array数组，然后在复制的新数组里面删除线程X通过get访问的元素，比如：删除完成后让array指向这个新的数组。
在线程x执行get操作的时候并不是直接通过全局array访问数组元素而是通过方法的形参a访问的，**a指向的地址和array指向的地址在调用get方法的那一刻是一样的，都指向了堆内存的数组对象。之后改变array指向的地址并不影响get的访问，因为在调用get方法的那一刻形参a指向的内存地址就已经确定了，不会改变。所以读的仍然是旧数组。**

#### 缺点

1. **内存占用问题**。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。

   针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如[ConcurrentHashMap](# 3.3.5 ConcurrentHashMap)。

2. **数据一致性问题**。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。**【当执行add或remove操作没完成时，get获取的仍然是旧数组的元素】**

## 9.3 队列接口 Queue

```
public interface Queue<E> extends Collection<E>
```

> Queue 是 Collection 的子接口
>
> Queue 的实现子类都是队列式集合。队列是一个有序列表，可以用数组或链表来实现
>
> 队列遵循先入先出的原则。队列中元素是以添加顺序取出的。
>
> 向队列中增加元素称为**入列**（push），取出元素称为**出列**（pop）

[![img](https://i-melody.github.io/img/Java_InputImage/%E9%98%9F%E5%88%97%E5%9B%BE_13.4.webp)](https://i-melody.github.io/img/Java_InputImage/队列图_13.4.webp)

**常用方法：**

- `add(E e)`：添加元素。队列满的场合抛出异常

  `put(E e)`：添加元素。队列满的场合可能阻塞

  `boolean offer(E e)`：添加元素。队列满的场合返回 false

- `E remove()`：移除并返回队列头部元素。队列空的场合抛出异常

  `E poll()`：移除并返回队列头部元素

  `E take()`：移除并返回队列头部元素。队列空的场合可能阻塞

- `E peek()`：仅返回队列头部元素。为空时返回 null

  `E element()`：仅返回队列头部元素。为空时抛出异常

### 9.3.1 优先级队列 PriorityQueue

```
public class PriorityQueue<E> extends AbstractQueue<E>
    implements java.io.Serializable
```

> PriorityQueue 是一个无界优先级队列。底层以数组储存元素。
>
> 无界队列：即没有范围限制的队列。
>
> PriorityQueue 不允许 null 元素，也不允许不可比较的元素。
>
> PriorityQueue 中的元素以自然顺序，或传入的比较器决定的顺序排序。其中的最小元素位于队头，最大元素位于队尾。
>
> 以迭代器遍历时，会按照原本的放入顺序获取元素。PriorityQueue 的源码：

1. 底层维护了一个 Object 类型的数组 queue。用以存放元素

   另维护了一个比较器 comparator，用以比较元素

   ```
   transient Object[] queue;
   private final Comparator<? super E> comparator;
   ```

2. 默认构造器初始容量为 11，比较器为 null

   也能指定初始容量，或传入比较器

   ```
   public PriorityQueue() {
       this(DEFAULT_INITIAL_CAPACITY, null);
   }
   
   public PriorityQueue(int initialCapacity) {
       this(initialCapacity, null);
   }
   
   public PriorityQueue(Comparator<? super E> comparator) {
       this(DEFAULT_INITIAL_CAPACITY, comparator);
   }
   
   public PriorityQueue(int initialCapacity,
                        Comparator<? super E> comparator) {
       if (initialCapacity < 1)
           throw new IllegalArgumentException();
       this.queue = new Object[initialCapacity];
       this.comparator = comparator;
   }
   ```

3. 放入时依靠比较器 comparator 进行排序。

   那个比较器为 null 的场合，每次放入元素会按元素自身的自然顺序进行排序。

   不能排序的场合会抛出异常。

4. 扩容时，容量小于 64 的场合容量变为 2 倍 + 2。否则那个容量变为 1.5 倍

   ```
   private void grow(int minCapacity) {
           int oldCapacity = queue.length;
           int newCapacity = oldCapacity + ((oldCapacity < 64) ?
                                            (oldCapacity + 2) :
                                            (oldCapacity >> 1));
           if (newCapacity - MAX_ARRAY_SIZE > 0)
               newCapacity = hugeCapacity(minCapacity);
           queue = Arrays.copyOf(queue, newCapacity);
       }
   ```

### 9.3.2 阻塞队列接口 BlockingQueue

```
public interface BlockingQueue<E> extends Queue<E>
```

> BlockingQueue 是一个接口，其实现子类都是阻塞队列。
>
> 阻塞队列：
>
> - 元素入列时，那个队列已满的场合，会进行等待。直到有元素出列后，元素数量未超过队列总数时，解除阻塞状态，进而继续入列。
> - 元素出列时，如果队列为空，则会进行等待。直到有元素入列时，解除阻塞状态，进而继续出列。
> - 阻塞队列能防止容器溢出。只要是阻塞队列，就是线程安全的队列。
> - 阻塞队列不接受 null 元素

**常用方法**

实际上，其常用方法能分为几类

| 队列为空/满时… | 抛出异常  | 特殊值   | 阻塞   | 等待                 |
| -------------- | --------- | -------- | ------ | -------------------- |
| 插入           | add(e)    | offer(e) | put(e) | offer(e, time, unit) |
| 删除           | remove()  | poll()   | take() | take(time, unit)     |
| 查找           | element() | peek()   | -      | -                    |

**BlockingQueue 的常用实现子类**

- ArrayBlockingQueue：底层以数组存放元素的有界阻塞队列，是有界的
- LinkedBlockingQueue：底层以链表存放元素的可选边界的阻塞队列，无界，但不是真正的无界，最大为int的最大值
- PriorityBlockingQueue：优先级阻塞队列，与 PriorityQueue 排序方式相同

### 9.3.3 双端队列接口 Deque

```
public interface Deque<E> extends Queue<E>
```

> Deque 是 Queue 的子接口。
>
> Deque 的实现子类都是双端队列。双端队列的两端都可以添加、删除。可见，Deque 双端队列既有队列的特性，又有栈的特性。

**常用方法**

Deque 接口同样提供了一系列方法

| 操作的是…      | 头元素         | 尾元素        |               |              |
| -------------- | -------------- | ------------- | ------------- | ------------ |
| 队列为空/满时… | 抛出异常       | 特殊值        | 抛出异常      | 特殊值       |
| 插入           | addFirst(e)    | offerFirst(e) | addLast(e)    | odderLast(e) |
| 删除           | removeFirst(e) | pollFirst(e)  | removeLast(e) | pollLast(e)  |
| 查找           | getFirst(e)    | peekFirst(e)  | getLast(e)    | peekLast(e)  |

**Deque 的常用实现子类**

- LinkedList：双向链表。在 Java 中，LinkedList 也实现了 Deque 接口。
- ArrayDeque：基于数组实现的双端队列。
- LinkedBlockingDeque：以双向链表实现的，双端阻塞队列。该类事实上也继承了 BlockingQueue 接口。

### 9.3.3 双列集合接口 Map

```
public interface Map<K,V>
```

**以下关于 Map 接口的描述，适用于 JDK 8 的环境**

> Map 与 Collection 并列存在，用于保存具有映射关系的数据：key - value（双列元素）
>
> Map 的 key 和 value 可以是任何类型的引用数据类型，也能存入 null。
>
> Map 的 key 不允许重复，value 可以重复。key 和 value 存在单一对应关系。通过特定的 key 一定能找到指定的 value。
>
> 一组 k - v 会被封装到一个 Entry 对象中。Entry 是一个内部接口。Map 的实现子类中都包含一个实现这个接口的内部类。
>
> ```
> interface Entry<K,V> {
> 	K getKey();
> 	V getValue();
>  ...
> }
> ```
>
> 如果添加相同的 key，会覆盖原先的 key -value。等同于修改（key 不会替换，value 会被替换）

**常用方法：**

- `put()`：添加。已存在的场合，实行替换。（key 不替换，value 替换）

- `remove()`：根据键删除映射关系

- `get()`：根据键获取值

- `size()`：元素个数

- `isEmpty()`：判断个数是否为 0

- `clear()`：清空

- `containsKey()`：查找键是否存在

- `Set<K> keySet()`：获取所有 键 构成的集合

  `Set<Map.Entry<K,V>> entrySet()`：获取所有 Entry 构成的集合

  `Collection<V> values()`：获取所有 值 构成的集合

#### Map 接口遍历元素：

- **方法一**：利用 `Set<K> keySet()` 方法

  先得到所有 keys，再遍历 keys，根据每个 key 获得 value：

  ```
  Set keyset = map.keySet();
  for (Object o : keyset) {
  	System.out.println(o + " = " + map.get(o));
  }
  ```

- **方法二**：利用 `Set<V> values()` 方法

  直接把所有 values 取出，之后遍历 values

  ```
  Collection values = map.values();
  for (Object value : values) {
  	System.out.println(value);
  }
  ```

- **方法三**：利用 `Set<Map.Entry<K,V>> entrySet()` 方法

  通过获取 entrySet 来获取 k - v

  ```
  Set<Map.Entry> entrySet = map.entrySet();
  for (Map.Entry e : entrySet) {
  	System.out.println(e.getKey() + " - " + e.getValue());
  }
  ```

#### 9.3.3.1 散列表 HashMap

```
public class HashMap<K,V> extends AbstractMap<K,V>
    implements Map<K,V>, Cloneable, Serializable
```

> HashMap 是 Map 接口使用频率最高的实现类。是根据关键码值（key value）而进行直接访问的数据结构。通过将关键码值映射到表中一个位置来访问记录，以加快查找速度。
>
> 那个映射函数叫做散列函数，存放记录的数组叫做散列表（哈希表）
>
> HashMap 是以 k - v 对得到方式来存储数据。一组数据会被封装到一个 Node 对象中。
>
> ```
> static class Node<K,V> implements Map.Entry<K,V> {
> final int hash;
> final K key;
> V value;
> Node<K,V> next;
> 
> ...
> }
> ```
>
> JDK 7 前，HashMap 底层是 数组 + 链表。JDK 8 后，底层是 Node数组 + 链表 + 红黑树。HashMap 不保证映射的顺序。
>
> HashMap 没有实现同步（没有 synchronized），是线程不安全的

##### HashMap 的源码：

1. HashMap 底层维护了 Node 类型的数组 table。默认为 null

   ```
   transient Node<K,V>[] table;
   ```

   另外，还有集合 values、keySet、enrtySet。这些集合能帮助程序员进行遍历

   ```
   transient Set<K>				keySet;
   transient Collection<V>			values;
   transient Set<Map.Entry<K,V>>	entrySet;
   ```

2. 创建对象时，默认构造器将加载因子（loadfactor）初始化为 0.75。

   也能指定那些初始容量和加载因子。

   默认构造器第一次添加元素的场合，table 扩容为 16，临界值为 16 * 0.75 = 12。

   ```
   static final float DEFAULT_LOAD_FACTOR = 0.75f;
   static final int MAXIMUM_CAPACITY = 1 << 30;
   
   
   public HashMap() {
       this.loadFactor = DEFAULT_LOAD_FACTOR;					// 这个默认构造的场合，其他参数都是默认值
   }
   
   public HashMap(int initialCapacity) {
       this(initialCapacity, DEFAULT_LOAD_FACTOR);
   }
   
   public HashMap(int initialCapacity, float loadFactor) {
       if (initialCapacity < 0)
           throw new IllegalArgumentException(...);
       if (initialCapacity > MAXIMUM_CAPACITY)
           initialCapacity = MAXIMUM_CAPACITY;
       if (loadFactor <= 0 || Float.isNaN(loadFactor))
           throw new IllegalArgumentException(...);
       this.loadFactor = loadFactor;
       this.threshold = tableSizeFor(initialCapacity);
   }
   ```

3. 添加时容量不够的场合，需要扩容。

   默认构造器第一次添加元素的场合，table 扩容为 16，临界值为 16 * 0.75 = 12。

   扩容的场合，容量变为 2 倍。临界值相应变化。

   临界值不会超过那个指定的 MAXIMUM_CAPACITY（1 << 30），否则变成 Integer.MAX_VALUE。

   JDK 8 中，如果一条链表的元素个数超过 TREEIFY_THRESHOLD（默认是 8），并且 `table` 的大小 >= MIN_TREEIFY_CAPACITY（默认 64），会进行树化。

   剪枝：红黑树的元素减少到一定程度，会被重新转化为 链表

   ```
   static final int MAXIMUM_CAPACITY = 1 << 30;
   static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;
   
   final Node<K,V>[] resize() {
       Node<K,V>[] oldTab = table;								// <- 旧的数据数组 table
       int oldCap = (oldTab == null) ? 0 : oldTab.length;		// <- 旧的 table 的容量
       int oldThr = threshold;									// <- 旧的临界值
       int newCap, newThr = 0;									// <- 新的容量、临界值
       
       /* 旧的数组不为空时，
       	如果容量已达指定的 MAXIMUM_CAPACITY，则不扩容
       	否则扩容为 2 倍容量，临界值也变为 2 倍 */
       if (oldCap > 0) {
           newCap = oldCap << 1;
           if (oldCap >= MAXIMUM_CAPACITY) {
               threshold = Integer.MAX_VALUE;
               return oldTab;
           }
           else if (newCap < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY)
               newThr = oldThr << 1;
       }
       /* 旧的数组为空，但临界值已被指定（原因是：指定构造器传入初始容量为 0） */
       else if (oldThr > 0)
           newCap = oldThr;
       /* 旧的数组为空，临界值为 0（原因是：使用默认构造器）
       	默认构造器初始化容量为 16，默认临界因子为 0.75f */
       else {
           newCap = DEFAULT_INITIAL_CAPACITY;
           newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
       }
       
       /* 到这里，newThr（新临界值）为 0 的原因可能是：
       	1. 旧容量小于那个最小容量（16）
       	2. 扩容后容量大于那个最大容量
       	3. 旧的临界值为 0 或 Integer.MIN_VALUE
       	4. 构造器传入初始容量为 0 */
       if (newThr == 0) {
           /* 按照 新容量 * 临界因子 的方法计算临界值。临界值不会超过一个指定的最大值 */
           float ft = (float)newCap * loadFactor;
           newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                     (int)ft : Integer.MAX_VALUE);
       }
       threshold = newThr;
       
       /* 确定了容量和临界值，下面把旧数组元素移至新数组。
       	那个移动的场合，会以新容量重新计算所有元素的下标位置 */
       Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
       table = newTab;
       if (oldTab != null) {
           for (int j = 0; j < oldCap; ++j) {
               Node<K,V> e;
               if ((e = oldTab[j]) != null) {
                   oldTab[j] = null;
                   if (e.next == null)
                       newTab[e.hash & (newCap - 1)] = e;
                   else if (e instanceof TreeNode)
                       ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                   else {
                       Node<K,V> loHead = null, loTail = null;
                       Node<K,V> hiHead = null, hiTail = null;
                       Node<K,V> next;
                       do {
                           next = e.next;
                           if ((e.hash & oldCap) == 0) {
                               if (loTail == null)
                                   loHead = e;
                               else
                                   loTail.next = e;
                               loTail = e;
                           }
                           else {
                               if (hiTail == null)
                                   hiHead = e;
                               else
                                   hiTail.next = e;
                               hiTail = e;
                           }
                       } while ((e = next) != null);
                       if (loTail != null) {
                           loTail.next = null;
                           newTab[j] = loHead;
                       }
                       if (hiTail != null) {
                           hiTail.next = null;
                           newTab[j + oldCap] = hiHead;
                       }
                   }
               }
           }
       }
       return newTab;
   }
   ```

4. 添加 k - v 时，通过 key 的哈希值得到其在 table 的索引，判断索引位置是否被占用。

   未占用的场合，直接添加。

   占用的场合，判断其 key 是否相等。相等的场合，替换 value。否则，按照 树 或 链表 的方式处理。

   ```
   public V put(K key, V value) {
       return putVal(hash(key), key, value, false, true);
   }
   
   
   /* 会先对放入元素的哈希值进行一次计算，得到一个数字：hash */
   static final int hash(Object key) {
       int h = key.hashCode();
       return (key == null) ? 0 : (h ^ (h >>> 16));	// 位运算符：>>> 无符号右移
   }
   
   
   /* put 方法会调用该 putVal 方法。
   	那些传入值是：	hash、	key、	value、			false、				true */
   final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
       Node<K,V>[] tab = table; 		// <- 是那个存放数据的 table 数组
       int n;							// <- 是 table.length
       
       /* 如果原先的 table 为空，则对其重新分配空间 */
       if (tab == null || (n = tab.length) == 0) {
           tab = resize();
           n = tab.length;
       }
       
       /* 用方才计算的 hash 数，得到要放入元素的下标值 i
       	n - 1 是数据数组的最大下标，(n - 1) & hash 必定不大于 n - 1 */
       int i = (n - 1) & hash;			// 位运算符：& 按位与
       Node<K,V> p = tab[i];			// 得到 table 中，位于那个插入位置的元素
       
       
       /* 倘若该位置为空，则直接放入 */
       if (p == null) {
           tab[i] = newNode(hash, key, value, null);
       }
       /* 该位置不为空，意味着可能添加了重复元素 */
       else {
           Node<K,V> e; 			// <- 被发现重复的那个 Node。无重复时结果为 null。这个 Node 的 value 会被替换。
           K k = p.key;			// <- 当前取出进行比较的 key 值
           
           /* 为了验证其是否重复，这里要进行如下比较：
           	1. 比较两者的 hash 数。不同的场合是不同元素
           	2. 使用 == 和 equals 两种方法比较 key。不同的场合是不同元素 
           	如果是相同元素，则该节点的值会被替换 */
           if (p.hash == hash && (k  == key || (key != null && key.equals(k)))) {
               e = p;
           }
           
           /* 此处节点结构是 树 的场合，还需遍历比较树的每个节点 */
           else if (p instanceof TreeNode)
               e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
           
           /* 此处节点结构是 链表 的场合，还需遍历比较每个链表节点 */
           else {
               for (int binCount = 0; ; ++binCount) {
                   e = p.next;
                   /* e == null 意味着遍历结束，全部不同。这样，在此处添加那个新的 Node */
                   if (e == null) {
                       p.next = newNode(hash, key, value, null);
                       if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                           treeifyBin(tab, hash);
                       break;
                   }
                   /* 故技重施，如果发现相同，则替换那个新元素 */
                   if (e.hash == hash &&
                       ((k = e.key) == key || (key != null && key.equals(k)))) {
                       break;
                   }
                   p = e;
               }
           }
           
           /* 经历上述比较后，e != null 意味着有元素要被替换了 */
           if (e != null) {
               V oldValue = e.value;
               /* 传入的参数 onluIfAbsent == false，所以此处一定是 true */
               if (!onlyIfAbsent || oldValue == null)
                   e.value = value;
               afterNodeAccess(e);		// <- HashMap 中，该方法为空实现。
               return oldValue;
           }
       }
       ++modCount;
       
       /* 如果到达这里，说明添加了元素（而非替换），要查看大小是否超过临界值 */
       if (++size > threshold)
           resize();
       afterNodeInsertion(evict);		// <- HashMap 中，该方法为空实现。
       return null;
   }
   
   
   /* 上面提到的一些空实现的方法 */
   void afterNodeAccess(Node<K,V> p) { }
   void afterNodeInsertion(boolean evict) { }
   void afterNodeRemoval(Node<K,V> p) { }
   ```

#### 9.3.3.2 散列表 Hashtable

```
public class Hashtable<K,V>
    extends Dictionary<K,V>
    implements Map<K,V>, Cloneable, java.io.Serializable
```

> Hashtable 和 HashMap 基本一致，但Hashtable 是线程安全的 。但也因为如此，Hashtable 的效率低下。

##### Hashtable 与 HashMap 的比较：

|           | 版本 | 线程安全（同步） | 效率 | 是否允许 null值 |
| --------- | ---- | ---------------- | ---- | --------------- |
| Hashtable | 1.0  | 安全             | 较低 | 不允许          |
| HashMap   | 1.2  | 不安全           | 高   | 允许            |

- Hashtable 底层也是有数组，默认构造器的初始容量为 11。临界值是 11 * 0.75 = 8。

- 扩容大致如下：

  ```
  int newCapacity = (oldCapacity << 1) + 1;			//即，原容量 * 2 + 1
  ```

- Hashtable 不会树化

##### 缺点

1. HashMap继承了AbstractMap，HashTable继承Dictionary抽象类，两者均实现Map接口，然而Dictionary类是一个已经被废弃的类，因此也不推荐使用其子类HashTable。单线程操作时使用[HashMap](# 3.3.1 散列表 HashMap)，而要多线程操作的时候可以使用线程安全且效率高的的[ConcurrentHashMap](# 3.3.5 ConcurrentHashMap)。
2. HashTable使用synchronized来锁住整张Hash表来实现线程安全，即每次锁住整张表让线程独占，相当于所有线程进行读写时都去竞争一把锁，导致效率非常低下。

#### 9.3.3.3 红黑树 TreeMap

```
public class TreeMap<K,V>
    extends AbstractMap<K,V>
    implements NavigableMap<K,V>, Cloneable, java.io.Serializable
```

> TreeMap 实现了 Map 接口。底层使用 红黑树 存储数据。
>
> 相较数组（访问快，检索、插入慢）和链表（插入快，检索、访问慢），树形数据结构（如二叉排序树）在保证数据检索速度的同时，也能保证数据插入、删除、修改的速度

***——见 [[14.1.4.1 平衡二叉树\]](https://i-melody.github.io/2022/06/02/Java/入门阶段/14 树/#14-1-4-1-平衡二叉树)***

##### TreeMap 的源码：

1. TreeMap 底层维护了一个二叉树，以及一个比较器

   ```
   private final Comparator<? super K> comparator;
   
   private transient Entry<K,V> root;
   ```

2. 创建对象时，能采用无参构造，也能指定比较器完成构造

   那个无参构造的场合，比较器为空。

   ```
   public TreeMap() {
       comparator = null;
   }
   
   public TreeMap(Comparator<? super K> comparator) {
       this.comparator = comparator;
   }
   ```

   比较器如果为空，则要求传入的 key 必须是 Comparable 接口的实现子类，否则无法进行比较。

   ```
   final int compare(Object k1, Object k2) {
       return comparator==null ? ((Comparable<? super K>)k1).compareTo((K)k2)
           : comparator.compare((K)k1, (K)k2);
   }
   ```

3. 添加时，通过比较器确定那个添加位置。

   ```
   public V put(K key, V value) {
       Entry<K,V> t = root;	// <- 树的根节点
       
       /* 二叉树为空的场合，创建根节点，将数据放入 */
       if (t == null) {
           compare(key, key);
           root = new Entry<>(key, value, null);
           size = 1;
           modCount++;
           return null;
       }
       
       int cmp;				// <- 临时值，存放比较结果
       Entry<K,V> parent;		// <- 临时值，存放父节点
       Comparator<? super K> cpr = comparator;		// <- 比较器
       
       /* 有比较器的场合，按照这个方法进行比较 */
       if (cpr != null) {
           do {
               parent = t;
               cmp = cpr.compare(key, t.key);
               if (cmp < 0)
                   t = t.left;
               else if (cmp > 0)
                   t = t.right;
               else
                   return t.setValue(value);
           } while (t != null);
       }
       
       /* 比较器为空的场合，按照这个方法进行比较 */
       else {
           if (key == null) {
               throw new NullPointerException();
           }
           Comparable<? super K> k = (Comparable<? super K>) key;
           do {
               parent = t;
               cmp = k.compareTo(t.key);
               if (cmp < 0)
                   t = t.left;
               else if (cmp > 0)
                   t = t.right;
               else
                   return t.setValue(value);
           } while (t != null);
       }
       
       /* 将数据节点放到正确的路径下 */
       Entry<K,V> e = new Entry<>(key, value, parent);
       if (cmp < 0)
           parent.left = e;
       else
           parent.right = e;
       
       /* 此处会试着将该树转换成完全二叉树 */
       fixAfterInsertion(e);
       size++;
       modCount++;
       return null;
   }
   ```

4. 添加的最后，会试着将该树转换成完全二叉树

   ```
   private void fixAfterInsertion(Entry<K,V> x) {
       x.color = RED;
   
       while (x != null && x != root && x.parent.color == RED) {
           if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
               Entry<K,V> y = rightOf(parentOf(parentOf(x)));
               if (colorOf(y) == RED) {
                   setColor(parentOf(x), BLACK);
                   setColor(y, BLACK);
                   setColor(parentOf(parentOf(x)), RED);
                   x = parentOf(parentOf(x));
               } else {
                   if (x == rightOf(parentOf(x))) {
                       x = parentOf(x);
                       rotateLeft(x);
                   }
                   setColor(parentOf(x), BLACK);
                   setColor(parentOf(parentOf(x)), RED);
                   rotateRight(parentOf(parentOf(x)));
               }
           } else {
               Entry<K,V> y = leftOf(parentOf(parentOf(x)));
               if (colorOf(y) == RED) {
                   setColor(parentOf(x), BLACK);
                   setColor(y, BLACK);
                   setColor(parentOf(parentOf(x)), RED);
                   x = parentOf(parentOf(x));
               } else {
                   if (x == leftOf(parentOf(x))) {
                       x = parentOf(x);
                       rotateRight(x);
                   }
                   setColor(parentOf(x), BLACK);
                   setColor(parentOf(parentOf(x)), RED);
                   rotateLeft(parentOf(parentOf(x)));
               }
           }
       }
       root.color = BLACK;
   }
   ```

#### 9.3.3.4 Properties

> Properties 继承自 Hashtable 并实现了 Map 接口。也使用键值对的方式保存数据
>
> Properties 使用特点与 Hashtable 相似
>
> Properties 还可以用于 xxx.properties 文件中，加载数据到 Properties 对象，进行读取和修改
>
> xxx.properties 文件常作为配置文件

```
public class Properties extends Hashtable<Object,Object>
```

***——关于这些，详见 [[17 IO流 \]](https://i-melody.github.io/2022/01/06/Java/入门阶段/17 IO流/)***

- `String getProperty(String key)` ：输入一个 String 类型的 key，返回一个 String 的 value

  ```
  public String getProperty(String key) {
  Object oval = super.get(key);
  String sval = (oval instanceof String) ? (String)oval : null;
  return ((sval == null) && (defaults != null)) ? defaults.getProperty(key) : sval;
  }
  ```

#### 9.3.3.5 ConcurrentHashMap

> 在多线程环境下，使用HashMap进行put操作时存在丢失数据的情况，为了避免这种隐患，可以建议使用ConcurrentHashMap代替HashMap。

ConcurrentHashMap同样是由Node数组+链表+红黑树的数据结构来实现**，**并发控制则使用Synchronized和CAS来操作，整个看起来就像是优化过且线程安全的HashMap。

**put操作**过程是对当前的table进行无条件自循环直到put成功，可以分成以下六步流程来概述

1. 如果没有初始化就先调用initTable（）方法来进行初始化过程 
2. 如果没有hash冲突就直接CAS插入 
3. 如果还在进行扩容操作就先进行扩容 
4. 如果存在hash冲突，就加锁来保证线程安全，这里有两种情况，一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入， 
5. 最后一个如果该链表的数量大于阈值8，就要先转换成黑红树的结构，break再一次进入循环 
6. 如果添加成功就调用addCount（）方法统计size，并且检查是否需要扩容



**扩容情况**：所有数据都存在table中，table的容量会根据实际情况进行扩容，table[i]存放的数据类型**有以下3种（前2种hash值都为负数，所以大于0可以判断是普通链表）：** 

- TreeBin 用于**包装**红黑树结构的结点类型  - 
- ForwardingNode 扩容时存放的结点类型，并发扩容的实现关键之一 
- Node 普通结点类型，表示链表头结点

其实helpTransfer（）方法的目的就是**调用多个工作线程一起帮助进行扩容，这样的效率就会更高**，而不是只有检查到要扩容的那个线程进行扩容操作，其他线程就要等待扩容操作完成才能工作

**所有引起数组扩容的情况如下**：

- 链表转换为红黑树时(链表节点个数达到8个可能会转换为红黑树)。如果转换时map长度小于64则直接扩容一倍，不转化为红黑树。如果此时map长度大于64，则不会扩容，直接进行链表转红黑树的操作。
- 当数组中元素达到了sizeCtl的数量的时候，则会调用transfer方法来进行扩容

**并发扩容总结：**

1.  单线程新建nextTable，扩容为原table容量的两倍。
2.  每个线程想增/删元素时，如果访问的桶是ForwardingNode节点，则表明当前正处于扩容状态**，协助一起扩容完成后**再完成相应的数据更改操作。
3.  扩容时将原table的所有桶倒序分配，每个线程每次最小分16个桶进行处理，防止资源竞争导致的效率下降， 每个桶的迁移是单线程的，但桶范围处理分配可以多线程，在没有迁移完成所有桶之前每个线程需要重复获取迁移桶范围，直至所有桶迁移完成。
4.  一个旧桶内的数据迁移完成但迁移工作没有全部完成时，查询数据委托给ForwardingNode结点查询nextTable完成（这个后面看find()分析）。
5.  迁移过程中sizeCtl用于记录参与扩容线程的数量，全部迁移完成后sizeCtl更新为新table的扩容阈值。 

**size操作**

ConcurrentHashMap返回size的时候并不是直接返回的值，是因为addCount 方法用于 CAS 更新 baseCount，但很有可能在高并发的情况下，更新失败，那么这些节点虽然已经被添加到哈希表中了，但是数量却没有被统计。

还好，addCount 方法在更新 baseCount 失败的时候，会调用 fullAddCount 将这些失败的结点包装成一个 CounterCell 对象，保存在 CounterCell 数组中。那么整张表实际的 size 其实是 baseCount 加上 CounterCell 数组中元素的个数。

```java
public int size() {
    long n = sumCount();
    return ((n < 0L) ? 0 :
            (n > (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :
            (int)n);
}
final long sumCount() {
    CounterCell[] as = counterCells; CounterCell a; //变化的数量
    long sum = baseCount;
    if (as != null) {
        for (int i = 0; i < as.length; ++i) {
            if ((a = as[i]) != null)
                sum += a.value;  //数量累加
        }
    }
    return sum;
}
```

addCount() 方法用于维护 ConcurrentHashMap 的计数器，并根据计数器的值判断是否需要进行扩容操作。通过动态扩容，ConcurrentHashMap 可以保持高效的并发性能，同时提供线程安全的操作。

addCount() 方法的作用是：

1. 增加计数器：首先，它会将当前线程的计数器值（通过内部方法 fullAddCount() 实现）加上给定的 count 值。计数器用于记录 ConcurrentHashMap 中的元素个数。
2. 判断是否需要扩容：接下来，它会检查计数器的值是否超过了一个阈值（threshold）。这个阈值是根据 ConcurrentHashMap 的容量（capacity）和负载因子（loadFactor）计算得出的。如果计数器的值超过了阈值，说明当前 ConcurrentHashMap 的负载较高，需要进行扩容操作。
3. 执行扩容：如果需要扩容，addCount() 方法会调用 ConcurrentHashMap 的内部方法 tryPresize() 来进行扩容操作。tryPresize() 方法会根据计数器的值和当前容量，计算出新的容量，并尝试对 ConcurrentHashMap 进行扩容。

**addCount()与tryPresize()处扩容有何区别？**

addCount()是扩容是按容量x2来扩容的，tryPresize()会传入一个size参数，可能一次性扩容很多倍。后面采用一样的方式调用transfer()来进行真正的扩容处理。

**get(int key)方法**流程如下： 

1. 根据key调用spread计算hash值；并根据计算出来的hash值计算出该key在table出现的位置i.
2. 检查table是否为空；如果为空，返回null，否则进行3
3. 检查table[i]处桶位不为空；如果为空，则返回null，否则进行4
4. 先检查table[i]的头结点的key是否满足条件，是则返回头结点的value；否则分别根据树、链表查询。 

**remove 方法**的并发删除过程：

1. 首先遍历整张表的桶结点，如果表还未初始化或者无法根据参数的 hash 值定位到桶结点，那么将返回 null。
2. 如果定位到的桶结点类型是 ForwardingNode 结点，调用 helpTransfer 协助扩容。
3. 否则就给桶加锁，删除一个节点。
4. 最后会调用 addCount 方法 CAS 更新 baseCount 的值。

**总结与思考**

其实可以看出JDK1.8版本的ConcurrentHashMap的数据结构已经接近HashMap，相对而言，ConcurrentHashMap只是增加了同步的操作来控制并发，从JDK1.7版本的ReentrantLock+Segment+HashEntry，到JDK1.8版本中synchronized+CAS+HashEntry+红黑树,相对而言，总结如下思考

1. JDK1.8的实现降低锁的粒度，JDK1.7版本锁的粒度是基于Segment的，包含多个HashEntry，而JDK1.8锁的粒度就是HashEntry（首节点）
2. JDK1.8版本的数据结构变得更加简单，使得操作也更加清晰流畅，因为已经使用synchronized来进行同步，所以不需要分段锁的概念，也就不需要Segment这种数据结构了，由于粒度的降低，实现的复杂度也增加了
3. JDK1.8使用红黑树来优化链表，基于长度很长的链表的遍历是一个很漫长的过程，而红黑树的遍历效率是很快的，代替一定阈值的链表，这样形成一个最佳拍档
4. JDK1.8为什么使用内置锁synchronized来代替重入锁ReentrantLock，我觉得有以下几点
   1. 因为粒度降低了，在相对而言的低粒度加锁方式，synchronized并不比ReentrantLock差，在粗粒度加锁中ReentrantLock可能通过Condition来控制各个低粒度的边界，更加的灵活，而在低粒度中，Condition的优势就没有了
   2. JVM的开发团队从来都没有放弃synchronized，而且基于JVM的synchronized优化空间更大，使用内嵌的关键字比使用API更加自然
   3. 在大量的数据操作下，对于JVM的内存压力，基于API的ReentrantLock会开销更多的内存，虽然不是瓶颈，但是也是一个选择依据

## 9.4 无序集合接口 Set

> Set 是 Collection 接口的子类接口。
>
> Set 接口的特点是无序（添加和取出顺序不一致，其取出顺序由某个算法决定），没有索引
>
> 不允许重复元素。故而，最多包含一个 null

```
public interface Set<E> extends Collection<E>
```

### 9.4.1 HashSet

```
public class HashSet<E>
    extends AbstractSet<E>
    implements Set<E>, Cloneable, java.io.Serializable
```

> HashSet 实现了 Set 接口。底层实际上使用 HashMap 来存储数据。~~身在 Collection 心在 Map~~
>
> HashSet 是无序的。其实际顺序取决于计算得到的 hash 值

#### HashSet 的源码

1. HashSet 底层是 HashMap。

   ```
   private transient HashMap<E,Object> map;
   ```

2. 实例化也和 HashMap 相同

   ```
   public HashSet() {
       map = new HashMap<>();
   }
   
   public HashSet(int initialCapacity) {
       map = new HashMap<>(initialCapacity);
   }
   
   public HashSet(int initialCapacity, float loadFactor) {
       map = new HashMap<>(initialCapacity, loadFactor);
   }
   ```

3. 添加一个元素时调用 HashMap 的方法

   ```
   public boolean add(E e) {
       return map.put(e, PRESENT)==null;
   }
   ```

### 9.4.2 LinkedHashSet

> LinkedHashSet 是 HashSet 的子类
>
> LinkedHashSet 底层是一个 LinkedHashMap，维护了一个数组 + 双向链表。~~有其父必有其子~~
>
> LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置。同时，使用链表维护元素的次序。这使得元素看起来是以插入顺序保存的，并得以按照放入顺序取出

```
public class LinkedHashSet<E>
    extends HashSet<E>
    implements Set<E>, Cloneable, java.io.Serializable
```

#### LinkedHashSet 的源码：

1. 在类 HashSet 中，存在一个默认访问范围的构造器。该构造器不同于其他构造器，会让实例维护一个 LinkedHashMap

   ```
   HashSet(int initialCapacity, float loadFactor, boolean dummy) {
       map = new LinkedHashMap<>(initialCapacity, loadFactor);
   }
   ```

   LinkedHashSet 的构造器即调用了该父类构造器

   ```
   public LinkedHashSet(int initialCapacity, float loadFactor) {
       super(initialCapacity, loadFactor, true);
   }
   
   public LinkedHashSet(int initialCapacity) {
       super(initialCapacity, .75f, true);
   }
   
   public LinkedHashSet() {
       super(16, .75f, true);
   }
   ```

### 9.4.3 TreeSet

```
public class TreeSet<E> extends AbstractSet<E>
    implements NavigableSet<E>, Cloneable, java.io.Serializable
```

> TreeSet 实现了 Set 接口，其底层是一个 TreeMap。~~好家伙，原来 Set 全家都是卧底~~
>
> 调用无参构造器创建 TreeSet 时，默认是无序排列。也能在构造时传入一个比较器。有比较器的场合，比较器返回 0 时，不发生替换
>
> 不传入比较器的场合，使用的是传入对象自带的比较器。所以，这个场合，传入的 key 对象必须是 Comparable 接口的实现子类

## 9.5 集合的选择

在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类特性进行分析选择。

判断存储的类型（一组对象 [单列]，或一组键值对 [双列]）

- 一组对象：Collection 接口
  - 允许重复：List
    - 增删多：`LinkedList` （双向链表）
    - 改查多：ArrayList （`Object[]` 数组）
  - 不允许重复：Set
    - 无序：HashSet （数组 + 链表 + 红黑树，底层是 HashMap）
    - 排序：`TreeSet`
    - 顺序一致：LinkedHashSet （数组 + 双向链表，底层是 `LinkedHashMap`）
- 一组键值对：Map
  - 键无序：HashMap （数组 + 链表 + 红黑树 [ JDK 8 以后 ] ）
  - 键排序：`TreeMap`
  - 键顺序一致：`LinkedHashMap` （底层是 HashMap）
  - 读取文件：Properties

**jdk1.5新增了很多多线程情况下使用的集合类.位于java.util.concurrent.**

**如果你说,Vector是同步的,你要在多线程使用.那你应该使用java.util.concurrent.CopyOnWriteArrayList等而不是Vector.**

**如果你要使用Stack做类似的业务.那么非线程的你可以选择linkedList,多线程情况你可以选择java.util.concurrent.ConcurrentLinkedDeque 或者java.util.concurrent.ConcurrentLinkedQueue**

**多线程情况下,应尽量使用java.util.concurrent包下的类.*

## 9.6 工具类 Collections

> Collections 工具类是一个操作 Set、List、Map 等集合的工具类
>
> 其中提供了一系列静态方法，对集合元素进行 排序、查询和修改等操作

### 常用方法：

**排序：**

- `reverse(List)`：反转 List 中元素的排序
- `shuffle(List)`：对 `List `中元素进行随机排序
- `sort(List)`：根据元素的自然顺序对指定 List 集合元素升序排列
- `reverse(List, Comparator)`：根据指定 Comparator 对 List 排序
- `swap(List, int, int)`：将两处元素位置互换

**查找、替换：**

- `Object max(Collection)`：根据元素的自然排序，返回集合中最大的元素

- `Object max(Collection, Comparator)`：根据比较器，返回最大元素

- `Object min(Collection)`：根据元素的自然排序，返回最小元素

- `Object min(Collection, Comparator)`：根据比较器，返回最小元素

- `int frequency(Collection, Object)`：返回集合中指定元素的出现次数

- `void copy(List dest, List src)`：将 src 的内容复制到 dest 中

  这个场合，要保证 dest 的大小不小于 src。所以，可能需要先给 dest 赋值

- `boolean replaceAll(List list, Object oldVal, Object newVal)`：用 newVal 替换所有 oldVal 值

## 9.7 不可变集合

### 9.7.1 什么是不可变集合

是一个长度不可变，内容也无法修改的集合

### 9.7.2 使用场景

如果某个数据不能被修改，把它防御性地拷贝到不可变集合中是个很好的实践。

当集合对象被不可信的库调用时，不可变形式是安全的。

简单理解：不想让别人修改集合中的内容

### 9.7.3 不可变集合

所有的不可变集合一旦创建完毕之后，是无法进行修改的（修改会报错），只能进行查询操作。

#### 9.7.3.1不可变的list集合

创建不可变的List集合：`List<String> list = List.of("张三", "李四", "王五", "赵六");`

NOTE：对于list而言，其可以放置任意多的内容。

#### 9.7.3.2不可变的set集合

创建不可变的set集合：`Set<String> set = Set.of("张三", "李四", "王五", "赵六");`

NOTE：对于list而言，其可以放置任意多的内容，但内容之间**不允许重复**。

#### 9.7.3.3不可变的map集合

创建不可变的map集合：`Map<String, String> map = Map.of("张三", "南京", "王五", "上海", "赵六", "广州", );`

NOTE：对于Map里面的of方法而言，其至多放置10个键值对，且键之间**不允许重复**。如果想要存放超过10个的键值对，可以使用`Map<Object, Object> map = Map.ofEntries(hashMap.entrySet().toArray(new Map.Entry[hashMap.size()]));`将hashMap中的键值对转换为不可变集合map，如果是在JKD10及以上的版本，可以使用`Map<Object, Object> map = Map.copyOf(hm);`。达到相同的目的。

# 10 枚举和注解

## 10.1 枚举

把具体的对象一一列举出来的类，就称为 枚举类（enumeration）

实现方法：

1. 自定义枚举
2. `enum` 关键字枚举

### 10.1.1 自定义枚举

1. 构造器私有化
2. 去掉 set 方法（可保留 get），防止属性被修改。因为枚举对象值通常为只读
3. 在类内部直接创建固定对象。使用 `final` + `static` 共同修饰，对象名通常全部大写。
4. 枚举对象按照需要可以有多个属性

### 10.1.2 `enum` 关键字

```
enum Example {
    RED("小红", 10), BLUE("小蓝", 11), YELLOW; //这句话要放在前面，第三个是无参
    private String name;
    private int age;

    private Example(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

1. 用关键字 `enum` 替代 `class`
2. 用 `常量名.(形参列表);` 代替创建对象（放在前面）。多个对象的场合，用 `,` 间隔。
3. 如果使用 `enum` 枚举，要求将常量对象写在前面

#### #10.1.2.1 使用细节

1. 当我们用 `enum` 关键字开发一个枚举类时，默认会继承 java.lang.Enum 类，而且是一个 `final` 类。

   这样，我们就能使用 Enum 中的相关方法。

   **也正因为如此，`enum` 类不能继承其他类，亦不能被其它类继承**

   不过，`enum` 类和其他类一样，可以实现接口。

2. 传统的 `public ststic final RED("小红", 10);` 简化为 `RED("小红", 10);`

3. 如果使用无参构造器创建枚举对象，则 实参列表 和 `( )` 都能省略

#### #10.1.2.2 `Enum` 类中的常用方法

- `valueOf`：将字符串转换成枚举对象。要求字符串必须是已有的常量名，否则报异常。
- `values`：返回一个数组 `Example[]`，其中包含定义的所有枚举对象
- `getDeclaringClass`：得到枚举常量所属的 `class`
- `name`：得到当前枚举常量的名称。建议优先用 `toString`
- `ordinal`：输出该枚举对象的次序/编号（从 0 开始编号。如上例 `BLUE.ordinal = 1`）
- `compareTo`：比较两个枚举常量的编号（调用常量编号 减去 传入常量编号）
- `clone`：枚举类不能 `clone`，所以，这是一个只会抛出异常的方法

## 10.2 注解

注解（Annotation）也被称为元数据（Metadata）。用于修饰 包、类、方法、属性、构造器、局部变量 等数据信息

和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息

在 JavaSE 中，注解的使用目的比较简单，例如 标记过时的功能，忽略警告 等。在 JavaEE 中注解占据了更重要的角色，例如用于配置应用程序的任何切面，代替 JavaEE 旧版中所遗留的繁冗代码和 XML 配置等。

1. 使用 `@Annotation` 时要在前面增加 `@` 符号，并把该注解当成一个修饰符使用。用于修饰它支持的程序元素。

2. 三个基本的`@Annotation`：
   - `@Override`：限定某个方法，是 重写 父类方法。该注解只能用于方法。如果你写了该注解，编译器会替你校验，看看是不是真的 重写 了父类方法。
   - `@Deprecated`：用于表示某个程序元素（类、方法等）已经过时
   - `@SuppressWarnings()`：抑制编辑器警告

3. 如果发现 `public @interface XXX{}` 这种东西，说明是定义了一个注解类 `XXX`。这里的 `@interface` 不代表接口（`interface`）。

### 10.2.1 `@Override`

1. `@Override` 表示指定重写父类的方法（从编译器层面验证），如果父类没有该方法，就报错
2. 不写该注解，重写依然构成重写
3. `@Override` 只能修饰方法，不能修饰其他 类、包、属性等
4. 查看 `@Override` 注解源码为 `@Target(ElementType.METHOD)` 说明只能修饰方法
5. `@Target` 是修饰注解的注解，称为 元注解

### 10.2.2 `@Deprecated`

1. `@Deprecated` 表示指定的某个程序元素（类、方法等）已过时

2. 不推荐使用，但仍能使用

3. 可以修饰方法、类、字段、包、参数

   `@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})`

4. `@Deprecated` 可以做到新旧版本的兼容和过度

### 10.2.3 `@SuppressWarnings()`

1. 当我们不想看到警告信息时，用 `@SuppressWarnings()`

   语法：`@SuppressWarnings({"..."})`

   在后面 `({"unused", "unchecked"})` 这样写入你希望抑制的信息，以下是所有可以输入的关键字

   | **关键字**               | **用途**                                           |
   | :----------------------- | :------------------------------------------------- |
   | all                      | 抑制所有警告                                       |
   | boxing                   | 抑制与装箱/解装箱操作相关的警告                    |
   | cast                     | 抑制与强制转换操作相关的警告                       |
   | dep-ann                  | 抑制与已弃用注释相关的警告                         |
   | deprecation              | 抑制与弃用有关的警告                               |
   | fallthrough              | 抑制与 switch 语句中丢失断点相关的警告             |
   | finally                  | 抑制不返回的 finally 块的相关警告                  |
   | hiding                   | 抑制与隐藏变量的局部变量相关的警告                 |
   | incomplete-switch        | 抑制与 switch 语句中缺少条目相关的警告（enum）     |
   | nls                      | 抑制与 非nls 字符串字面值相关的警告                |
   | null                     | 抑制相对于null分析的警告                           |
   | rawtypes                 | 在类参数上使用泛型时，抑制与非特定类型相关的警告   |
   | restriction              | 抑制与不推荐或禁止引用有关的警告                   |
   | serial                   | 抑制与可序列化类缺少serialVersionUID字段相关的警告 |
   | static-access            | 抑制与不正确的静态访问有关的警告                   |
   | synthetic-access         | 抑制与未优化的内部类访问相关的警告                 |
   | unchecked                | 抑制与未检查的操作相关的警告                       |
   | unqualified-field-access | 抑制与字段访问不合格相关的警告                     |
   | unused                   | 抑制与未使用代码相关的警告                         |

2. `@SuppressWarnings` 的范围与你放置的位置相关。

### 10.2.4 JDK 的元注解（了解即可）

> JDK 的 元注解 是用于修饰其他注解的注解

1. `@Rentention`：指定注解的作用范围，有三种范围 `SOURCE` `CLASS` `RUNTIME`

   `@Rentention` 的三种值：

   - `RententionPolicy.SOURCE`：编译器使用后，直接丢弃这种策略的注释
   - `RententionPolicy.CLASS`：编译器把注解记录在 class 文件中。当运行 Java 程序时， JVM 不会保留注释。这是默认值
   - `RententionPolicy.RUNTIME`：编译器把注解记录在 class 文件中。当运行 Java 程序时，JVM 会保留注解。程序可以通过反射获取该注解

2. `@Target`：指定注解的使用范围

   `@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})`

3. `@Documented`：指定该注解会不会在 Javadoc 体现

4. `@Inherited`：子类会继承父类注解

# 11 异常（Exception）

> 在 Java 语言中，将程序执行中发生的不正常情况称为 “异常”（开发过程中的语法错误和逻辑错误不是异常）
>
> 这些 异常事件 可分为两类：
>
> - Error（错误）：Java 虚拟机无法解决的严重问题。
>
>   如：JVM 系统内部错误，资源耗尽等严重情况。Error 是严重错误，程序会崩溃。
>
> - Exception：其他因编程错误或偶然的外部因素导致的一般性问题，可以使用针对性的代码进行处理。
>
>   如：空指针访问，试图读取不存在的文件，网络中断等等。
>
>   Exception 又分为两大类：
>
>   - 运行时异常（程序运行时，发生的异常）
>   - 编译时异常（编程时，编译器检查出的异常）

## 11.1 异常体系图

> 编译异常（受检异常） 和 运行异常（非受检异常）
>
> Java 源程序 ——(javac.exe)——> 字节码文件 ——(java.exe)——> 在内存中加载，运行类
>
> 编译异常↑ 运行异常↑

![img](D:/College_life/Journal/images/异常体系图.jpg)

 *（异常体系图_11.1）*

异常分为两大类：运行时异常 和 编译时异常

- 运行时异常，编译器不要求强制处置的异常。一般是指编程的逻辑错误，是程序员应该避免其出现的异常。

  java.lang.RuntimeException 类及它的子类都是运行时异常

  对于运行时异常，可以不做处理。因为这类异常很普遍，若全处理会对程序的可读性和运行效率产生影响

- 编译时异常，是编译器要求必须处置的异常

### 11.1.1 常见的运行时异常

> 常见的运行时异常（RuntimeException）包括
>
> - NullPointerException：空指针异常
> - ArithmeticException：数学运算异常
> - ArrayIndexOutOfBoundsException：数组下标越界异常
> - ClassCastException：类型转换异常
> - NumberFormatException：数学格式异常

**空指针异常**

- 当应用程序试图在需要对象的地方使用 null 时，抛出该异常。

> ```
> String str = null;
> int n = str.length;					//这里，出现了 空指针异常
> ```

**数学运算异常**

- 当出现异常的运算条件时，抛出该异常。

> ```
> double n = 100 / 0;					//这里，出现了 数学运算异常
> ```

**数组下标越界异常**

- 用非法索引（为负或超出范围）访问数组时，抛出该异常。

> ```
> int[] nums = {0, 0, 0, 0};
> nums[-50] = 100;					//这里，出现了 数组下标越界异常
> ```

**类型转换异常**

- 当试图把对象强制转换为不是实例的子类时，抛出该异常。

> ```
> public class Example {
> public static void main(String[] args){
>   A a1 = new A1();
>   A2 a1 = (A2)a1;				//这里，出现了 类型转换异常
> }
> }
> class A {}
> class A1 extends A {}
> class A2 extends A {}
> ```

**数字格式不正确异常**

- 当应用程序试图将字符串转成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。

> ```
> String str = "ABC";
> int num = Integer.parseInt(str);	//这里，出现了 数字格式不正确异常
> ```

### 11.1.2 常见的编译异常

> 常见的编译异常：
>
> - SQLException：操作数据库时，查询表可能发生异常
> - IOException：操作文件时，发生的异常
> - FileNotFoundException：操作一个不存在的文件时，发生的异常
> - ClassNotFoundException：加载类，而该类不存在时，发生的异常
> - EOFException：操作文件，到文档末尾，发生的异常
> - IllegalArguementException：参数异常

因为还没有学习 SQL、文件编程 等，这里不举例子

## 11.2 异常处理

> 异常发生时，对异常的处理方式。如果没有显式异常处理，默认处理方式是 `throws`
>
> - `try - chatch - finally`：程序员在代码中捕获发生的异常，自行处理
> - `throws`：将发生的异常抛出，交给调用者（方法）来处理。最顶级的处理者就是 JVM

### 11.2.1 `try - catch` 异常处理

> Java 提供 try 和 catch 块 来处理异常。try 块用于包含可能出错的代码，catch 块用于处理 try 块中的异常。可以根据需要在程序中有多个 `try - catch` 块。

> 基本语法
>
> ```
> try {
> 	//可疑代码
> 	//将异常生成对应的异常对象，传递给 catch 块
> } catch(Exception e) {
> 	//如果发生异常，执行这些代码
> } finally {
> //无论是否异常，都执行这些代码
> //finally 块可以不写
> }
> ```

> 快捷键：选中代码后按 ctrl + alt + T

#### #11.2.1.1 使用细节

1. 如果异常发生了，则异常发生后面的代码块都不执行，直接进入 catch 块

2. 如果异常未发生，则顺序执行 try 代码块，catch 块不执行

3. 如果希望不管是否异常，都执行一些代码，则使用 finally

4. 可以有多个 catch 捕获不同的异常。要求 子类异常在前，父类异常在后。

   > ```
   > try {
   > 	...
   > } catch (NullPointerException e) {
   > 	...
   > } catch (ArithmeticException e) {
   > 	...
   > } catch (ArrayIndexOutOfBoundsException e) {
   > 	...
   > } catch (Exception e){
   > 	...
   > }
   > ```

5. 可以进行 try - finally 配合使用（不写 catch）。这种用法相当于没有捕获异常，此时程序如果出错会直接退出。

   应用场景，就是写一段代码，不管是否发生异常，都必须执行某个业务逻辑。

6. 如果没有出现异常，执行 try 中所有语句，不执行 catch 语句，最后执行 finally 语句

7. 如果出现异常，则 try 块异常发生后，剩余语句不执行。之后执行 catch 语句，最后，执行 finally 语句。

### 11.2.2 `throws` 异常处理

> 如果一个方法可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显式地声明抛出异常，表明该方法将不对这些异常进行处理，而由调用者负责处理
>
> 在方法中声明 `throws` 语句可以声明抛出异常的列表。`throws` 后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。

> 语法
>
> ```
> public void metord() throws FileNontFoundException ,NullPointerException {
> 	...
> }
> ```

#### #11.2.2.1 使用细节

1. 对于 **编译异常**，程序中必须处理。
2. 对于 **运行异常**，程序中诺没有处理，默认处理是 `throws`
3. 子类 重写 父类方法时，子类方法抛出的异常类型必须和父类一致，或者是父类抛出异常类型的子类型。
4. 如果有 `try - catch` 就不必 `throws` 了

## 11.3 自定义异常

> 当程序中出现了某些 “错误”，但该信息并未在 `Throwable` 子类中描述处理，这时候可以自己设计异常类，用于描述该错误信息

1. 定义类：自定义异常类名，继承 RuntimeException 或 Exception
2. 如果继承 Exception，属于 编译异常。
3. 如果继承 RuntimeException，属于 运行异常。（一般来说，选这个。这样利用了默认处理机制，更方便）

> ```
> class Metords {
> public void method() {
>  int n = 10;
>  if(n > 100){
>      throw new CustomException("不能大于100");
>  }
> }
> }
> 
> class CustomException extends RuntimeException {
> public CustomException(String message) {
>   super(message);
> }
> }
> ```

### 11.3.1 `throw` 和 `throws`

|          | 意义                   | 位置       | 后面跟的东西 |
| -------- | ---------------------- | ---------- | ------------ |
| `throws` | 异常处理的一种方式     | 方法声明时 | 异常类型     |
| `throw`  | 手动生成异常对象关键字 | 方法体中   | 异常对象     |

### 11.3.2 编程小技巧

编写异常时，先确定正确的情况，然后取反。这样写，你的思路就不乱。
