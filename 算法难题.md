# 难题

## [406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)

假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi` ，前面 **正好** 有 `ki` 个身高大于或等于 `hi` 的人。

请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0]` 是排在队列前面的人）。

**示例 1：**

```
输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
```

**示例 2：**

```
输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
```

这种题目其实还是比较困难的，**一般这种数对，还涉及排序的，根据第一个元素正向排序，根据第二个元素反向排序，或者根据第一个元素反向排序，根据第二个元素正向排序，往往能够简化解题过程。**

在本题目中，我首先对数对进行排序，按照数对的元素 1 降序排序，按照数对的元素 2 升序排序。原因是，按照元素 1 进行降序排序，对于每个元素，在其之前的元素的个数，就是大于等于他的元素的数量，而按照第二个元素正向排序，我们希望 k 大的尽量在后面，保证正确性。

举个例子，在身高一样，k不一样的时候，譬如[5,2]和[5,3], 对于最后排完的数组，[5,2]必然在[5,3]的前面。所以如果遍历的时候[5,3]在前面，等它先插入完，这个时候它前面会有3个大于等于它的数组对，遍历到[5,2]的时候，它必然又会插入[5,3]前面（因为它会插入链表索引为2的地方），这个时候[5,3]前面就会有4个大于等于它的数组对了，这样就会出错。

```python
class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        people.sort(key = lambda x: (-x[0], x[1]))
        result = []
        for p in people:
            result.insert(p[1], p)
        return result
```

## [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

**示例 1：**

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。
```

**示例 2：**

```
输入：s = "a", t = "a"
输出："a"
解释：整个字符串 s 是最小覆盖子串。
```

**示例 3:**

```
输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
```

**滑动窗口的思想：**
	用 $i$,$j$ 表示滑动窗口的左边界和右边界，通过改变 $i$,$j$ 来扩展和收缩滑动窗口，可以想象成一个窗口在字符串上游走，当这个窗口包含的元素满足条件，即包含字符串T的所有元素，记录下这个滑动窗口的长度$j-i+1$，这些长度中的最小值就是要求的结果。

1. 不断增加 $j$ 使滑动窗口增大，直到窗口包含了T的所有元素

2. 不断增加 $i$ 使滑动窗口缩小，因为是要求最小字串，所以将不必要的元素排除在外，使长度减小，直到碰到一个必须包含的元素，这个时候不能再扔了，再扔就不满足条件了，记录此时滑动窗口的长度，并保存最小值

3. 让$i$再增加一个位置，这个时候滑动窗口肯定不满足条件了，那么继续从步骤一开始执行，寻找新的满足条件的滑动窗口，如此反复，直到 $j$ 超出了字符串S范围。

```java
class Solution {
    public String minWindow(String s, String t) {
        //首先创建的是need数组表示每个字符在t中需要的数量，用ASCII码来保存
        int[] need = new int[128];
        for (char idx : t.toCharArray()){
            need[idx]++;
        }
        char[] chars = s.toCharArray(); // 转成char[]时使用索引取值效率更高
        /*
        count: 当次遍历中还需要几个字符才能够满足包含t中所有字符的条件，最大也就是t的长度
        start: 如果有效更新滑动窗口，记录这个窗口的起始位置，方便后续找子串用
         */
        int windowStart = 0, windowEnd = 0, windowSize = chars.length + 1, count = t.length(), start = 0;
        while (windowEnd < chars.length) {
            char idx = chars[windowEnd];
            //表示t中包含当前遍历到的这个c字符，更新目前所需要的count数大小，应该减少一个
            if (need[idx] > 0) {
                count--;
            }
            need[idx]--;		//无论这个字符是否包含在t中，need[]数组中对应那个字符的计数都减少1
            if (count == 0) {	//count==0说明当前的窗口已经满足了包含t所需所有字符的条件
                // 只有t中包含的字符才会在need[chars[windowStart]]++前等于0
                while (windowStart < windowEnd && need[chars[windowStart]] < 0) {
                    // 窗口向右滑动，windowStart增加，减去的值加回来
                    need[chars[windowStart++]]++;
                }
                //如果当前的这个窗口值比之前维护的窗口值更小，需要进行更新
                if (windowEnd - windowStart + 1 < windowSize) { // 更新窗口值
                    windowSize = windowEnd - windowStart + 1;
                    start = windowStart;
                }
                
                need[chars[windowStart++]]++;   // 窗口向右滑动
                count++;                        // 窗口滑动后，窗口内没有包含所有的字符了
            }
            windowEnd++;    //右移边界，开始下一次循环
        }
        return windowSize > chars.length ? "" : s.substring(start, start + windowSize);
    }
}
```



## [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

**回文串** 是正着读和反着读都一样的字符串。

**示例 1：**

```
输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
```

**示例 2：**

```
输入：s = "a"
输出：[["a"]]
```

此题并不算困难，但要解此题也需要掌握很多技能点，比如判断字符串为回文串，回溯，动态规划等。当然最简单也最容易想到的就是使用回溯来解决了，其实现的代码如下：

```java
class Solution {
    public List<List<String>> partition(String s) {
        List<List<String>> lists = new ArrayList<>();
        dfs(0, s.toCharArray(), lists, new ArrayList<>());
        return lists;
    }

    private void dfs(int start, char[] chars, List<List<String>> lists, List<String> list) {
        if (start == chars.length) {
            lists.add(new ArrayList<>(list));
            return;
        }
        for (int i = start; i < chars.length; i++) {
            if (isPalindrome(chars, start, i)) {
                list.add(new String(chars, start, i - start + 1));
                dfs(i + 1, chars, lists, list);
                list.remove(list.size() - 1);
            }
        }
    }

    private boolean isPalindrome(char[] chars, int start, int end) {
        while (start < end){
            if (chars[start++] != chars[end--]) return false;
        }
        return true;
    }
}
```

使用回溯其性能并不高，即使已经很简化了，但也需要8ms，只击败了61%的用户，同时看代码，在回溯时会经常判断是否为回文串，而这不可避免的出现了很多重复判断，因此我们可以使用动态规划先对原始字符串进行预处理，统计出其回文串，这样在判断的时候就能避免很多重复判断。实现的代码如下：

```java
class Solution {
    public List<List<String>> partition(String s) {
        List<List<String>> lists = new ArrayList<>();
        char[] chars = s.toCharArray();
        boolean[][] dp = new boolean[chars.length][chars.length];
        for (int i = 0; i < chars.length - 1; i++) {
            dp[i][i] = true;							// 初始化
            dp[i][i + 1] = chars[i] == chars[i + 1];	// 初始化（两个相同的字母）
        }
        dp[chars.length - 1][chars.length - 1] = true;
        for (int i = 0; i < chars.length - 2; i++) {
            dfsDP(dp, chars, i, i + 2);					// 判断右上斜线，即头+1，尾-1，判断是否相等
            if (dp[i + 1][i + 2])			
                dfsDP(dp, chars, i, i + 3);				// 同上面，但需要判断是否是（两个相同的字母）
        }
        dfs(0, chars, dp, lists, new ArrayList<>());
        return lists;
    }

    private void dfs(int start, char[] chars, boolean[][] dp, List<List<String>> lists, List<String> list) {
        if (start == chars.length) {
            lists.add(new ArrayList<>(list));
            return;
        }
        for (int i = start; i < chars.length; i++) {
            if (dp[start][i]) {
                list.add(new String(chars, start, i - start + 1));
                dfs(i + 1, chars, dp, lists, list);
                list.remove(list.size() - 1);
            }
        }
    }
    private void dfsDP(boolean[][] dp, char[] chars, int i, int j){
        if (i == -1 || j == chars.length || chars[i] != chars[j]) return;
        dp[i][j] = true;
        dfsDP(dp, chars, i - 1, j + 1);
    }
}
```

使用使用动态规划实现的代码其运行时间也需要8ms，~~但至少我们节省了很多判断嘛，面试官就会认为你牛逼。~~关于判断回文串，可以试试[5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)，除了本文所采用的动态规划外，还可以采用中心开花的思想，即从一个字符左右开始同时判断是否相等，这样的判断速度是更快的。在下面也把中心开花的算法贴上吧：

```java
class Solution {
    public List<List<String>> partition(String s) {
        List<List<String>> lists = new ArrayList<>();
        char[] chars = s.toCharArray();
        boolean[][] dp = new boolean[chars.length][chars.length];
        for (int i = 0; i < chars.length - 1; i++) {
            findPalindrome(i, i, chars, dp);
            findPalindrome(i, i + 1, chars, dp);
        }
        dp[chars.length - 1][chars.length - 1] = true;
        dfs(0, s, dp, lists, new ArrayList<>());
        return lists;
    }

    private void dfs(int start, String s, boolean[][] dp, List<List<String>> lists, List<String> list) {
        if (start == s.length()) {
            lists.add(new ArrayList<>(list));
            return;
        }
        for (int i = start; i < s.length(); i++) {
            if (dp[start][i]) {
                list.add(s.substring(start, i + 1));
                dfs(i + 1, s, dp, lists, list);
                list.remove(list.size() - 1);
            }
        }
    }

    private void findPalindrome(int left, int right, char[] chars, boolean[][] dp){
        while (left >= 0 && right < chars.length && chars[left] == chars[right]){
            dp[left--][right++] = true;
        }
    }
}
```

从代码来看还是很简洁的，但运行时间都一致，均为8ms

使用python实现的代码如下：

```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        def add_palindrome(left, right) -> bool:
            while left > -1 and right < length and s[left] == s[right]:
                palindromes[left].append(right)
                left -= 1
                right += 1

        def dfs(left, path):
            if left == length:
                result.append(path[:])
                return
            for right in palindromes[left]:
                path.append(s[left:right + 1])
                dfs(right + 1, path)
                path.pop()
        
        length = len(s)
        palindromes = [[] for _ in range(length)]
        result = []

        for mid in range(length):
            add_palindrome(mid, mid)
            add_palindrome(mid, mid + 1)
        dfs(0, [])
        return result
```

## [132. 分割回文串 II](https://leetcode.cn/problems/palindrome-partitioning-ii/)

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是回文串。

返回符合要求的 **最少分割次数** 。

**示例 1：**

```
输入：s = "aab"
输出：1
解释：只需一次分割就可将 s 分割成 ["aa","b"] 这样两个回文子串。
```

**示例 2：**

```
输入：s = "a"
输出：0
```

**示例 3：**

```
输入：s = "ab"
输出：1
```

此题是上一题的进阶版，我们需要求出分割后数目最小的那个方法，因此我们需要在上一题的基础上再增加一个dp数组，用来求最小的值。我们可以令dp[i]表示从$0,i$开始最小的分割次数。那么当$j+1,i$是回文串的时候递推公式就是$dp[i]=min(dp[i],dp[j]+1)$。据此我们可以写出以下代码：

```python
class Solution:
    def minCut(self, s: str) -> int:
        def add_palindrome(left, right, is_palindrome,length) -> bool:
            while left > -1 and right < length and s[left] == s[right]:
                is_palindrome[left][right] = True
                left -= 1
                right += 1
        
        length = len(s)
        is_palindrome = [[False] * len(s) for _ in range(len(s))]
        for mid in range(length):
            add_palindrome(mid, mid, is_palindrome,length)
            add_palindrome(mid, mid + 1, is_palindrome,length)

        dp = [2000] * len(s)
        dp[0] = 0
        for i in range(1, len(s)):
            if is_palindrome[0][i]:
                dp[i] = 0
                continue
            for j in range(i):
                if is_palindrome[j + 1][i] and dp[j] + 1 < dp[i]:
                    dp[i] = dp[j] + 1
        return dp[-1]
```

在记录是否是回文串的时候，我们直接采用了一个二维数组去存储，这样更加方便去取值，该数组表示的含义是$is-palindrome[i][j]$表示从$i-j$的字符串是回文串，同时使用这种存储方式我们还可以使用动态规划的思想来求解回文串。

```python
class Solution:
    def minCut(self, s: str) -> int:
        is_palindrome = [[False] * len(s) for _ in range(len(s))]
        for i in range(len(s) - 1, -1, -1):
            is_palindrome[i][i] = True
            for j in range(i + 1, len(s)):
                if s[i] == s[j] and (j - i == 1 or is_palindrome[i + 1][j - 1]):
                    is_palindrome[i][j] = True
                    
        dp = [2000] * len(s)
        dp[0] = 0            
        for i in range(1, len(s)):
            if is_palindrome[0][i]:
                dp[i] = 0
                continue
            for j in range(i):
                if is_palindrome[j + 1][i] and dp[j] + 1 < dp[i]:
                    dp[i] = dp[j] + 1
        return dp[-1]
```



## [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg)

```
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示。
```

**示例 2：**

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：3
```

使用两次递归的解法比较简单，此处不再举例。

考虑如何利用已经计算过的信息。类似在数组中找连续子数组和为$targetSum$，即力扣上的 **[560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)**。本题也在父子链路上体现出从某点到某点的连续性。这启发我们使用前缀和方法处理。使用dfs遍历一次整棵树，实时地计算从root到当前结点的前缀和。在同一条路径上，更短的前缀和已经被计算出来了，为了对前缀和求差以查找是否存在 $ pre_i $ -$ pre_j $= $targetSum$（$pre_i$为当前结点前缀和，$pre_j$为当前路径上i节点之前的结点j的前缀和)，我们需要保存之前结点的前缀和。map是一个不假思索的选择，key保存前缀和，value保存对应此前缀和的数量。需要注意的是，前缀和求差的对象是同一条路径上的结点，因此在dfs遍历树的过程中，当到达叶子结点，之后向上返回时，路径退缩，使得当前结点将退出后续路径。对前缀和求差的前提是要保证map中所保存的前缀和均为同一路径上的结点的前缀和，因此需要删除返回前的节点所代表的前缀和。

- 时间复杂度：$O(n)$，n为结点总数，只需一次遍历。
- 空间复杂度：$O(n)$，map空间。

```java
class Solution {
    int targetSum, count = 0;
    Map<Integer, Integer> map;
    public int pathSum(TreeNode root, int targetSum) {
        if(root == null) return 0;
        this.targetSum = targetSum;
        this.map = new HashMap<>();
        map.put(0, 1); // 表示前缀和为0的节点为空，有一个空。否则若pre_i = targetSum，将错过从root到i这条路径。
        dfs(root, 0);
        return count;
    }
    private void dfs(TreeNode node, int preSum){
        if(node == null) return;
        preSum += node.val;
        count += map.getOrDefault(preSum - targetSum, 0); // #1 累计满足要求的前缀和数量
        map.put(preSum, map.getOrDefault(preSum, 0) + 1); // #2 先累计再put（先#1，再#2）
        dfs(node.left, preSum);
        dfs(node.right, preSum);
        map.put(preSum, map.get(preSum) - 1); // 路径退缩，去掉不再在路径上的当前结点的前缀和。其实就是回溯
    }
}
```



## [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

二叉树中的 **路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" alt="img" style="zoom:60%;" />

```
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
```

**示例 2：**

<img src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg" alt="img" style="zoom:60%;" />

```
输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
```

此题乍一看与上面的[二叉树中的最大路径和](# 124. 二叉树中的最大路径和)有点像，毕竟都是求和，但由于此题是求最大和，不知你还是否记得在学动态规划算法的时候有一个[Kadane's 算法](./数据结构.md#6 Kadane's 算法)，该算法是用来求解最大子数组和的，而这与本题很相似。只需要搞清楚递推关系即可求得最大值。

在本题所给的两个例题中已经告诉读者，最大路径和可能是该节点与左右孩子之和，同时也有可能是该节点与左/右孩子的最大值之和，基于此便可以轻易的写出以下代码：

```java
class Solution {
    int max = -1000;
    public int maxPathSum(TreeNode root) {
        dfs(root);
        return max;
    }

    private int dfs(TreeNode node) {
        if (node == null) return 0;
        int left = dfs(node.left);
        int right = dfs(node.right);
        this.max = Math.max(this.max, left + right + node.val);		// 该节点与左右孩子之和
        int max = Math.max(left, right) + node.val;				
        this.max = Math.max(this.max, max);							// 该节点与左/右孩子的最大值之和
        return Math.max(max, 0);	// 如果该节点为正，那可能继续给父节点提供帮助，否则返回0，不拖累父节点
    }
}
```



## [212. 单词搜索 II](https://leetcode.cn/problems/word-search-ii/)

给定一个 `m x n` 二维字符网格 `board` 和一个单词（字符串）列表 `words`， *返回所有二维网格上的单词* 。

单词必须按照字母顺序，通过 **相邻的单元格** 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/07/search1.jpg)

```
输入：board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
输出：["eat","oath"]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/11/07/search2.jpg)

```
输入：board = [["a","b"],["c","d"]], words = ["abcb"]
输出：[]
```

此题考查内容较多，但很重要，虽然是困难题，但也要掌握。

考察内容有：

- 你知不知道字典树 - 考察知识的广度
- 你能不能手撸字典树 - 考察算法的扎实度
- 二维数组当成图的遍历 - 考察多维数组，dfs
- 字符替换原有值实现标记访问过的节点 - 考察标记还原法的应用
- 逆向思维，看棋盘上的点在不在前缀里（不是判断单词在不在棋盘上哦）- 就看你还灵不灵？！！
- 大厂都有朋友圈推荐的功能 - 这就是字典树嘛（朋友的朋友，人连人，人人都是前缀），业务需要，例如[1268. 搜索推荐系统](https://leetcode.cn/problems/search-suggestions-system/)

实现的代码如下：

```java
class Solution {
    Trie trie = new Trie();

    public List<String> findWords(char[][] board, String[] words) {
        for (int i = 0; i < words.length; i++) {
            trie.insert(words[i], i);
        }
        List<String> list = new ArrayList<>();
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if (trie.node[board[i][j] - 'a'] != null) {		// 看棋盘上的点在不在前缀里
                    dfs(i, j, board, trie, list, words);
                }
            }
        }
        return list;
    }

    private void dfs(int i, int j, char[][] board, Trie trie, List<String> list, String[] words) {
        if (i == -1 || i == board.length || j == -1 || j == board[0].length || board[i][j] < 'a') return;
        trie = trie.node[board[i][j] - 'a'];
        if (trie == null) return;						// 看棋盘上的点在不在前缀里
        if (trie.wordIndex != -1) {
            list.add(words[trie.wordIndex]);
            this.trie.remove(words[trie.wordIndex], trie);	// 已经查找到单词就把单词从字典树中删除，避免重复查找
        }
        if (trie.wordNum == 0) return;
        board[i][j] -= 'a';
        dfs(i + 1, j, board, trie, list, words);		// 二维数组当成图的遍历
        dfs(i - 1, j, board, trie, list, words);
        dfs(i, j + 1, board, trie, list, words);
        dfs(i, j - 1, board, trie, list, words);
        board[i][j] += 'a';								// 标记还原法（回溯）
    }

    static class Trie {
        private final Trie[] node;
        private int wordIndex = -1;
        private int wordNum;

        public Trie() {
            node = new Trie[26];
        }

        public void insert(String word, int index) {
            Trie trie = this;
            int idx;
            for (char c : word.toCharArray()) {
                idx = c - 'a';
                if (trie.node[idx] == null) {
                    trie.node[idx] = new Trie();
                }
                trie.wordNum++;
                trie = trie.node[idx];
            }
            trie.wordIndex = index;
        }

        public void remove(String word, Trie trie) {
            trie.wordIndex = -1;
            trie = this;
            int idx;
            for (char c : word.toCharArray()) {
                idx = c - 'a';
                if (--trie.wordNum == 0) {		// 减少该支路上的单词数
                    trie.node[idx] = null;		// 释放空间
                    break;
                }
                trie = trie.node[idx];
            }
        }
    }
}
```

此代码可以达到17ms，击败了99%的人，还是很不错的。

## [332. 重新安排行程](https://leetcode.cn/problems/reconstruct-itinerary/)

给你一份航线列表 `tickets` ，其中 `tickets[i] = [fromi, toi]` 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。

所有这些机票都属于一个从 `JFK`（肯尼迪国际机场）出发的先生，所以该行程必须从 `JFK` 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。

- 例如，行程 `["JFK", "LGA"]` 与 `["JFK", "LGB"]` 相比就更小，排序更靠前。

假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg)

```
输入：tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]
输出：["JFK","MUC","LHR","SFO","SJC"]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/03/14/itinerary2-graph.jpg)

```
输入：tickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
输出：["JFK","ATL","JFK","SFO","ATL","SFO"]
解释：另一种有效的行程是 ["JFK","SFO","ATL","JFK","ATL","SFO"] ，但是它字典排序更大更靠后。
```

此题是求解欧拉回路 / 欧拉通路的题目，本题题意本题：给定一个 n个点 m条边的图，要求从指定的顶点出发，经过所有的边恰好一次（可以理解为给定起点的「一笔画」问题），使得路径的字典序最小。

因为本题保证至少存在一种合理的路径，也就告诉了我们，这张图是一个欧拉图或者半欧拉图。我们只需要输出这条欧拉通路的路径即可。

欧拉图或者半欧拉图定义如下：

- 通过图中所有边恰好一次且行遍所有顶点的通路称为欧拉通路；
- 通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路；
- 具有欧拉回路的无向图称为欧拉图；
- 具有欧拉通路但不具有欧拉回路的无向图称为半欧拉图。

如果没有保证至少存在一种合理的路径，我们需要判别这张图是否是欧拉图或者半欧拉图，具体地：

- 对于无向图$G$，$G$是欧拉图当且仅当 $G$是连通的且没有奇度顶点。
- 对于无向图$G$，$G$是半欧拉图当且仅当 $G$是连通的且 $G$ 中恰有0个或2个奇度顶点。
- 对于有向图$G$，$G$是欧拉图当且仅当$G$的所有顶点属于同一个强连通分量且每个顶点的入度和出度相同。
- 对于有向图$G$，$G$是半欧拉图当且仅当
  - 如果将$G$中的所有有向边退化为无向边时，那么$G$的所有顶点属于同一个强连通分量；
  - 最多只有一个顶点的出度与入度差为1；
  - 最多只有一个顶点的入度与出度差为1；
  - 所有其他顶点的入度和出度相同。

解决方法一般使用 Hierholzer算法：

Hierholzer 算法用于在连通图中寻找欧拉路径，其流程如下：

1. 从起点出发，进行深度优先搜索。
2. 每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。
3. 如果没有可移动的路径，则将所在节点加入到栈中，并返回。

另一种解释如下：

1. 由于题目中说必然存在一条有效路径(至少是半欧拉图)，所以算法不需要回溯（既加入到结果集里的元素不需要删除）
2. 整个图最多存在一个死胡同(出度和入度相差1），且这个死胡同一定是最后一个访问到的，否则无法完成一笔画。
3. DFS的调用其实是一个拆边的过程（既每次递归调用删除一条边，所有子递归都返回后，再将当前节点加入结果集保证了结果集的逆序输出），一定是递归到这个死胡同（没有子递归可以调用）后递归函数开始返回。所以死胡同是第一个加入结果集的元素。
4. 最后逆序的输出即可。

据此实现的代码如下：

```python
class Solution:
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        result = []
        targets = defaultdict(list)
        for f, t in tickets:
            targets[f].append(t)
            
        for k in targets:
            targets[k].sort(reverse = True)	# 由于此题要求字典序最小，因此需要进行排序

        def dfs(target):
            nexts = targets[target]
            while nexts:
                dfs(nexts.pop())
            result.append(target)

        dfs("JFK")
        return result[::-1]
```



## [909. 蛇梯棋](https://leetcode.cn/problems/snakes-and-ladders/)（图BFS）

给你一个大小为 `n x n` 的整数矩阵 `board` ，方格按从 `1` 到 `n2` 编号，编号遵循 [转行交替方式](https://baike.baidu.com/item/牛耕式转行书写法/17195786) ，**从左下角开始** （即，从 `board[n - 1][0]` 开始）每一行交替方向。

玩家从棋盘上的方格 `1` （总是在最后一行、第一列）开始出发。

每一回合，玩家需要从当前方格 `curr` 开始出发，按下述要求前进：

- 选定目标方格`next`，目标方格的编号符合范围 `[curr + 1, min(curr + 6, n2)]`
  - 该选择模拟了掷 **六面体骰子** 的情景，无论棋盘大小如何，玩家最多只能有 6 个目的地。
- 传送玩家：如果目标方格 `next` 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 `next` 。 
- 当玩家到达编号 `n2` 的方格时，游戏结束。

`r` 行 `c` 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 `board[r][c] != -1`，那个蛇或梯子的目的地将会是 `board[r][c]`。编号为 `1` 和 `n2` 的方格上没有蛇或梯子。

注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，玩家也 **不能** 继续移动。

- 举个例子，假设棋盘是 `[[-1,4],[-1,3]]` ，第一次移动，玩家的目标方格是 `2` 。那么这个玩家将会顺着梯子到达方格 `3` ，但 **不能** 顺着方格 `3` 上的梯子前往方格 `4` 。

返回达到编号为 `n2` 的方格所需的最少移动次数，如果不可能，则返回 `-1`。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2018/09/23/snakes.png" alt="img" style="zoom:50%;" />

```
输入：board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]
输出：4
解释：
首先，从方格 1 [第 5 行，第 0 列] 开始。 
先决定移动到方格 2 ，并必须爬过梯子移动到到方格 15 。
然后决定移动到方格 17 [第 3 行，第 4 列]，必须爬过蛇到方格 13 。
接着决定移动到方格 14 ，且必须通过梯子移动到方格 35 。 
最后决定移动到方格 36 , 游戏结束。 
可以证明需要至少 4 次移动才能到达最后一个方格，所以答案是 4 。 
```

**示例 2：**

```
输入：board = [[-1,-1],[-1,3]]
输出：1
```

~~看懂题目了吗？看不懂就对了，~~首先先解释一下题目的要求吧，这题相当于有个棋盘，从左下角开始蛇形向上每个格子有个从1开始递增的序号，你从序号1的格子开始，你每步可以从当前格子开始往后走1~6格，你只能按照序号的升序走，不能往回走（如第5格走到第4格），走到最后一格就结束了。每个格子内有传送门或啥都没有，-1代表啥都没有，大于0的数字代表传送门，传送门意味着你可以传送到当前数字的格子去（如当前是35，你就可以传送到序号为35的格子去），如果你传送过去后的格子内依然是大于0的数字，你不能使用这个传送门，而是继续从从当前格子开始往后走1-6格，现在要求最少需要几步可以走到终点。

其实此题的难点不在题目，也不在使用DFS搜索算法， 而是确信BFS搜索得到的结果就是最优值，虽然说在搜索最短路径时都是使用BFS，但在应用此题时还是很不放心。解法如下：

```java
class Solution {
    public int snakesAndLadders(int[][] board) {
        int len = board.length * board.length;
        boolean[] isVisited = new boolean[len + 1];
        ArrayDeque<int[]> deque = new ArrayDeque<>();
        deque.addFirst(new int[]{1, 0});
        while (!deque.isEmpty()) {
            int[] p = deque.pollLast();
            for (int i = 1; i <= 6; ++i) {
                int local = p[0] + i;
                int[] rc = id2rc(local, board.length); // 得到下一步的行列
                if (board[rc[0]][rc[1]] > 0) { // 存在蛇或梯子，由于终点不存在蛇或梯子，因此无需提前考虑退出
                    local = board[rc[0]][rc[1]];
                }
                if (local == len) { // 到达终点
                    return p[1] + 1;
                }
                if (!isVisited[local]) {
                    isVisited[local] = true;		// BFS中直接设置为true，其他的节点也不会再访问该节点，
                    deque.addFirst(new int[]{local, p[1] + 1}); // 扩展新状态
                }
            }
        }
        return -1;
    }

    public int[] id2rc(int id, int n) {
        int r = (id - 1) / n, c = (id - 1) % n;
        if (r % 2 == 1) { // 如果是奇数列，则y是从右向左
            c = n - 1 - c;
        }
        return new int[]{n - 1 - r, c};
    }
}
```



##  [127. 单词接龙](https://leetcode.cn/problems/word-ladder/)（图双向BFS）

字典 `wordList` 中从单词 `beginWord` 和 `endWord` 的 **转换序列** 是一个按下述规格形成的序列 `beginWord -> s1 -> s2 -> ... -> sk`：

- 每一对相邻的单词只差一个字母。
-  对于 `1 <= i <= k` 时，每个 `si` 都在 `wordList` 中。注意， `beginWord` 不需要在 `wordList` 中。
- `sk == endWord`

给你两个单词 `beginWord` 和 `endWord` 和一个字典 `wordList` ，返回 *从 `beginWord` 到 `endWord` 的 **最短转换序列** 中的 **单词数目*** 。如果不存在这样的转换序列，返回 `0` 。

**示例 1：**

```
输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
输出：5
解释：一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog", 返回它的长度 5。
```

**示例 2：**

```
输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
输出：0
解释：endWord "cog" 不在字典中，所以无法进行转换。
```

此题其实并不难，列在此是为了再一次加深印象搜索最短路径时使用BFS没问题，同时也引出另一种解题思路。

首先是使用BFS求解方法，该方法简单修改即可应用于[433. 最小基因变化](https://leetcode.cn/problems/minimum-genetic-mutation/)中，两种都是同样是要求和思路。

```java
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        char[] startChars = beginWord.toCharArray();
        char[] endChars = endWord.toCharArray();
        char[][] bankChars = new char[wordList.size()][];
        for (int i = 0; i < bankChars.length; i++) {
            bankChars[i] = wordList.get(i).toCharArray();				// 全部转换成char[]后运行速度快
        }
        boolean[] isVisited = new boolean[bankChars.length];
        ArrayDeque<char[]> deque = new ArrayDeque<>();
        deque.addFirst(startChars);
        int time = 1;
        while (!deque.isEmpty()) {
            int size = deque.size();
            for (int i = 0; i < size; i++) {		// 循环deque.size()后time++，这是在讲二叉树的层序遍历时提到的
                startChars = deque.pollLast();
                if (charEquals(startChars, endChars)) return time;		// 从bigin变到了end，则返回
                for (char[] chars : findValidVariation(startChars, bankChars, isVisited)) {
                    deque.addFirst(chars);		// BFS
                }
            }
            time++;
        }
        return 0;
    }

    private boolean charEquals(char[] chars1, char[] chars2){
        for (int i = 0; i < chars1.length; i++) {
            if (chars1[i] != chars2[i]) return false;
        }
        return true;
    }

    private ArrayList<char[]> findValidVariation(char[] chars, char[][] bankChars, boolean[] isVisited) {
        ArrayList<char[]> list = new ArrayList<>();
        for (int i = 0; i < bankChars.length; i++) {
            if (isVisited[i]) continue;							// BFS中经典的遍历过则跳过
            int dif = 0;
            for (int j = 0; j < bankChars[i].length; j++) {
                if (bankChars[i][j] != chars[j]) dif++;
                if (dif > 1) break;
            }
            if (dif == 1) {										// 满足要求的变化结果
                list.add(bankChars[i]);
                isVisited[i] = true;
            }
        }
        return list;
    }
}
```

其实这种方法速度并不快，实际运行达到了196ms，只击败了32%的用户，因此还需要效率更高的算法，除了上面直接搜索的满足要求的结果，也可以直接建立一个邻接表矩阵，但实际测试运行速度达到了406ms，更慢，因为其时间复杂度达到了$O log(N^2M)$，其中$N$为wordList的长度，$M$为beginWord的长度

针对于该方法的改进就是使用双向BFS，其原理如下图所示：

<img src="./mysqlImgs/单词接龙.jpg" alt="img" style="zoom:50%;" />

从图中可以看出，使用双向BFS可以大大减小搜索面积，加快运行效率。其实现的代码如下：

```java
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        char[] endChars = endWord.toCharArray();
        char[][] bankChars = new char[wordList.size()][];
        for (int i = 0; i < bankChars.length; i++) {
            bankChars[i] = wordList.get(i).toCharArray();                // 全部转换成char[]后运行速度快
        }
        int idx;
        if ((idx = charsIdx(endChars, bankChars)) == -1) return 0;
        boolean[] startVisited = new boolean[bankChars.length];			// 定义两个visited
        boolean[] endVisited = new boolean[bankChars.length];
        ArrayDeque<Integer> startDeque = new ArrayDeque<>();			// 定义两个queue
        ArrayDeque<Integer> endDeque = new ArrayDeque<>();
        findValidVariation(beginWord.toCharArray(), bankChars, startVisited, startDeque, endVisited);	// 对于开始和结尾单独处理
        int time = 2;
        if (findValidVariation(endChars, bankChars, endVisited, endDeque, startVisited))
            return startVisited[idx] ? time : time + 1;					// 如果start的visited已经到达了idx，那么就是两次，否则3次
        while (!startDeque.isEmpty() && !endDeque.isEmpty()) {
            time++;
            int startSize = startDeque.size();
            int endSize = endDeque.size();
            if (startSize <= endSize) {							// size小的先进行，提高效率
                for (int i = 0; i < startSize; i++) {       	// 循环deque.size()后time++，这是在讲二叉树的层序遍历时提到的
                    int n = startDeque.pollLast();
                    if (findValidVariation(bankChars[n], bankChars, startVisited, startDeque, endVisited))
                        return time + 1;
                }
            } else {
                for (int i = 0; i < endSize; i++) {          	 // 循环deque.size()后time++，这是在讲二叉树的层序遍历时提到的
                    int n = endDeque.pollLast();
                    if (findValidVariation(bankChars[n], bankChars, endVisited, endDeque, startVisited))
                        return time + 1;
                }
            }
        }
        return 0;
    }

    private int charsIdx(char[] chars, char[][] bankChars) {		// 用来检查endWord是否在wordList中，返回其索引
        for (int i = 0; i < bankChars.length; i++) {
            int num = 0;
            for (int j = 0; j < bankChars[i].length; j++) {
                if (bankChars[i][j] != chars[j]) break;
                num++;
            }
            if (num == bankChars[i].length) return i;
        }
        return -1;
    }

    private boolean findValidVariation(char[] chars, char[][] bankChars, boolean[] isVisited, ArrayDeque<Integer> deque, boolean[] anotherVisited) {
        for (int i = 0; i < bankChars.length; i++) {
            if (isVisited[i]) continue;                            // BFS中经典的遍历过则跳过
            int dif = 0;
            for (int j = 0; j < bankChars[i].length; j++) {
                if (bankChars[i][j] != chars[j]) dif++;
                if (dif > 1) break;
            }
            if (dif <= 1) {                           	// 满足要求的变化结果，其实==即可，但由于最开始可能start变化一次就到end因此成了<=
                if (anotherVisited[i]) return true;		// 对于start来说，如果end已经到达节点i了，那么两者就相遇了
                deque.addFirst(i);
                isVisited[i] = true;
            }
        }
        return false;
    }
}
```

根据代码量来说还是不少的，但内容其实只是把单边的BFS增加为了双边BFS，效率加快了10倍，达到了22ms，击败了91%的用户



## [399. 除法求值](https://leetcode.cn/problems/evaluate-division/)

给你一个变量对数组 `equations` 和一个实数值数组 `values` 作为已知条件，其中 `equations[i] = [Ai, Bi]` 和 `values[i]` 共同表示等式 `Ai / Bi = values[i]` 。每个 `Ai` 或 `Bi` 是一个表示单个变量的字符串。

另有一些以数组 `queries` 表示的问题，其中 `queries[j] = [Cj, Dj]` 表示第 `j` 个问题，请你根据已知条件找出 `Cj / Dj = ?` 的结果作为答案。

返回 **所有问题的答案** 。如果存在某个无法确定的答案，则用 `-1.0` 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 `-1.0` 替代这个答案。

**注意：**输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。

**注意：**未在等式列表中出现的变量是未定义的，因此无法确定它们的答案。

**示例 1：**

```
输入：equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]
解释：
条件：a / b = 2.0, b / c = 3.0
问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?
结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]
注意：x 是未定义的 => -1.0
```

**示例 2：**

```
输入：equations = [["a","b"],["b","c"],["bc","cd"]], values = [1.5,2.5,5.0], queries = [["a","c"],["c","b"],["bc","cd"],["cd","bc"]]
输出：[3.75000,0.40000,5.00000,0.20000]
```

**示例 3：**

```
输入：equations = [["a","b"]], values = [0.5], queries = [["a","b"],["b","a"],["a","c"],["x","y"]]
输出：[0.50000,2.00000,-1.00000,-1.00000]
```

此题难度并不是很大，仔细思考便知这是一个有向图，每个String对应一个索引，equations中的每对String对应一个有向边，values中的值对应有向边的权重。

列在此处只是便于查看并熟悉其解法，此题的解法列出了两种，分别是Floyd-Warshall算法和不相交集合法，这两种方法都在[数据结构](./数据结构.md)中提到了。而Floyd-Warshall算法比较容易，其思路就是建立两两之间的路径，最后查表即可。其实现代码如下：

```java
class Solution6 {
    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        int idx = 0;
        HashMap<String, Integer> map = new HashMap<>(2 * equations.size());
        for (List<String> list : equations) {					// 加入hash表并创建对应的索引
            if (!map.containsKey(list.get(0))) {
                map.put(list.get(0), idx++);
            }
            if (!map.containsKey(list.get(1))) {
                map.put(list.get(1), idx++);
            }
        }
        
        int size = map.size();
        double[][] dist = new double[size][size];
        for (int k = 0; k < values.length; k++) {				// 构建dist矩阵
            List<String> list = equations.get(k);
            int i = map.get(list.get(0));
            int j = map.get(list.get(1));
            dist[i][j] = values[k];
            dist[j][i] = 1.0D / values[k];
            dist[k][k] = 1.0D;
        }
        
        for (int k = 0; k < size; k++) {
            for (int i = 0; i < size; i++) {
                for (int j = 0; j < size; j++) {
                    if (dist[i][j] == 0 && dist[i][k] != 0.0D && dist[k][j] != 0.0D) {
                        dist[i][j] = dist[i][k] * dist[k][j];	// 借路，完善dist矩阵
                    }
                }
            }
        }
        
        double[] result = new double[queries.size()];
        for (int k = 0; k < result.length; k++) {				// 结果填充
            List<String> list = queries.get(k);
            Integer i = map.get(list.get(0));
            if (i == null) {
                result[k] = -1.0D;
                continue;
            }
            Integer j = map.get(list.get(1));
            if (j == null) {
                result[k] = -1.0D;
                continue;
            }
            result[k] = dist[i][j] == 0 ? -1.0D : dist[i][j];
        }
        return result;
    }
}
```

对于不相交集合法，其就不是构建一个二维矩阵来表示，而是采用一个一维矩阵来表示每个索引的weight，这就需要缕清其中的关系。其解法如下：

```java
class Solution {
    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        int idx = 0;
        HashMap<String, Integer> map = new HashMap<>(2 * values.length);
        DisjointSet disjointSet = new DisjointSet(2 * values.length); // 由于是一维矩阵，多一点空间浪费也不要紧，还可以少执行一次循环
        for (int k = 0; k < values.length; k++) { // 构建索引同时联通
            List<String> list = equations.get(k);
            String s0 = list.get(0);
            String s1 = list.get(1);
            Integer i = map.get(s0);
            Integer j = map.get(s1);
            if (i == null) {
                i = idx;
                map.put(s0, idx++);
            }
            if (j == null) {
                j = idx;
                map.put(s1, idx++);
            }
            disjointSet.union(i, j, values[k]);
        }
        
        double[] result = new double[queries.size()];
        for (int k = 0; k < result.length; k++) {
            List<String> list = queries.get(k);
            Integer i = map.get(list.get(0));
            if (i == null) {
                result[k] = -1.0D;
                continue;
            }
            Integer j = map.get(list.get(1));
            if (j == null) {
                result[k] = -1.0D;
                continue;
            }
            result[k] = disjointSet.isConnected(i, j);
        }
        return result;
    }
    
    class DisjointSet {
        int[] parent;
        double[] weight;		// weight[i]表示从i到parent[i]的权重

        public DisjointSet(int size) {
            this.parent = new int[size];
            this.weight = new double[size];
            for (int i = 0; i < size; i++) {
                this.parent[i] = i;
                this.weight[i] = 1.0D;
            }
        }
        // find 是找到老大 - 优化：路径压缩
        public int find(int x) { // x = 2
            if (x != parent[x]) {
                int origin = parent[x];
                parent[x] = find(parent[x]); // 路径压缩
                weight[x] *= weight[origin];
            }
            return parent[x];
        }
        // union 是让两个集合“相交”，即选出新老大，x、y 是原老大索引
        public void union(int x, int y, double weight) {
            int eldestX = find(x);
            int eldestY = find(y);
            if (eldestX == eldestY) return;
            parent[eldestX] = eldestY;		// 由于更改eldestX的parent，因此需要对eldestX的权重进行更新
            this.weight[eldestX] = this.weight[y] * weight / this.weight[x];
        }

        public double isConnected(int x, int y) {
            int rootX = find(x);
            int rootY = find(y);
            if (rootX == rootY) {
                return weight[x] / weight[y];
            } else {
                return -1.0d;
            }
        }
    }
}
```

**说明：**代码 `weight[rootX] = weight[y] * value / weight[x];` 的推导过程，主要需要明白各个变量的含义，由两条路径有向边的权值乘积相等得到相等关系，然后做等价变换即可。

<img src="./imgs/1609863006-GhibcH-image.png" style="zoom:40%;" />

复杂度分析：

- 时间复杂度：$O((N+Q)log⁡A)$，
  - 构建并查集 $O(Nlog⁡A)$，这里 $N$为输入方程 equations 的长度，每一次执行合并操作的时间复杂度是 $O(log⁡A)$，这里$ A$ 是 equations 里不同字符的个数；
  - 查询并查集$ O(Qlog⁡A)$，这里 $Q$为查询数组 queries 的长度，每一次查询时执行「路径压缩」的时间复杂度是$ O(log⁡A)$。

- 空间复杂度：$O(A)$：创建字符与 id 的对应关系 hashMap 长度为 $A$，并查集底层使用的两个数组 parent 和 weight 存储每个变量的连通分量信息，parent 和 weight 的长度均为 $A$。

## [139. 单词拆分](https://leetcode.cn/problems/word-break/)

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。请你判断是否可以利用字典中出现的单词拼接出 `s` 。

**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

**示例 1：**

```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
```

**示例 2：**

```
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
     注意，你可以重复使用字典中的单词。
```

**示例 3：**

```
输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
```

此题并不算难，放在这也是为了开阔思路，看见此题第一印象就是使用字典树，这是正确的，如果熟悉字典树可以很轻松的写出来以下代码：

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Trie trie = new Trie();
        for (String string : wordDict) {
            trie.insert(string);			// 将单词插入字典树
        }
        char[] chars = s.toCharArray();
        ArrayDeque<Integer> deque = new ArrayDeque<>();	// 用来记录前i位是否可以用wordDict中的单词表示。
        deque.addFirst(0);					// 插入第0位置，相当于wordDict中包含空字符串，这是不影响的
        while (!deque.isEmpty()){
            if (findResult(deque.pollLast(), trie, chars, deque))
                return true;
        }
        return false;
    }

    private boolean findResult(int start, Trie trie, char[] chars, ArrayDeque<Integer> deque){
        for (; start < chars.length; start++){
            trie = trie.node[chars[start] - 'a'];
            if (trie == null){
                return false;
            } else if (trie.isWord && !deque.contains(start + 1)){	// 如果队列已经包含该位置，则无需继续添加
                deque.addFirst(start + 1);
            }
        }
        return trie.isWord;		// 循环到了chars的最后，如果此处是单词，则已经找到了
    }

    private static class Trie{
        private final Trie[] node;
        private boolean isWord;

        public Trie() {
            this.node = new Trie[26];
        }

        public void insert(String word){
            Trie trie = this;
            int idx;
            for (char c : word.toCharArray()) {
                idx = c - 'a';
                if (trie.node[idx] == null)
                    trie.node[idx] = new Trie();
                trie = trie.node[idx];
            }
            trie.isWord = true;
        }
    }
}
```

以上代码可以达到1ms，可以击败99%的用户，但如果对动态规划比较熟悉的话，可以用动态规划来解答。此题的代码中和动态规划最接近的地方就是`ArrayDeque<Integer> deque`，其本身就是记录的前i位是否可以用wordDict中的单词表示。这不就是的动态规划中的dp矩阵吗？因此稍加注意便可写出以下动态规划的代码：

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        char[] chars = s.toCharArray();
        char[][] words = new char[wordDict.size()][];
        for (int i = 0; i < words.length; i++) {
            words[i] = wordDict.get(i).toCharArray();		// 全部转为数组类型，加快运算
        }
        boolean[] dp = new boolean[chars.length + 1];		// dp数组，记录前i位是否可以用wordDict中的单词表示
        dp[0] = true;										// 同样的第0位记录为true，等同于deque.addFirst(0);
        for (int i = 0; i < chars.length; i++) {
            if (!dp[i])			// 如果无法达到该位置，则跳过该轮循环
                continue;
            for (char[] word : words) {
                if (startsWith(chars, word, i)) {
                    dp[i + word.length] = true;
                }
            }
        }
        return dp[chars.length];
    }
	// 此函数用于判断chars数组从start开始和target数组是否完全相同
    private boolean startsWith(char[] chars, char[] target, int start){
        if (start + target.length > chars.length) return false;
        for (int i = 0; i < target.length; i++) {
            if (chars[i + start] != target[i]) return false;
        }
        return true;
    }
}
```

以上代码同样可以达到1ms，可以击败99%的用户，但代码量少了很多。



## [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例 2：**

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

**示例 3：**

```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

此题并不算难，放在这也是为了开阔思路，看见此题第一印象就是使用动态规划，这是正确的，如果熟悉动态规划可以很轻松的写出来以下代码：

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        Arrays.fill(dp, 1);
        int result = 1;
        for (int i = 1; i < dp.length; i++) {
            int x = nums[i];
            for (int j = 0; j < i; j++) {
                if (x > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            result = Math.max(result, dp[i]);
        }
        return result;
    }
}
```

其中$dp[i] $的值代表 `nums` 以 $nums[i]$结尾的最长子序列长度，然而该方法的时间复杂度达到了$O(N^2)$，需要57ms，并且只击败了74%的其他用户，是比较慢的，因此需要考虑对其进行优化。

我们考虑维护一个列表 `tails`（类似于单调栈），其中每个元素$ tails[k]$ 的值代表长度为$ k+1$的子序列尾部元素的值。 `tails`**列表一定是严格递增的**。

**算法流程：**

- 转移方程： 

  设 `res`为` tails`当前长度，代表直到当前的最长上升子序列长度。设$j∈[0,res)$，考虑每轮遍历 $nums[k]$ 时，通过二分法遍历 $[0,res)$列表区间，找出 $nums[k]$的大小分界点，会出现两种情况：

  - 区间中存在$ tails[i]>nums[k]$： 将第一个满足 $tails[i]>nums[k]$ 执行 $tails[i]=nums[k]$

  - 区间中不存在 $tails[i]>nums[k]$ ： 意味着$ nums[k]$可以接在前面所有长度的子序列之后，因此肯定是接到最后面，那么新子序列长度为 `res+1`。

- 初始状态：

  令 `tails`列表所有值 `=0`。

- 返回值：

  返回 `res`，即最长上升子子序列长度。

- 复杂度分析：
  时间复杂度 $O(NlogN)$ ： 遍历 `nums` 列表需 $O(N)$，在每个 $nums[i]$ 进行二分查找需$ O(logN)$。

实现的代码如下：

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] tails = new int[nums.length];
        tails[0] = nums[0];
        int res = 1;
        for (int i = 1; i < nums.length; i++) {
            int num = nums[i];
            if (num > tails[res - 1]) {		// 新来的num大于tails的最大值，那么直接加入上升子序列
                tails[res++] = num;
            } else if (num < tails[0]) {	// 新来的num小于tails的最小值，那么替换掉该最小值
                tails[0] = num;
            } else {						// 新来的num介于tails的最大最小值之间，那么替换掉大于num的最小值
                tails[binarySearch(0, res, tails, num)] = num;	
            }
        }
        return res;
    }
	// 该方法使用的是二分查找的改进版
    private int binarySearch(int start, int end, int[] nums, int target){
        while (start < end) {
            int mid = (start + end) >>> 1;
            if (nums[mid] < target)
                start = mid + 1;
            else
                end = mid;
        }
        return start;
    }
}
```

使用二分优化后的动态规划则只耗时2ms，效率加快了25倍之多，击败了99%的其他用户，还是不错的。

python的实现如下：

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        def binary_search(start, end, target, dp):
            while start <= end:
                mid = (start + end) >> 1
                if dp[mid] < target:
                    start = mid + 1
                elif dp[mid] > target:
                    end = mid - 1
                else:
                    return mid
            return start
                
        dp = [0] * len(nums)
        dp[0] = nums[0]
        result = 0
        for i in range(1, len(nums)):
            if nums[i] > dp[result]:
                result += 1
                dp[result] = nums[i]
            else:
                dp[binary_search(0, result, nums[i], dp)] = nums[i]
        return result + 1
```

## [673. 最长递增子序列的个数](https://leetcode.cn/problems/number-of-longest-increasing-subsequence/)

给定一个未排序的整数数组 `nums` ， *返回最长递增子序列的个数* 。

**注意** 这个数列必须是 **严格** 递增的。

**示例 1:**

```
输入: [1,3,5,4,7]
输出: 2
解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。
```

**示例 2:**

```
输入: [2,2,2,2,2]
输出: 5
解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。
```

此题可以使用普通的动态规划方法解决，但还需要再定义一个数组，用来记录第i个位置的最长递增子序列的个数，简单分析一下可以写出以下代码：

```python
class Solution:
    def findNumberOfLIS(self, nums: List[int]) -> int:
        dp = [1] * len(nums)
        count = [1] * len(nums)
        for i in range(len(nums)):
            for j in range(i):
                if nums[i] > nums[j]:
                    if dp[j] + 1 > dp[i]:
                        dp[i] = dp[j] + 1
                        count[i] = count[j]
                    elif dp[j] + 1 == dp[i]:
                        count[i] += count[j]
        max_dp = max(dp)
        return sum(result for d, result in zip(dp, count) if d == max_dp)
```

这样做，其时间复杂度为$O(N^2)$。还是比较高的，我们可以使用上一题的贪心+二分的方法来解决，但是很复杂，且其难度更大，此处就不再列出了。

## [1262. 可被三整除的最大和](https://leetcode.cn/problems/greatest-sum-divisible-by-three/)

给你一个整数数组 `nums`，请你找出并返回能被三整除的元素最大和。

**示例 1：**

```
输入：nums = [3,6,5,1,8]
输出：18
解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。
```

**示例 2：**

```
输入：nums = [4]
输出：0
解释：4 不能被 3 整除，所以无法选出数字，返回 0。
```

**示例 3：**

```
输入：nums = [1,2,3,4,4]
输出：12
解释：选出数字 1, 3, 4 以及 4，它们的和是 12（可被 3 整除的最大和）。
```

这一题我们可以使用贪心的思想来做，即我们求数组的和。

- 如果和是3的倍数那么直接返回。
- 如果和对3的模为1，那么其最大值可能是和减去数组中对3模为1的最小值或者和减去数组中最小的两个对3模为2的数。
- 如果和对3的模为2，那么其最大值可能是和减去数组中对3模为2的最小值或者和减去数组中最小的两个对3模为1的数。

那么我们就可以写为：

```python
class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        s = sum(nums)
        if s % 3 == 0: return s
        dict = [[] for _ in range(3)]
        for num in nums:
            dict[num % 3].append(num)
        remain1 = dict[1]
        remain2 = dict[2]
        remain1.sort()
        remain2.sort()
        if s % 3 == 2:
            remain1, remain2 = remain2, remain1
        if not remain1 and not remain2: return 0
        if not remain1 and len(remain2) > 1: return s - remain2[0] - remain2[1]
        if len(remain2) <= 1: return s - remain1[0]
        return max(s - remain1[0], s - remain2[0] - remain2[1])
```

此处之外，我们还可以使用动态规划来解决这道题，我们可以定义一个3*n的dp数组，其第一行代表最大的对3模为0的和，第二行代表最大的对3模为1的和，第三行代表最大的对3模为2的和，那么递推公式如下：

- 如果num对3的模为0：
  - $dp[i][0] = max(dp[i][0], dp[i - 1][0] + num)$
  - $dp[i][1] = max(dp[i][1], dp[i - 1][1] + num)$
  - $dp[i][2] = max(dp[i][2], dp[i - 1][2] + num)$
- 如果num对3的模为1：
  - $dp[i][0] = max(dp[i][0], dp[i - 1][2] + num)$
  - $dp[i][1] = max(dp[i][1], dp[i - 1][0] + num)$
  - $dp[i][2] = max(dp[i][2], dp[i - 1][1] + num)$
- 如果num对3的模为2：
  - $dp[i][0] = max(dp[i][0], dp[i - 1][1] + num)$
  - $dp[i][1] = max(dp[i][1], dp[i - 1][2] + num)$
  - $dp[i][2] = max(dp[i][2], dp[i - 1][0] + num)$

对于上面的递推公式还是比较复杂的，但如果我们修改dp数组第二三行的定义，即第二行表示最大的对3模为2的和，第三行表示最大的对3模为1的和，那么递推公式变为：

- 如果num对3的模为0：
  - $dp[i][0] = max(dp[i][0], dp[i - 1][0] + num)$
  - $dp[i][1] = max(dp[i][1], dp[i - 1][1] + num)$
  - $dp[i][2] = max(dp[i][2], dp[i - 1][2] + num)$
- 如果num对3的模为1：
  - $dp[i][0] = max(dp[i][0], dp[i - 1][1] + num) = max(dp[i][0], dp[i - 1][1+0] + num)$
  - $dp[i][1] = max(dp[i][1], dp[i - 1][2] + num) = max(dp[i][1], dp[i - 1][1+1] + num)$
  - $dp[i][2] = max(dp[i][2], dp[i - 1][0] + num) = max(dp[i][2], dp[i - 1][(1+2)\%3] + num)$
- 如果num对3的模为2：
  - $dp[i][0] = max(dp[i][0], dp[i - 1][2] + num) = max(dp[i][0], dp[i - 1][2+0] + num)$
  - $dp[i][1] = max(dp[i][1], dp[i - 1][0] + num) = max(dp[i][1], dp[i - 1][(2+1)\%3] + num)$
  - $dp[i][2] = max(dp[i][2], dp[i - 1][1] + num) = max(dp[i][2], dp[i - 1][(2+2)\%3] + num)$

那么经过定义的改变，我们就可以将其写成有规律的形式，基于此，我们可以写出以下代码：

```python
class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        dp = [[-math.inf] * 3 for _ in range(len(nums) + 1)]
        dp[0][0] = 0
        for i, num in enumerate(nums):
            for j in range(3):
                dp[i + 1][j] = max(dp[i][j], dp[i][(j + num) % 3] + num)
        return dp[-1][0]
```

如果需要求对其他数组的模，那么我们只需改变代码中的3即可。

## [97. 交错字符串](https://leetcode.cn/problems/interleaving-string/)

给定三个字符串 `s1`、`s2`、`s3`，请你帮忙验证 `s3` 是否是由 `s1` 和 `s2` **交错** 组成的。

两个字符串 `s` 和 `t` **交错** 的定义与过程如下，其中每个字符串都会被分割成若干 **非空** 子字符串：

- `s = s1 + s2 + ... + sn`
- `t = t1 + t2 + ... + tm`
- `|n - m| <= 1`
- **交错** 是 `s1 + t1 + s2 + t2 + s3 + t3 + ...` 或者 `t1 + s1 + t2 + s2 + t3 + s3 + ...`

**注意：**`a + b` 意味着字符串 `a` 和 `b` 连接。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg)

```
输入：s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
输出：true
```

**示例 2：**

```
输入：s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"
输出：false
```

**示例 3：**

```
输入：s1 = "", s2 = "", s3 = ""
输出：true
```

见到此题第一印象是使用图的DFS，这样可以遍历s1与s2中每个字符，最终返回结果，实现代码如下：

```java
class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        if (s1.length() + s2.length() != s3.length()) return false;
        return dfs(s1.toCharArray(), s2.toCharArray(), s3.toCharArray(), 0, 0, 0);
    }

    private boolean dfs(char[] c1, char[] c2, char[] c3, int i, int j, int k) {
        if (k == c3.length) return true;
        return (i < c1.length && c1[i] == c3[k] && dfs(c1, c2, c3, i + 1, j, k + 1)) ||
                (j < c2.length && c2[j] == c3[k] && dfs(c1, c2, c3, i, j + 1, k + 1));
    }
}
```

使用DFS的代码还是很简洁的，但实际在力扣上跑的时候，最后一个测试用例会无法通过，因为消耗的时间太长了。聪明的可以已经想到了我们还可以增加一个visited矩阵，但是其由来我们是从动态规划中得到启发的。

这就需要使用动态规划，用来保存每次遍历的结果。

- 我们使用$dp[i][j]$表示$s_{1}$的前$ i$ 个字符和$s_{2}$的前$j$ 个字符是否能构成 $s_{3}$的前$ i+j$ 个字符。
  首先，$dp[0][0]$一定是 $True$

- 初始化第一列 $dp[i][0]$，遍历第一列，遍历区间$ [1,s_{1}.length()+1)$

- 初始化第一行 $dp[0][j]$，遍历第一行，遍历区间 $[1,s_{2}.length()+1)$

- 遍历 $dp$数组：
  - 每一行$ i$，遍历区间$ [1,s_{1}.length()+1)$
  - 每一列 $j$，遍历区间$ [1,s_{2}.length()+1)$
  - $dp[i][j]=(dp[i][j−1] \&\& s2[j−1]==s3[i+j−1]) || (dp[i−1][j] \&\& s1[i−1]==s3[i+j−1]) $。解释：$s1$ 前$i$ 位和 $s2$的前$j$ 位能否组成 $s3$ 的前$ i+j$ 位

实现代码如下：

```java
class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        if (s1.length() + s2.length() != s3.length()) return false;
        char[] c1 = s1.toCharArray();
        char[] c2 = s2.toCharArray();
        char[] c3 = s3.toCharArray();
        boolean[][] dp = new boolean[c1.length + 1][c2.length + 1];
        dp[0][0] = true;
        for (int i = 0; i < c1.length; i++) {
            if (c1[i] == c3[i]) dp[i + 1][0] = true;
            else break;
        }
        for (int j = 0; j < c2.length; j++) {
            if (c2[j] == c3[j]) dp[0][j + 1] = true;
            else break;
        }
        for (int i = 1; i <= c1.length; i++) {
            for (int j = 1; j <= c2.length; j++) {
                int idx = i + j - 1;
                dp[i][j] = (c1[i - 1] == c3[idx] && dp[i - 1][j]) || (c2[j - 1] == c3[idx] && dp[i][j - 1]);
            }
        }
        return dp[c1.length][c2.length];
    }
}
```

从代码中可以看出，dp数组是可以降维的，但要注意点，降维前初始化有行和列，但降维后初始化只剩下了行，因此在循环时要把每一行进行一个初始化，即循环时j不能从1开始， 而应该从0开始：

```java
class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        if (s1.length() + s2.length() != s3.length()) return false;
        char[] c1 = s1.toCharArray();
        char[] c2 = s2.toCharArray();
        char[] c3 = s3.toCharArray();
        boolean[] dp = new boolean[c2.length + 1];
        dp[0] = true;
        for (int j = 0; j < c2.length; j++) {
            if (c2[j] == c3[j]) dp[j + 1] = true;
            else break;
        }
        for (int i = 1; i <= c1.length; i++) {
            for (int j = 0; j <= c2.length; j++) {
                int idx = i + j - 1;
                dp[j] = (c1[i - 1] == c3[idx] && dp[j]) || (j > 0 && c2[j - 1] == c3[idx] && dp[j - 1]);
            }
        }
        return dp[c2.length];
    }
}
```

由以上动态规划的代码可以看出，不论是降维后还是降维前，其时间复杂度都是实打实的$O(MN)$，其中$M$是s1的长度，$N$是s2的长度，即使是降维后，其运行时间也达到了2ms，只击败了90%的用户。

那我们能不能不遍历那些不可能是答案的地方呢？答案是肯定的，在我们最前面使用DFS的时候，我们就只遍历那些可能是答案的地方，但是我们会重复遍历很多次同一个$(i,j)$，而我们能不能像BFS那样也记录一个visited矩阵来记录是否访问过该节点呢？答案也是肯定的，因为既然我们的动态规划都可以实现了，而动态规划实现的代码中$dp[i][j]$只与$dp[i][j - 1]$和$dp[i - 1][j]$有关，即只与其上一时刻有关，**并不关心其是怎么来的**，因此我们就可以使用一个visited矩阵来记录是否已经访问过该节点。这样我们就只遍历了可能是答案的地方，并且还没有重复遍历。其实现的代码如下：

```java
class Solution12 {
    public boolean isInterleave(String s1, String s2, String s3) {
        if (s1.length() + s2.length() != s3.length()) return false;
        return dfs(s1.toCharArray(), s2.toCharArray(), s3.toCharArray(), 0, 0, 0, new boolean[s1.length() + 1][s2.length() + 1]);
    }

    private boolean dfs(char[] c1, char[] c2, char[] c3, int i, int j, int k, boolean[][] visited) {
        if (k == c3.length) return true;
        if (visited[i][j]) return false;
        visited[i][j] = true;
        return (i < c1.length && c1[i] == c3[k] && dfs(c1, c2, c3, i + 1, j, k + 1, visited)) ||
                (j < c2.length && c2[j] == c3[k] && dfs(c1, c2, c3, i, j + 1, k + 1, visited));
    }
}
```

从代码可以看出，其相比DFS的代码只是增加了一个visited矩阵，而这样优化后，其运行时间达到了0ms，超过了100%的用户。

## [1653. 使字符串平衡的最少删除次数](https://leetcode.cn/problems/minimum-deletions-to-make-string-balanced/)

给你一个字符串 `s` ，它仅包含字符 `'a'` 和 `'b'` 。

你可以删除 `s` 中任意数目的字符，使得 `s` **平衡** 。当不存在下标对 `(i,j)` 满足 `i < j` ，且 `s[i] = 'b'` 的同时 `s[j]= 'a'` ，此时认为 `s` 是 **平衡** 的。

请你返回使 `s` **平衡** 的 **最少** 删除次数。

**示例 1：**

```
输入：s = "aababbab"
输出：2
解释：你可以选择以下任意一种方案：
下标从 0 开始，删除第 2 和第 6 个字符（"aababbab" -> "aaabbb"），
下标从 0 开始，删除第 3 和第 6 个字符（"aababbab" -> "aabbbb"）。
```

**示例 2：**

```
输入：s = "bbaaaaabb"
输出：2
解释：唯一的最优解是删除最前面两个字符。
```

对于此题，一个很朴素的想法就是对s从第一个位置遍历到最后一个位置，将字符串按当前位置分开，左边全是`a`右边全是`b`，那么可以使用$O(N^2)$的时间复杂度。但是该做法会超时，我们可以使用两次遍历的方法来达到此效果。

第一次遍历我们可以先统计出字符串中`a`的出现次数，那么在第二次遍历的时候，我们仍然是将字符串按当前位置分开，左边全是`a`右边全是`b`，那么我们遍历的时候如果遇到了`a`，那么我们就将次数减去1，如果遇到了`b`，我们就将次数加上1。这是因为遇到`a`时，其相当于在当前位置的左边，我们并不需要将其删除，遇到`b`时，我们需要将其删除。

据此我们可以写出以下代码：

```python
class Solution:
    def minimumDeletions(self, s: str) -> int:
        result = count = s.count("a")
        for c in s:
            if c == "a":
                count -= 1
            else:
                count += 1
            if count < result:
                result = count
        return result
```

除此之外，我们还可以使用动态规划的思想来解决这道题，对于`dp[i]`表示从`0-i`的字符串其需要的删除次数，那么当`dp[i] = b `时我们并不需要删除它，因此此时`dp[i] = dp[i - 1]`，当`dp[i] = a`时，我们需要考虑是删除它还是删除以此开始前面所有`b`的次数，这样我们就可以一次遍历就得到最优解了。

````python
class Solution:
    def minimumDeletions(self, s: str) -> int:
        dp = count_b = 0
        for c in s:
            if c == 'b': count_b += 1  # f 值不变
            else: dp = min(dp + 1, count_b)
        return dp
````

做完此题可以看一下[926. 将字符串翻转到单调递增](https://leetcode.cn/problems/flip-string-to-monotone-increasing/)，与此题很像。

## [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

**示例 1：**

```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

**示例 2：**

```
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
```

**示例 3：**

```
输入：nums = [1], target = 0
输出：-1
```

此题要求设计时间复杂度为$O(log (n))$，则很明显是使用二分法，但由于数组进行了旋转，其并不是完全有序的。

那我们就不能使用二分法了吗？那当然不会，仔细想想，如果我们还是像有序数组的二分法那样查找，但求得中间值后，将数组分成两半，那么这两半数组中必然有一个是有序的，~~想想为什么~~。此时有序部分用二分法查找，无序部分再一分为二，其中一个一定有序，另一个可能有序，可能无序。就这样循环， 那么我们就可以写出如下的代码了。

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        def binary_search(start, end):
            while start <= end:
                mid = (start + end) >> 1
                if nums[mid] == target:
                    return mid
                elif nums[mid] > target:
                    end = mid - 1
                else:
                    start = mid + 1
            return -1
            
        def split_search(start, end):
            while start <= end:
                mid = (start + end) >> 1
                if nums[mid] == target:
                    return mid
                elif nums[mid] > nums[start]:		# mid > start，那么从start-mid是有序的
                    result1 = binary_search(start, mid - 1)
                    if result1 > -1: return result1
                    return split_search(mid + 1, end)
                else:
                    result1 = binary_search(mid + 1, end)
                    if result1 > -1: return result1
                    return split_search(start, mid - 1)
            return -1
        return split_search(0, len(nums) - 1)
```



## [4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

算法的时间复杂度应该为 `O(log (m+n))` 。

**示例 1：**

```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```

**示例 2：**

```
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
```

此题可以将两个数组合并并排序，可以很容易的得到正确结果，但其时间复杂度为$O((m+n)log(m+n))$并不符合题意。

除此之外，我们可以像[88. 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/)这样一次判断一个数，然后将两个数组合并，这样时间复杂度就降低到了$O(m+n)$，但仍然不符合题目要求。

到现在，我们已经得到了$O(m+n)$的时间复杂度，而要求是$O(log(m+n))$，与之差了一个对数复杂度，而一般对数复杂度就是在二分法中出现，因此我们可以在这个的基础上进行改进。由于两个数组均是有序的，我们也并不在意合并后的数组，因此我们就不必要一个一个判断数组，而是一半一半判断（二分思想）。其实这种方法就是求第 `k` 小数的一种特殊情况，只不过此处的第`k`小数是中位数$(m+n)/2$而已。

基于此，我们可以写出以下代码：

```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        def mid_num(nums):
            length = len(nums)
            return nums[length // 2] if length & 1 else (nums[length // 2] + nums[(length - 1) // 2]) / 2
        if len(nums1) == 0: return mid_num(nums2)
        if len(nums2) == 0: return mid_num(nums1)	# 判断一下特殊情况，不是此题的核心
    
        length1 = len(nums1)
        length2 = len(nums2)
        def median_split(start1, start2, k):
            if start1 == length1: return nums2[k + start2 - 1]
            if start2 == length2: return nums1[k + start1 - 1]
            if k == 1: return min(nums1[start1], nums2[start2])
            mid = k >> 1							# 每次比较k/2个数，排除一半
            i = min(length1, start1 + mid) - 1	
            j = min(length2, start2 + mid) - 1
            if nums1[i] <= nums2[j]:
                return median_split(i + 1, start2, k - i + start1 - 1)
            else:
                return median_split(start1, j + 1, k - j + start2 - 1)
        length = length1 + length2
        return median_split(0, 0, (length // 2) + 1) if length & 1 else (median_split(0, 0, length // 2) + median_split(0, 0, (length // 2) + 1)) * 0.5
```



# 深拷贝

## [138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)

给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 **[深拷贝](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)**。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。

例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。

返回复制链表的头节点。

用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：

- `val`：一个表示 `Node.val` 的整数。在此题中`val`不唯一。
- `random_index`：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为 `null` 。

```
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
```

你的代码 **只** 接受原链表的头节点 `head` 作为传入参数。

**示例 1：**

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png" alt="img" style="zoom:40%;" />

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

**示例 2：**

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png" alt="img" style="zoom:40%;" />

```
输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
```

**示例 3：**

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png" alt="img" style="zoom:40%;" />

```
输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
```

解法如下：

```java
class Solution {
    public Node copyRandomList(Node target) {
        if (target == null) return null;
        Node result = new Node(target.val);
        int inx = 0;
        HashMap<Node, Integer> targetMap = new HashMap<>(); // 通过HashMap来定位Node
        HashMap<Integer, Node> resultMap = new HashMap<>();
        resultMap.put(inx, result); // 由于val不唯一，因此只能自定义一个索引ID，便于索引random指针
        targetMap.put(target, inx++);
        Node targetNext = target.next, resultTemp = result;
        while (targetNext != null){
            resultTemp.next = new Node(targetNext.val);
            resultTemp = resultTemp.next;
            resultMap.put(inx, resultTemp);
            targetMap.put(targetNext, inx++);
            targetNext = targetNext.next;
        }
        // 开始处理random指针
        resultTemp = result;
        while (target != null){
            if (target.random != null){
                resultTemp.random = resultMap.get(targetMap.get(target.random));
            }
            target = target.next;
            resultTemp = resultTemp.next;
        }
        return result;
    }
}
```



## [133. 克隆图](https://leetcode.cn/problems/clone-graph/)

给你无向 **[连通](https://baike.baidu.com/item/连通图/6460995?fr=aladdin)** 图中一个节点的引用，请你返回该图的 [**深拷贝**](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)（克隆）。

图中的每个节点都包含它的值 `val`（`int`） 和其邻居的列表（`list[Node]`）。在此题中`val`唯一。

```java
class Node {
    public int val;
    public List<Node> neighbors;

    public Node() {
        val = 0;
        neighbors = new ArrayList<>();
    }

    public Node(int _val) {
        val = _val;
        neighbors = new ArrayList<>();
    }

    public Node(int _val, ArrayList<Node> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
}
```

 **示例 1：**

```
输入：adjList = [[2,4],[1,3],[2,4],[1,3]]
输出：[[2,4],[1,3],[2,4],[1,3]]
解释：
图中有 4 个节点。
节点 1 的值是 1，它有两个邻居：节点 2 和 4 。
节点 2 的值是 2，它有两个邻居：节点 1 和 3 。
节点 3 的值是 3，它有两个邻居：节点 2 和 4 。
节点 4 的值是 4，它有两个邻居：节点 1 和 3 。
```

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/133_clone_graph_question.png" alt="img" style="zoom:20%;" />

**示例 2：**

```
输入：adjList = [[]]
输出：[[]]
解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。
```

**示例 3：**

```
输入：adjList = []
输出：[]
解释：这个图是空的，它不含任何节点。
```

解法如下：

```java
class Solution {
    // 使用bfs，由于val唯一，故可以使用val作为key来查询node
    public Node cloneGraph(Node target) {
        if (target == null) return null;
        Node head = new Node(target.val);
        if (head.neighbors == null) return head; // 只有一个顶点
        Node result = head;
        HashMap<Integer, Node> map = new HashMap<>(); // 用来放result的Node
        map.put(head.val, head);
        ArrayDeque<Node> deque = new ArrayDeque<>(); // 用来放target的Node
        deque.addLast(target);
        while (!deque.isEmpty()) {
            target = deque.pollFirst();
            head = map.get(target.val);
            for (Node targetNeighbors : target.neighbors) {
                Node headNeighbors = map.get(targetNeighbors.val);
                if (headNeighbors == null) { // 如果result里不存在headNeighbors则创建一个并加入result
                    headNeighbors = new Node(targetNeighbors.val);
                    map.put(headNeighbors.val, headNeighbors);
                    deque.addLast(targetNeighbors); // 此时加入deque，因为还没有遍历过targetNeighbors的neighbors
                }
                head.neighbors.add(headNeighbors);
            }
        }
        return result;
    }
}
```

可以看出，以上两题的共同思路均为使用HashMap来索引对应的Node，对于[138. 随机链表的复制](# 138. 随机链表的复制)，其由于val不唯一，因此自定义了一个ID，并用此ID作为HashMap的Key来索引Node，而[133. 克隆图](# 133. 克隆图)中由于val唯一，因此使用val即可作为Key索引Node。

课本上总说deep copy和shallow copy，似懂非懂的，不觉得这东西有什么用。慢慢地，发现deep copy背后隐藏的逻辑其实是一种对象图（Object Graph）的遍历行为——这东西广泛出现在各语言的垃圾回收、序列化机制里。内存里各个对象存储空间中放置的引用域/指针就好像有向图里一条边，你沿着它去到达内存中的每个角落、去到当前对象所有的关联对象。题设里的`neibours`就像一道开胃菜，它可以是其他collection、甚至object，学会这个deep copy，你也就学会了GC里的可达性分析、你也就学会了如何把RAM中的数据固化到硬盘里。

# 打家劫舍系列

## [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

此题并不算困难，只是普通的动态规划，其思想很简单，即如果抢当前的房屋，那么上一个房屋就不能抢，因此转移矩阵就是$dp[i]=max(dp[i-1], dp[i-2], values[i])$。写出的代码如下：

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) < 3: return max(nums)
        pre, post = nums[0], max(nums[0], nums[1])
        for i in range(2, len(nums)):
            pre, post = post, max(pre + nums[i], post)
        return post
```

## [213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **在不触动警报装置的情况下** ，今晚能够偷窃到的最高金额。

**示例 1：**

```
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```

**示例 2：**

```
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 3：**

```
输入：nums = [1,2,3]
输出：3
```

此题相比上一题，多了一个限制条件，即房屋成环。而对于环我们并没有特别好的处理办法，因此我们可以考虑两次。第一次只偷第一家至倒数第二家，第二次只偷第二家至倒数第一家，然后取两者最大值即可。

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) < 3: return max(nums)
        pre1, post1 = 0, nums[1]						# 偷第二至倒数第一家
        pre2, post2 = nums[0], max(nums[0], nums[1])	# 偷第一至倒数第二家
        for i in range(2, len(nums)):
            pre1, post1 = post1, max(pre1 + nums[i], post1)
            pre2, post2 = post2, max(pre2 + nums[i], post2)
        return max(post1, pre2)
```

## [337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)

小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root` 。

除了 `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。

给定二叉树的 `root` 。返回 ***在不触动警报的情况下** ，小偷能够盗取的最高金额* 。

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg)

```
输入: root = [3,2,3,null,3,null,1]
输出: 7 
解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7
```

**示例 2:**

![img](https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg)

```
输入: root = [3,4,5,1,3,null,1]
输出: 9
解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9
```

对于此题，其基本思路和前面两道题一样，还是选择不相邻的来偷，但是遍历方式有点不一样而已。对于这类题目的遍历，如果从父节点到子节点，我们需要考虑很多，同时也要有很多判断，来判断子节点是否存在等，因此很麻烦。因此此类题目都是采用后续遍历的方式，从最下面开始，这样就少了很多判断。

与前两题一样，我们的动态规划转移方程是不变的，但是前面两题其只是判断前一个结点即可，而此题就需要判断两个子节点，因此会多一点。根据分析可以写出以下代码：

```python
class Solution:
    def rob(self, root: Optional[TreeNode]) -> int:
        def dfs(root: Optional[TreeNode]): # 函数返回值第一个为偷当前房屋的最高金额，第二个为不偷当前房屋的最高金额
            if root is None: return 0, 0
            left_rob, left_not_rob = dfs(root.left)
            right_rob, right_not_rob = dfs(root.right)
            return root.val + left_not_rob + right_not_rob, max(left_rob, left_not_rob) + max(right_rob, right_not_rob)
        return max(dfs(root))
```

## [968. 监控二叉树](https://leetcode.cn/problems/binary-tree-cameras/)

给定一个二叉树，我们在树的节点上安装摄像头。

节点上的每个摄影头都可以监视**其父对象、自身及其直接子对象。**

计算监控树的所有节点所需的最小摄像头数量。

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png)

```
输入：[0,0,null,0,0]
输出：1
解释：如图所示，一台摄像头足以监控所有节点。
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_02.png)

```
输入：[0,0,null,0,null,0,null,null,0]
输出：2
解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。
```

此题其实本质上与上一题相同，其基本思想都是间隔着偷/放，但此题要求将所有的节点全部覆盖，那么就需要对此做成一定的改变。除此之前，两者基本是相同的，都是后续遍历思想，都是动态规划思想。

我们可以定义一些状态，0: 该节点未覆盖、1: 该节点有摄像头、2: 该节点有覆盖，那么据此我们可以写出以下代码：

```python
class Solution:
    result = 0
    def minCameraCover(self, root: Optional[TreeNode]) -> int:
        def dfs(root: Optional[TreeNode]):
            if root is None: return 2 				# 对于空的节点，我们无序覆盖摄像头，因此返回2
            left = dfs(root.left)
            right = dfs(root.right)
            if left == 2 and right == 2: return 0	# 如果左右节点只是覆盖，无摄像头，那么该节点未覆盖
            if left == 0 or right == 0: 			# 如果左右节点有一个未覆盖，那么该节点就增加一个摄像头
                self.result += 1
                return 1
            return 2
        return self.result if dfs(root) > 0 else self.result + 1	# 如果根节点未覆盖，那么需要再多一个摄像头
```

# 丑数系列（质因数）

## [263. 丑数](https://leetcode.cn/problems/ugly-number/)

**丑数** 就是只包含质因数 `2`、`3` 和 `5` 的正整数。

给你一个整数 `n` ，请你判断 `n` 是否为 **丑数** 。如果是，返回 `true` ；否则，返回 `false` 。

**示例 1：**

```
输入：n = 6
输出：true
解释：6 = 2 × 3
```

**示例 2：**

```
输入：n = 1
输出：true
解释：1 没有质因数，因此它的全部质因数是 {2, 3, 5} 的空集。习惯上将其视作第一个丑数。
```

**示例 3：**

```
输入：n = 14
输出：false
解释：14 不是丑数，因为它包含了另外一个质因数 7 。
```

此题较为简单，只需判断数字的质因数是否只含有 `2`、`3` 和 `5` ，那么该数字一定可以表示成m个2，n个3，l个5的相乘，其中m,n,l可以为0。那么就可以很轻松的写成以下代码了：

```python
class Solution:
    def isUgly(self, n: int) -> bool:
        if n <= 0: return False
        for i in (2, 3, 5):
            while n % i == 0:
                n //= i
        return n == 1
```

## [264. 丑数 II](https://leetcode.cn/problems/ugly-number-ii/)

给你一个整数 `n` ，请你找出并返回第 `n` 个 **丑数** 。

**丑数** 就是质因子只包含 `2`、`3` 和 `5` 的正整数。

**示例 1：**

```
输入：n = 10
输出：12
解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。
```

**示例 2：**

```
输入：n = 1
输出：1
解释：1 通常被视为丑数。
```

此题要求找出并返回n个丑数，那么最简单的想法，我们可以利用上面判断丑数的方法从1开始判断，一直到第n个丑数，但这样时间复杂度是很高的，效率很低。那么我们需要使用其他的方法来快速的解决这道题目。

我们可以使用动态规划来解决这道题，令dp[i]表示从小到大的第i个丑数，那么dp[i] / 2，dp[i] / 3， dp[i] / 5（如果存在的话）均为丑数。

定义三个指针 $p_2,p_3,p_5$，表示下一个丑数是当前指针指向的丑数乘以对应的质因数。最开始，三个质因数$num2, num3, num5$是给定的，

当$2≤i≤n$*时，令*$dp[i]=min(num2, num3, num5)$，然后分别比较$dp[i]$与$num2, num3, num5$的值，如果相等，则更新对应的值，即如果$dp[i]=num2$，那么$p_2 = p_2 + 1，num2 = dp[p_2] * 2$。这样做可以使得如果$num2, num3, num5$都相等，也可以正确处理重复值。

```python
class Solution:
    def nthUglyNumber(self, n: int) -> int:
        dp = [1] * (n + 1)
        p2, p3, p5 = 0, 0, 0
        num2, num3, num5 = 2, 3, 5
        for i in range(1, n + 1):
            min_num = min(num2, num3, num5)
            dp[i] = min_num
            if num2 == min_num:
                p2 += 1
                num2 = dp[p2] * 2
            if num3 == min_num:
                p3 += 1
                num3 = dp[p3] * 3
            if num5 == min_num:
                p5 += 1
                num5 = dp[p5] * 5
        return dp[n]
```

## [313. 超级丑数](https://leetcode.cn/problems/super-ugly-number/)

**超级丑数** 是一个正整数，并满足其所有质因数都出现在质数数组 `primes` 中。

给你一个整数 `n` 和一个整数数组 `primes` ，返回第 `n` 个 **超级丑数** 。

题目数据保证第 `n` 个 **超级丑数** 在 **32-bit** 带符号整数范围内。

**示例 1：**

```
输入：n = 12, primes = [2,7,13,19]
输出：32 
解释：给定长度为 4 的质数数组 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。
```

**示例 2：**

```
输入：n = 1, primes = [2,3,5]
输出：1
解释：1 不含质因数，因此它的所有质因数都在质数数组 primes = [2,3,5] 中。
```

此题只是对上一题进行了扩展，即质因数不再只是2，3，5。而是题目给出的数字，那么我们可以在上一题的基础上进行简单的更改即可。需要组意的是上一题中把1也算为了丑数，而此题中1并不算丑数，因此上一题在定义dp数组的时候需要多定义一个位置，即$dp = [1] * (n + 1)$，而此题则不用。

```python
class Solution:
    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:
        dp = [1] * n
        m = len(primes)
        p = [0] * m
        nums = primes.copy()
        for i in range(1, n):
            min_num = min(nums)
            dp[i] = min_num
            for j in range(m):
                if nums[j] == min_num:
                    p[j] += 1
                    nums[j] = dp[p[j]] * primes[j]
        return dp[-1]
```

## [878. 第 N 个神奇数字](https://leetcode.cn/problems/nth-magical-number/)

一个正整数如果能被 `a` 或 `b` 整除，那么它是神奇的。

给定三个整数 `n` , `a` , `b` ，返回第 `n` 个神奇的数字。因为答案可能很大，所以返回答案 **对** `10^9 + 7` **取模** 后的值。

**示例 1：**

```
输入：n = 1, a = 2, b = 3
输出：2
```

**示例 2：**

```
输入：n = 4, a = 2, b = 3
输出：6
```

此题与前面的题目就不一样了，其只是要求可以整处即可，并不要求数字的质因数全部为 `a` 或 `b` 。因此做法就不一样了。

对于此题，我们是采用容斥原理+二分法做的，对于任意两个数 `a` 或 `b` ，如果一个数能被 `a` 或 `b` 整除，那么这个数一定是 `a` 的倍数，或`b`的倍数，或 `a` 和 `b` 共同的倍数。那么我们可以定义一个上届$lcm(a,b)*n$，其中$lcm(a,b)$表示 `a` 和 `b` 的最小公倍数。那么$lcm(a,b)*n$至少是第 `n` 个神奇的数字。接着我们使用二分法从0至上届进行搜索，不断搜索当前数字是第几个神奇的数字，由于我们需要被整除，那么我们需要找到第 `n` 个神奇的数字最左边的那一个。即

```python
class Solution:
    def nthMagicalNumber(self, n: int, a: int, b: int) -> int:
        lcm = math.lcm(a, b)
        left, right = 0, n * lcm
        while left < right:
            mid = (left + right) // 2
            count = mid // a + mid // b - (mid // lcm)
            if count < n:
                left = mid + 1
            else:
                right = mid
        return left % 1000000007
```

## [1201. 丑数 III](https://leetcode.cn/problems/ugly-number-iii/)

丑数是可以被 `a` **或** `b` **或** `c` 整除的 **正整数** 。

给你四个整数：`n` 、`a` 、`b` 、`c` ，请你设计一个算法来找出第 `n` 个丑数。

**示例 1：**

```
输入：n = 3, a = 2, b = 3, c = 5
输出：4
解释：丑数序列为 2, 3, 4, 5, 6, 8, 9, 10... 其中第 3 个是 4。
```

**示例 2：**

```
输入：n = 4, a = 2, b = 3, c = 4
输出：6
解释：丑数序列为 2, 3, 4, 6, 8, 9, 10, 12... 其中第 4 个是 6。
```

**示例 3：**

```
输入：n = 5, a = 2, b = 11, c = 13
输出：10
解释：丑数序列为 2, 4, 6, 8, 10, 11, 12, 13... 其中第 5 个是 10。
```

此题是在上一题的基础上做的扩展，其同样是求能被整处的数。我们同样使用容斥原理+二分法解决这个题目，只是容斥原理我们的公式变复杂了：$A∪B∪C=A+B+C-A∩B-A∩C-B∩C+A∩B∩C$，根据此公式我们可以写出以下代码：

```python
class Solution:
    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:
        lcmab, lcmac, lcmbc, lcmabc = math.lcm(a, b), math.lcm(a, c), math.lcm(b, c), math.lcm(a, b, c)
        left, right = 0, n * min(a, b, c)	# 搜索上届优化为了a,b,c中的最小值
        while left < right:
            mid = (left + right) // 2
            count = mid // a + mid // b + mid // c - mid // lcmab - mid // lcmac - mid // lcmbc + mid // lcmabc
            if count < n:
                left = mid + 1
            else:
                right = mid
        return left
```

## [3116. 单面值组合的第 K 小金额](https://leetcode.cn/problems/kth-smallest-amount-with-single-denomination-combination/)

给你一个整数数组 `coins` 表示不同面额的硬币，另给你一个整数 `k` 。

你有无限量的每种面额的硬币。但是，你 **不能** 组合使用不同面额的硬币。

返回使用这些硬币能制造的 **第** $k_{th}$**小** 金额。

**示例 1：**

```
输入：coins = [3,6,9], k = 3
输出：9

解释：给定的硬币可以制造以下金额：
3元硬币产生3的倍数：3, 6, 9, 12, 15等。
6元硬币产生6的倍数：6, 12, 18, 24等。
9元硬币产生9的倍数：9, 18, 27, 36等。
所有硬币合起来可以产生：3, 6, 9, 12, 15等。
```

**示例 2：**

```
输入：coins = [5,2], k = 7
输出：12

解释：给定的硬币可以制造以下金额：
5元硬币产生5的倍数：5, 10, 15, 20等。
2元硬币产生2的倍数：2, 4, 6, 8, 10, 12等。
所有硬币合起来可以产生：2, 4, 5, 6, 8, 10, 12, 14, 15等。
```

此题是上两题的扩展，上面两题只是2个或3个被除数，现在扩展为了coins的长度个，但其思路是一样的，只是代码更加复杂了。

```python
class Solution:
    def findKthSmallest(self, coins: List[int], k: int) -> int:
        import itertools
        def compute(val, lcms):
            count = 0
            for i in range(len(lcms)):
                if i & 1:
                    for lcm in lcms[i]:
                        count -= val // lcm
                else:
                    for lcm in lcms[i]:
                        count += val // lcm
            return count
        
        lcms = [0] * (len(coins))
        lcms[0] = coins
        for i in range(1, len(coins)):
            combinations = itertools.combinations(coins, i+1)
            lcms[i] = [math.lcm(*c) for c in combinations]
        left, right = 0, k * min(coins)
        while left < right:
            mid = (left + right) // 2
            count = compute(mid, lcms)
            if count < k:
                left = mid + 1
            else:
                right = mid
        return left
```

# 数之和系列

## [1. 两数之和](https://leetcode.cn/problems/two-sum/)

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**

```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**

```
输入：nums = [3,3], target = 6
输出：[0,1]
```

**方法一：暴力枚举**

- 思路及算法
  - 最容易想到的方法是枚举数组中的每一个数 $x$，寻找数组中是否存在 $target - x$。
  - 当我们使用遍历整个数组的方式寻找 $target - x$ 时，需要注意到每一个位于$ x$ 之前的元素都已经和$ x $匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 $x$ 后面的元素中寻找$ target - x$。

- 复杂度分析
  - 时间复杂度：$O(N^2)$，其中 $N$ 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。
  - 空间复杂度：$O(1)$。

**方法二：哈希表**

- 思路及算法
  - 注意到方法一的时间复杂度较高的原因是寻找 $target - x$ 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。
  - 使用哈希表，可以将寻找 $target - x$ 的时间复杂度降低到从$O(N)$ 降低到 $O(1)$。
  - 这样我们创建一个哈希表，对于每一个 $x$，我们首先查询哈希表中是否存在 $target - x$，然后将$x $插入到哈希表中，即可保证不会让$ x $和自己匹配。

- 复杂度分析
  - 时间复杂度：$O(N)$，其中 $N$是数组中的元素数量。对于每一个元素 $x$，我们可以$O(1)$地寻找$ target - x$。
  - 空间复杂度：$O(N)$，其中$N$ 是数组中的元素数量。主要为哈希表的开销。

基于哈希表实现的代码如下：

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> map = new HashMap<>();
        Integer num;
        for (int i = 0; i < nums.length; i++) {
            if ((num = map.get(target - nums[i])) != null)
                return new int[]{i, num};
            map.put(nums[i], i);
        }
        return new int[]{0, 0};
    }
}
```

## [454. 四数相加 II](https://leetcode.cn/problems/4sum-ii/)

给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：

- `0 <= i, j, k, l < n`
- `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`

**示例 1：**

```
输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
输出：2
解释：
两个元组如下：
1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
```

**示例 2：**

```
输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]
输出：1
```

这道题目是四个独立的数组，只要找到$A[i] + B[j] + C[k] + D[l] = 0$就可以，不用考虑有重复的四个元素相加等于0的情况，因此我们可以使用哈希表来解决。

解题步骤如下：

1. 首先定义 一个字典，key放a和b两数之和，value 放a和b两数之和出现的次数。
2. 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。
3. 定义int变量count，用来统计 a+b+c+d = 0 出现的次数。
4. 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。
5. 最后返回统计值 count 就可以了

```python
class Solution:
    def fourSumCount(self, nums1: list, nums2: list, nums3: list, nums4: list) -> int:
        rec, cnt = defaultdict(lambda : 0), 0
        for i in nums1:
            for j in nums2:
                rec[i+j] += 1
        for i in nums3:
            for j in nums4:
                cnt += rec.get(-(i+j), 0) 
        return cnt
```

## [167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

给你一个下标从 **1** 开始的整数数组 `numbers` ，该数组已按 **非递减顺序排列** ，请你从数组中找出满足相加之和等于目标数 `target` 的两个数。如果设这两个数分别是 `numbers[index1]` 和 `numbers[index2]` ，则 `1 <= index1 < index2 <= numbers.length` 。

以长度为 2 的整数数组 `[index1, index2]` 的形式返回这两个整数的下标 `index1` 和 `index2`。

你可以假设每个输入 **只对应唯一的答案** ，而且你 **不可以** 重复使用相同的元素。

你所设计的解决方案必须只使用常量级的额外空间。

**示例 1：**

```
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。
```

**示例 2：**

```
输入：numbers = [2,3,4], target = 6
输出：[1,3]
解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。
```

**示例 3：**

```
输入：numbers = [-1,0], target = -1
输出：[1,2]
解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。
```

**双指针**

- 思路
  - 初始时两个指针分别指向第一个元素位置和最后一个元素的位置。每次计算两个指针指向的两个元素之和，并和目标值比较。如果两个元素之和等于目标值，则发现了唯一解。如果两个元素之和小于目标值，则将左侧指针右移一位。如果两个元素之和大于目标值，则将右侧指针左移一位。移动指针之后，重复上述操作，直到找到答案。

- 复杂度分析
  - 时间复杂度：$O(n)$，其中 $n$ 是数组的长度。两个指针移动的总次数最多为 $n $次。
  - 空间复杂度：$O(1)$。

基于双指针实现的代码如下：

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int i = 0, j = numbers.length - 1;
        int sum = numbers[i] + numbers[j];
        while (sum != target){
            if (sum > target) j--;
            else i++;
            sum = numbers[i] + numbers[j];
        }
        return new int[]{i + 1, j + 1};
    }
}
```

## [15. 三数之和](https://leetcode.cn/problems/3sum/)

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请

你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

**示例 2：**

```
输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。
```

**示例 3：**

```
输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。
```

**排序 + 双指针**

- 算法流程：
  1. 对数组进行排序。
  2. 遍历排序后数组：
     - 若 $nums[i]>0$：因为已经排序好，所以后面不可能有三个数加和等于 0，直接返回结果。
     - 对于重复元素：跳过，避免出现重复解
     - 套用上面两数之和 II的解法搜索新的解
       

- 复杂度分析
  - 时间复杂度：$O\left(n^{2}\right)$，数组排序 $O(N \log N)$，遍历数组 $O\left(n\right)$，双指针遍历 $O\left(n\right)$，总体$ O(Nlog⁡N)+O(n)∗O(n)=O\left(n^{2}\right)$
  - 空间复杂度：$O(1)$

实现的代码如下：

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> lists = new ArrayList<>();
        int length = nums.length;
        for (int i = 0; i < length - 2; i++) {
            if (nums[i] + nums[i + 1] + nums[i + 2] > 0) return lists;			// 该情况下不可能符合条件
            if (nums[i] + nums[length - 2] + nums[length - 1] < 0) continue;	// 该情况下不可能符合条件
            if (i > 0 && nums[i] == nums[i - 1]) continue;						// 避免出现重复解
            twoSum(i + 1, length - 1, nums, -nums[i], lists);
        }
        return lists;
    }

    public void twoSum(int i, int j, int[] nums, int target, List<List<Integer>> lists) {
        while (i < j) {
            if (nums[i] + nums[j] > target) j--;
            else if (nums[i] + nums[j] < target) i++;
            else {
                lists.add(List.of(nums[i], nums[j], -target));
                do i++;											// 正常的话i++就足够了，再循环就是为了避免重复解
                while (i < j && nums[i] == nums[i - 1]);		// 避免出现重复解
                do j--;
                while (i < j && nums[j] == nums[j + 1]);		// 避免出现重复解
            }
        }
    }
}
```

## [18. 四数之和](https://leetcode.cn/problems/4sum/)

给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：

- `0 <= a, b, c, d < n`
- `a`、`b`、`c` 和 `d` **互不相同**
- `nums[a] + nums[b] + nums[c] + nums[d] == target`

你可以按 **任意顺序** 返回答案 。

**示例 1：**

```
输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```

**示例 2：**

```
输入：nums = [2,2,2,2,2], target = 8
输出：[[2,2,2,2]]
```

 **排序 + 双指针**

- 算法流程：
  - 四数之和与前面三数之和的思路几乎是一样的，这里其实就是在前面的基础上多添加一个遍历的指针而已。

- 复杂度分析
  - 时间复杂度：$O\left(n^{3}\right)$，数组排序 $O(N \log N)$，遍历数组 $O\left(n^{2}\right)$，双指针遍历 $O\left(n\right)$，总体$ O(Nlog⁡N)+O\left(n^{2}\right)∗O(n)=O\left(n^{3}\right)$
  - 空间复杂度：$O(1)$

实现代码如下：

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> lists = new ArrayList<>();
        if (nums.length < 3) return lists;
        Arrays.sort(nums);
        int length = nums.length;
        for (int i = 0; i < length - 3; i++) {
            long sum = nums[i];
            if (sum + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) return lists;
            if (sum + nums[length - 3] + nums[length - 2] + nums[length - 1] < target) continue;
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            for (int j = i + 1; j < length - 2; j++) {
                if (j > i + 1 && nums[j] == nums[j - 1]) continue;
                sum = nums[i] + nums[j];
                if (sum + nums[j + 1] + nums[j + 2] > target) break;
                if (sum + nums[length - 2] + nums[length - 1] < target) continue;
                twoSum(j + 1, length - 1, nums, target - sum, lists, nums[i], nums[j]);
            }
        }
        return lists;
    }
    public void twoSum(int i, int j, int[] nums, long target, List<List<Integer>> lists, int num1, int num2) {
        while (i < j) {
            if (nums[i] + nums[j] > target) j--;
            else if (nums[i] + nums[j] < target) i++;
            else {
                lists.add(List.of(nums[i], nums[j], num1, num2));
                do i++;
                while (i < j && nums[i] == nums[i - 1]);
                do j--;
                while (i < j && nums[j] == nums[j + 1]);
            }
        }
    }
}
```

由于leetcode官方给的测试用例很变态，因此计算$nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3]$及计算$target$时候需要使用$long$类型，代码看起来就比较复杂了。另外关于不可能符合条件的判断是必须要有的，可以大大缩短执行时间，超越99%的用户

# 堆（最大/最小值）

## [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `k` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

你必须设计并实现时间复杂度为 $O(n)$ 的算法解决此问题。

**示例 1:**

```
输入: [3,2,1,5,6,4], k = 2
输出: 5
```

**示例 2:**

```
输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4
```

此题并不算难题，基于堆排序的思想较为常规，但其复杂度为$O (n(log (n))$，~~其实使用计算排序更快~~，在此处介绍另一种方法，即使用[快速排序的方法](./数据结构.md#8 快速排序)，也叫做快速选择算法，其平均时间复杂度可以达到 $O(n)$ 。

首先我们来回顾一下快速排序，这是一个典型的分治算法。我们对数组$ a[l⋯r] $做快速排序的过程是（参考《算法导论》）：

- **分解**： 将数组 $a[l⋯r]$「划分」成两个子数组 $a[l⋯q−1]$、$a[q+1⋯r]$，使得 $a[l⋯q−1]$中的每个元素小于等于 $a[q]$，且 $a[q]$小于等于 $a[q+1⋯r]$中的每个元素。其中，计算下标 $q$也是「划分」过程的一部分。

- **解决**： 通过递归调用快速排序，对子数组 $a[l⋯q−1]$ 和 $a[q+1⋯r]$进行排序。

- **合并**： 因为子数组都是原址排序的，所以不需要进行合并操作，$ a[l⋯r] $ 已经有序。

- 上文中提到的 「划分」 过程是：从子数组$ a[l⋯r] $中选择任意一个元素$ x $作为主元，调整子数组的元素使得左边的元素都小于等于它，右边的元素都大于等于它， $x$ 的最终位置就是 $q$。

由此可以发现每次经过「划分」操作后，我们一定可以确定一个元素的最终位置，即 $x$ 的最终位置为 $q$，并且保证 $a[l⋯q−1]$中的每个元素小于等于 $a[q]$，且 $a[q]$ 小于等于 $a[q+1⋯r]$中的每个元素。所以只要某次划分的$q$ 为倒数第 $k$ 个下标的时候，我们就已经找到了答案。 我们只关心这一点，至于$a[l⋯q−1]$和$a[q+1⋯r]$ 是否是有序的，我们不关心。

因此我们可以改进快速排序算法来解决这个问题：在分解的过程当中，我们会对子数组进行划分，如果划分得到的$q$ 正好就是我们需要的下标，就直接返回 $a[q]$；否则，如果 $q$ 比目标下标小，就递归右子区间，否则递归左子区间。这样就可以把原来递归两个区间变成只递归一个区间，提高了时间效率。这就是「快速选择」算法。

```java
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        def quick_select(nums, left, right, k):
            if left == right: return nums[left]
            index = partition(nums, left, right)
            if k == index: return nums[k]
            elif k < index: return quick_select(nums, left, index - 1, k)
            else: return quick_select(nums, index + 1, right, k)

        def partition(nums, left, right):
            index = random.randint(left, right)
            nums[left], nums[index] = nums[index], nums[left]
            pivot = nums[left]
            i, j = left + 1, right
            while i <= j:
                while i <= j and nums[i] < pivot: i += 1
                while i <= j and nums[j] > pivot: j -= 1
                if i <= j: 
                    nums[i], nums[j] = nums[j], nums[i]
                    i += 1
                    j -= 1
            nums[left], nums[j] = nums[j], nums[left]
            return j

        return quick_select(nums, 0, len(nums) - 1, len(nums) - k)
```

如果看完此题感觉无压力，可以试试[347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)，此题同样可以使用堆排序，~~计数排序~~，但使用快排会更快。

代码根据以上简单改改即可：

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int num : nums) map.put(num, map.getOrDefault(num, 0) + 1);
        int[][] arr = new int[map.size()][2];
        int i = 0;
        for (Map.Entry<Integer, Integer> entry : map.entrySet()){
            arr[i++] = new int[]{entry.getValue(), entry.getKey()};
        }
        quick(arr, 0, arr.length - 1, arr.length - k);
        int[] result = new int[k];
        for (int j = 0; j < k; j++) {
            result[j] = arr[arr.length - 1 - j][1];
        }
        return result;
    }

    private static void quick(int[][] arr, int left, int right, int k) {
        if (right == left) return;
        int p = enhancedPartition(arr, left, right);
        if (p < k) {
            quick(arr, p + 1, right, k);
        } else if (p > k){
            quick(arr, left, p - 1, k);
        }
    }

    private static int enhancedPartition(int[][] arr, int left, int right) {
        swap(arr, left, ThreadLocalRandom.current().nextInt(left, right + 1));
        int pv = arr[left][0]; // 基准点元素的值
        int i = left + 1, j = right; // i找比基准点大的，j找比基准点小的，如果两者都找到了则交换
        while (i <= j) {
            while (i <= j && arr[i][0] < pv) i++;

            while (i <= j && arr[j][0] > pv) j--;

            if (i <= j) swap(arr, i++, j--);
        }
        swap(arr, left, j); // 把基准点放到中间
        return j;
    }

    private static void swap(int[][] arr, int i, int j) {
        if (i == j) return;
        int[] temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```



## [502. IPO](https://leetcode.cn/problems/ipo/)

假设 力扣（LeetCode）即将开始 **IPO** 。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 `k` 个不同的项目。帮助 力扣 设计完成最多 `k` 个不同项目后得到最大总资本的方式。

给你 `n` 个项目。对于每个项目 `i` ，它都有一个纯利润 `profits[i]` ，和启动该项目需要的最小资本 `capital[i]` 。

最初，你的资本为 `w` 。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。

总而言之，从给定项目中选择 **最多** `k` 个不同项目的列表，以 **最大化最终资本** ，并输出最终可获得的最多资本。

答案保证在 32 位有符号整数范围内。

**示例 1：**

```
输入：k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]
输出：4
解释：
由于你的初始资本为 0，你仅可以从 0 号项目开始。
在完成后，你将获得 1 的利润，你的总资本将变为 1。
此时你可以选择开始 1 号或 2 号项目。
由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。
因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。
```

**示例 2：**

```
输入：k = 3, w = 0, profits = [1,2,3], capital = [0,1,2]
输出：6
```

其实此题想出解法并不难，主要是**贪心 + 优先队列（堆）**。由于每完成一个任务都会使得总资金 $w$ 增加或不变。因此对于所选的第 $i $个任务而言，应该在所有「未被选择」且启动资金不超过 $w$ 的所有任务里面选利润最大的。

即求解流程如下：

1. 预处理`profits` 和 `capital` ：对「启动资金`capital` 」进行升序排序，同时也保持`profits` 相对 `capital` 的顺序；
2. 每次决策前，将所有的启动资金不超过 $w$ 的任务加入优先队列（根据利润排序的大根堆），然后从优先队列（根据利润排序的大根堆），将利润累加到 $w$；
3. 循环步骤 2，直到达到 $k$ 个任务，或者队列为空（当前资金不足以选任何任务）。

主要难点还是第一步，如果想要对 `capital` 排序，且`profits` 的相对顺序不变，就需要重新将其放入到数组或集合中，这样势必要new很多对象，且占用空间较大，~~经过前面一道题的铺垫，相信你在此也可以顺利的写出快排了吧~~。看看下面的代码和你实现的一不一样：

```java
class Solution {
    public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {
        sort(capital, profits, 0, profits.length - 1);		// 流程第一步
        PriorityQueue<Integer> q = new PriorityQueue<>((a, b) -> b - a);
        int i = 0;
        while (k-- > 0) {									// 流程第三步
            while (i < capital.length && capital[i] <= w)	// 流程第二步
                q.add(profits[i++]);
            if (q.isEmpty()) return w;
            w += q.poll();
        }
        return w;
    }

    private void sort(int[] sortArr, int[] refArr, int left, int right) {
        if (right <= left) return;
        int p = enhancedPartition(sortArr, refArr, left, right);
        sort(sortArr, refArr, p + 1, right);
        sort(sortArr, refArr, left, p - 1);
    }

    private static int enhancedPartition(int[] sortArr, int[] refArr, int left, int right) {
        swap(sortArr, refArr, left, ThreadLocalRandom.current().nextInt(left, right + 1));
        int pv = sortArr[left]; // 基准点元素的值
        int i = left + 1, j = right; // i找比基准点大的，j找比基准点小的，如果两者都找到了则交换
        while (i <= j) {
            while (i <= j && sortArr[i] < pv) i++;

            while (i <= j && sortArr[j] > pv) j--;

            if (i <= j) swap(sortArr, refArr, i++, j--);
        }
        swap(sortArr, refArr, left, j); // 把基准点放到中间
        return j;
    }

    private static void swap(int[] sortArr, int[] refArr, int i, int j) {
        if (i == j) return;
        int temp = sortArr[i];
        sortArr[i] = sortArr[j];
        sortArr[j] = temp;
        temp = refArr[i];
        refArr[i] = refArr[j];
        refArr[j] = temp;
    }
}
```

据此实现的代码可达42ms，击败98的用户，在内存上也能击败89%的用户

## [373. 查找和最小的 K 对数字](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/)

给定两个以 **非递减顺序排列** 的整数数组 `nums1` 和 `nums2` , 以及一个整数 `k` 。

定义一对值 `(u,v)`，其中第一个元素来自 `nums1`，第二个元素来自 `nums2` 。

请找到和最小的 `k` 个数对 `(u1,v1)`, ` (u2,v2)` ...  `(uk,vk)` 。

**示例 1:**

```
输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
输出: [1,2],[1,4],[1,6]
解释: 返回序列中的前 3 对数：
     [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
```

**示例 2:**

```
输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2
输出: [1,1],[1,1]
解释: 返回序列中的前 2 对数：
     [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]
```

此题与上面的题目就明显不一样了，这个题目中带有了**最小的k个**这样的字眼，那么一个自然的想法就是使用堆，那么在使用堆的时候，一个最简单的方法就是把所有的数字组合都放到堆里，这样我们取出k个数，那么第k个数就是我们要求的，但是这样其实意义并不大，并且在数据量很大的时候内存是支持不了的，那么我们就可以利用题目里给出的条件：**非递减顺序排列**，那么我们就已知了最小的数一定是最开始的数，那么我们就可以先把最开始的数加到堆里，然后不断取出，再添加，这样k次之后堆首就是我们想要的值了。但是有个问题就是我们需要考虑重复的问题。对于重复的问题，我们使用代码中的方法来去重。

```python
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        result = []
        heap = [(nums1[0] + nums2[0], 0, 0)]
        while k > 0:
            k -= 1
            _, i, j = heapq.heappop(heap)
            result.append([nums1[i], nums2[j]])
            if j == 0 and i < len(nums1) - 1:
                heapq.heappush(heap, (nums1[i + 1] + nums2[j], i + 1, j))
            if j < len(nums2) - 1:
                heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))
        return result
```

除了使用堆排序之外，我们还可以使用二分方法来解决这道题，但由于此题需要把k对数字全求出来，因此还是比较繁琐的。

## [1439. 有序矩阵中的第 k 个最小数组和](https://leetcode.cn/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/)

给你一个 `m * n` 的矩阵 `mat`，以及一个整数 `k` ，矩阵中的每一行都以非递减的顺序排列。

你可以从每一行中选出 1 个元素形成一个数组。返回所有可能数组中的第 k 个 **最小** 数组和。

**示例 1：**

```
输入：mat = [[1,3,11],[2,4,6]], k = 5
输出：7
解释：从每一行中选出一个元素，前 k 个和最小的数组分别是：
[1,2], [1,4], [3,2], [3,4], [1,6]。其中第 5 个的和是 7 。  
```

**示例 2：**

```
输入：mat = [[1,3,11],[2,4,6]], k = 9
输出：17
```

**示例 3：**

```
输入：mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7
输出：9
解释：从每一行中选出一个元素，前 k 个和最小的数组分别是：
[1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]。其中第 7 个的和是 9 。 
```

此题实际只是上一题的扩展，将上一题由两个数组扩展为了多个数组，因此我们可以直接使用上一题的思路来解决这道题，但对于去重，我们只能在两个数组里去重，对于多维数组，我们是不好去重的，因此我们将其转换为多个数组，数组与数组之后不断取最小，这样就可以了。

```python
class Solution:
    def kthSmallest(self, mat: List[List[int]], k: int) -> int:
        def merge(nums1, nums2, k):
            heap = [(nums1[0] + nums2[0], 0, 0)]
            result = []
            len1, len2 = len(nums1) - 1, len(nums2) - 1
            while k and heap:
                k -= 1
                val, i, j = heapq.heappop(heap)
                result.append(val)
                if j == 0 and i < len1:
                    heapq.heappush(heap, (nums1[i + 1] + nums2[0], i + 1, 0))
                if j < len2:
                    heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))
            return result
        
        nums = mat[0]
        for row in mat[1:]:
            nums = merge(nums, row, k)
        return nums[k - 1]
```

## [378. 有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/)

给你一个 `n x n` 矩阵 `matrix` ，其中每行和每列元素均按升序排序，找到矩阵中第 `k` 小的元素。
请注意，它是 **排序后** 的第 `k` 小元素，而不是第 `k` 个 **不同** 的元素。

**示例 1：**

```
输入：matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
输出：13
解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13
```

**示例 2：**

```
输入：matrix = [[-5]], k = 1
输出：-5
```

对于此题，与前面的就不太一样了，虽然我们也可以直接将矩阵展平然后再使用前面的方法，但这样并没有使用题目给出的每行和每列元素均按升序排序这个条件，因此我们需要直接对矩阵进行处理，参照前面的[373. 查找和最小的 K 对数字](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/)我们也可以使用堆来做这道题，并且利用矩阵每行升序这个条件，因此参考前面的代码我们可以轻易的写出：

```python
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        heap = [(matrix[0][0], 0, 0)]
        h, w = len(matrix) - 1, len(matrix[0]) - 1
        for _ in range(k - 1):
            _, i, j = heapq.heappop(heap)
            if j == 0 and i < h:
                heapq.heappush(heap, (matrix[i + 1][0], i + 1, 0))
            if j < w:
                heapq.heappush(heap, (matrix[i][j + 1], i, j + 1))
        return heap[0][0]
```

类似的，此题是可以使用二分法的，由于在[373. 查找和最小的 K 对数字](https://leetcode.cn/problems/find-k-pairs-with-smallest-sums/)题中需要求出前k对，因此是比较繁琐的，此题只是要求出第k个，因此实现的代码是相对较少的。

```python
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        def count(mid, matrix):
            i, j = 0, len(matrix[0]) - 1
            num = 0
            while i < len(matrix) and j >= 0:
                if matrix[i][j] <= mid:
                    num += j + 1
                    i += 1
                else:
                    j -= 1
            return num

        left, right = matrix[0][0], matrix[-1][-1]
        while left < right:
            mid = (left + right) // 2
            if count(mid, matrix) < k:
                left = mid + 1
            else:
                right = mid
        return left
```

对于二分的方法，我们使用了每行和每列元素均按升序排序这两个条件，因此其时间复杂度是更优秀的。对于count函数，其是从[240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)得来的，该方法可以以$O(N)$的时间复杂度来搜索二维矩阵（前提是每行和每列元素均按升序排序）。

## [668. 乘法表中第k小的数](https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/)

几乎每一个人都用 [乘法表](https://baike.baidu.com/item/乘法表)。但是你能在乘法表中快速找到第 `k` 小的数字吗？

乘法表是大小为 `m x n` 的一个整数矩阵，其中 `mat[i][j] == i * j`（下标从 **1** 开始）。

给你三个整数 `m`、`n` 和 `k`，请你在大小为 `m x n` 的乘法表中，找出并返回第 `k` 小的数字。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2021/05/02/multtable1-grid.jpg" alt="1" style="zoom:50%;" />

```
输入：m = 3, n = 3, k = 5
输出：3
解释：第 5 小的数字是 3 。
```

**示例 2：**

<img src="https://assets.leetcode.com/uploads/2021/05/02/multtable2-grid.jpg" style="zoom:50%;" />

```
输入：m = 2, n = 3, k = 6
输出：6
解释：第 6 小的数字是 6 。
```

此题与上一题基本一致，只是值不是直接给出的，而是求出来的，但是此题的矩阵长宽是比较大的，直接使用堆的方法是通过不了的，因此只能使用二分法了。

```python
class Solution:
    def findKthNumber(self, m: int, n: int, k: int) -> int:
        def count(x, m, n):
            return sum(min(x // i, n) for i in range(1, m + 1))
        
        left, right = 1, m * n
        while left < right:
            mid = (left + right) // 2
            if count(mid, m, n) < k:
                left = mid + 1
            else:
                right = mid
        return left
```

## [1918. 第 K 小的子数组和(付费题目)](https://leetcode.cn/problems/kth-smallest-subarray-sum)

给你一个 长度为 `n` 的整型数组 `nums` 和一个数值 `k` ，返回 **第 `k` 小的子数组和。**

**子数组** 是指数组中一个 **非空** 且不间断的子序列。 **子数组和** 则指子数组中所有元素的和。

**示例 1:**

```
输入: nums = [2,1,3], k = 4
输出: 3
解释: [2,1,3] 的子数组为：
- [2] 和为 2
- [1] 和为 1
- [3] 和为 3
- [2,1] 和为 3
- [1,3] 和为 4
- [2,1,3] 和为 6 
最小子数组和的升序排序为 1, 2, 3, 3, 4, 6。 第 4 小的子数组和为 3 。
```

**示例 2：**

```
输入：nums = [3,3,5,5], k = 7
输出：10
解释：[3,3,5,5] 的子数组为：
- [3] 和为 3
- [3] 和为 3
- [5] 和为 5
- [5] 和为 5
- [3,3] 和为 6
- [3,5] 和为 8
- [5,5] 和为 10
- [3,3,5], 和为 11
- [3,5,5] 和为 13
- [3,3,5,5] 和为 16
最小子数组和的升序排序为 3, 3, 5, 5, 6, 8, 10, 11, 13, 16。第 7 小的子数组和为 10 。
```

对于此题，由于求的是子数组和，其求解的时间复杂度是$O(N^2)$，我们如果仍然使用堆的方法来解决，无疑会超时，因此我们还是选用二分法来解决这道题。二分法的上届为sum(nums)，下届为min(nums)。而判断是第几大子数组和时，我们可以使用滑动窗口来求解。

```python
class Solution:
    def kthSmallestSubarraySum(self, nums: List[int], k: int) -> int:
        def count(sum_limit):
            sum = left = 0
            cnt = 0
            for right, x in enumerate(nums):
                sum += x
                while sum > sum_limit:
                    sum -= nums[left]
                    left += 1
                cnt += right - left + 1
            return cnt

        left, right = min(nums), sum(nums)
        while left < right:
            mid = (left + right) // 2
            if count(mid) < k:
                left = mid + 1
            else:
                right = mid
        return left
```



## [2386. 找出数组的第 K 大和](https://leetcode.cn/problems/find-the-k-sum-of-an-array/)

给你一个整数数组 `nums` 和一个 **正** 整数 `k` 。你可以选择数组的任一 **子序列** 并且对其全部元素求和。

数组的 **第 k 大和** 定义为：可以获得的第 `k` 个 **最大** 子序列和（子序列和允许出现重复）

返回数组的 **第 k 大和** 。

子序列是一个可以由其他数组删除某些或不删除元素派生而来的数组，且派生过程不改变剩余元素的顺序。

**注意：**空子序列的和视作 `0` 。

**示例 1：**

```
输入：nums = [2,4,-2], k = 5
输出：2
解释：所有可能获得的子序列和列出如下，按递减顺序排列：
6、4、4、2、2、0、0、-2
数组的第 5 大和是 2 。
```

**示例 2：**

```
输入：nums = [1,-2,3,4,-10,12], k = 16
输出：10
解释：数组的第 16 大和是 10 。
```

此题有点超模。对于此类型来说，如果nums都是正数，则对于每个子序列，可以用“换一个“和“加一个“两种办法生成下一个序列，但nums里有负数，如何把负数转化成正数，正确做法不太容易直接想到，也比较难证明。

转换如下：

- 计算$ nums$中所有非负数的和，记作$ sum$。

- $nums$的任意一个子序列的元素和，都等价于从$ sum$中减去某些非负数 / 加上某些负数得到。
- 注意到，「减去非负数」和「加上负数」都相当于减去 $∣nums[i]∣$。
- $sum$ 减去的数越小，$nums$的子序列和就越大。

对于此题，我们可以使用二分法进行搜索，在转换后，二分的上下界分布为0和$sum(∣nums[i]∣)$，而搜索的值我们可以使用深度优先进行递归搜索，搜索其是第几大和。

```python
class Solution:
    def kSum(self, nums: List[int], k: int) -> int:
        def dfs(i: int, local_sum: int, k: int, sum_limit: int) -> None:
            nonlocal cnt
            if cnt == k or i == len(nums) or local_sum + nums[i] > sum_limit:
                return
            cnt += 1  # s + nums[i] <= sum_limit
            dfs(i + 1, local_sum + nums[i], k, sum_limit)  # 选
            dfs(i + 1, local_sum, k, sum_limit)  # 不选

        s = 0
        for i, x in enumerate(nums):
            if x >= 0:
                s += x
            else:
                nums[i] = -x
        nums.sort()

        left, right = 0, sum(nums)
        while left < right:
            cnt = 1
            mid = (left + right) // 2
            dfs(0, 0, k, mid)
            if cnt < k:
                left = mid + 1
            else:
                right = mid
        return s - left
```

除此之外，我们还可以使用堆的方法来解决这道题。在我们将其进行转换后，我们向堆里添加元素时，可能是"换一个"也可能是"加一个"，因此我们可以写出以下代码：

```python
class Solution:
    def kSum(self, nums: List[int], k: int) -> int:
        sum = 0
        for i, x in enumerate(nums):
            if x >= 0:
                sum += x
            else:
                nums[i] = -x
        nums.sort()

        h = [(0, 0)]  # 空子序列
        for _ in range(k - 1):
            s, i = heapq.heappop(h)
            if i < len(nums):
                # 在子序列的末尾添加 nums[i]
                heapq.heappush(h, (s + nums[i], i + 1))  # 下一个添加/替换的元素下标为 i+1
                if i > 0:  # 替换子序列的末尾元素为 nums[i]
                    heapq.heappush(h, (s + nums[i] - nums[i - 1], i + 1))
        return sum - h[0][0]
```



# 贡献法：

## [907. 子数组的最小值之和](https://leetcode.cn/problems/sum-of-subarray-minimums/)

给定一个整数数组 `arr`，找到 `min(b)` 的总和，其中 `b` 的范围为 `arr` 的每个（连续）子数组。

由于答案可能很大，因此 **返回答案模 `10^9 + 7`** 。

**示例 1：**

```
输入：arr = [3,1,2,4]
输出：17
解释：
子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 
最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。
```

**示例 2：**

```
输入：arr = [11,81,94,43,3]
输出：444
```

此题的解法是属于贡献法，如果没有接触过这种方法，可能很难下手，只是暴力循环了，时间复杂度达到了$O(N^2)$。对于贡献法，我们计算以 arr[i] 为最小值的子数组的个数，这样把所有的i遍历一遍，就可以在$O(N)$的时间复杂度里解决这道题，

一般地，设 $arr[i]$对应的边界为**开区间** $(L,R)$，由于子数组必须包含 $arr[i]$：

- 子数组的左端点可以是$ L+1,L+2,⋯ ,i$，共有$ i−L$ 个；
- 子数组的右端点可以是$ i,i+1,⋯ ,R−1$，共有 $R−i$个。

因此，**在$ arr$不含重复元素的前提下**，根据**乘法原理**，我们可以得出如下结论：

以 $arr[i]$ 为最小值的子数组的个数为$ (i−L)⋅(R−i)$，对答案的贡献为 $arr[i]⋅(i−L)⋅(R−i)$。

对于我们计算其边界条件，我们可以使用一个单调递减的单调栈来计算。

```python
class Solution:
    def sumSubarrayMins(self, arr: List[int]) -> int:
        arr.append(-1)
        ans, st = 0, [-1]  # 哨兵
        for r, x in enumerate(arr):
            # 也可以 while arr[st[-1]] > x，效率略高一点
            while arr[st[-1]] > x:
                l = st.pop()
                ans += arr[l] * (l - st[-1]) * (r - l)  # 累加贡献
            st.append(r)
        return ans % (10 ** 9 + 7)
```

由于本题规定arr数组全为正数，因此在我们可以将arr的结尾添加一个负数，这样在循环过程中，当到达最后一个数字时，就可以把栈里的数字全部弹出并计算，而不用我们手动弹出了。同时我们的单调栈里也加入了一个哨兵索引，这也是为了计算的方便。

## [2104. 子数组范围和](https://leetcode.cn/problems/sum-of-subarray-ranges/)

给你一个整数数组 `nums` 。`nums` 中，子数组的 **范围** 是子数组中最大元素和最小元素的差值。

返回 `nums` 中 **所有** 子数组范围的 **和** *。*

子数组是数组中一个连续 **非空** 的元素序列。

**示例 1：**

```
输入：nums = [1,2,3]
输出：4
解释：nums 的 6 个子数组如下所示：
[1]，范围 = 最大 - 最小 = 1 - 1 = 0 
[2]，范围 = 2 - 2 = 0
[3]，范围 = 3 - 3 = 0
[1,2]，范围 = 2 - 1 = 1
[2,3]，范围 = 3 - 2 = 1
[1,2,3]，范围 = 3 - 1 = 2
所有范围的和是 0 + 0 + 0 + 1 + 1 + 2 = 4
```

**示例 2：**

```
输入：nums = [1,3,3]
输出：4
解释：nums 的 6 个子数组如下所示：
[1]，范围 = 最大 - 最小 = 1 - 1 = 0
[3]，范围 = 3 - 3 = 0
[3]，范围 = 3 - 3 = 0
[1,3]，范围 = 3 - 1 = 2
[3,3]，范围 = 3 - 3 = 0
[1,3,3]，范围 = 3 - 1 = 2
所有范围的和是 0 + 0 + 0 + 2 + 0 + 2 = 4
```

此题实际为上一题的扩展，对于此题的结果，实际是**子数组的最大值之和 - 子数组的最小值之和**，因此我们可以按照上一题的方法来求出子数组的最大值之和和最小值之和，然后两者相减得到答案，当在实际代码中，我们可以同时进行：

```python
class Solution:
    def subArrayRanges(self, nums: List[int]) -> int:
        stack_min, stack_max, ans = [-1], [-1], 0
        for r, num in enumerate(nums):
            while len(stack_min) > 1 and nums[stack_min[-1]] > num:
                l = stack_min.pop()
                ans -= nums[l] * (r - l) * (l - stack_min[-1])
            while len(stack_max) > 1 and nums[stack_max[-1]] < num:
                l = stack_max.pop()
                ans += nums[l] * (r - l) * (l - stack_max[-1])
            stack_max.append(r)
            stack_min.append(r)
        r = len(nums)
        while len(stack_min) > 1:
            l = stack_min.pop()
            ans -= nums[l] * (r - l) * (l - stack_min[-1])
        while len(stack_max) > 1:
            l = stack_max.pop()
            ans += nums[l] * (r - l) * (l - stack_max[-1])
        return ans
```

这里，我们就没有在数组后面添加一个负数了，这是因为我们即要求最大，也要求最小，因此我们选择手动弹出栈。

## [891. 子序列宽度之和](https://leetcode.cn/problems/sum-of-subsequence-widths/)

一个序列的 **宽度** 定义为该序列中最大元素和最小元素的差值。

给你一个整数数组 `nums` ，返回 `nums` 的所有非空 **子序列** 的 **宽度之和** 。由于答案可能非常大，请返回对 `10^9 + 7` **取余** 后的结果。

**子序列** 定义为从一个数组里删除一些（或者不删除）元素，但不改变剩下元素的顺序得到的数组。例如，`[3,6,2,7]` 就是数组 `[0,3,1,6,2,2,7]` 的一个子序列。

**示例 1：**

```
输入：nums = [2,1,3]
输出：6
解释：子序列为 [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3] 。
相应的宽度是 0, 0, 0, 1, 1, 2, 2 。
宽度之和是 6 。
```

**示例 2：**

```
输入：nums = [2]
输出：0
```

此题从上一题的子数组变为了子序列，因此对于元素的顺序我们就并不关心了。我们同样还是使用贡献法的思路，首先我们将 nums 数组排序。对于每一个数 nums[i] 来说，它可以做最大值也可以做最小值。

当 nums[i] 为子序列的最大值时，计算该子序列的宽度时，需要用 nums[i] 减去当前子序列的最小值。它一共可以当 $2^i $个子序列中的最大值，所以它会被加上$ 2^i $次。

当 nums[i] 为子序列的最小值时，计算该子序列的宽度时，需要用子序列的最大值减去 nums[i]。它一共可以当 $2^{(n - 1 - i)} $个子序列中的最小值，所以它会被减去 $2^{(n - 1 - i)} $次。

所以 nums[i] 对结果的贡献为 `(2^i - 2^(n - 1 - i)) * nums[i]`。

```python
class Solution:
    def sumSubseqWidths(self, nums: List[int]) -> int:
        nums.sort()
        pow2 = [1] * len(nums)
        for i in range(1, len(nums)):
            pow2[i] = pow2[i - 1] * 2 % 1000000007
        ans = 0
        length = len(nums)
        for i, num in enumerate(nums):
            ans += (pow2[i] - pow2[length - 1 - i]) * num
        return ans % (10**9 + 7)
```

# 前缀和系列

## [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回该数组中和为 `k` 的子数组的个数 。

子数组是数组中元素的连续非空序列。

**示例 1：**

```
输入：nums = [1,1,1], k = 2
输出：2
```

**示例 2：**

```
输入：nums = [1,2,3], k = 3
输出：2
```

普通双重循环的方法就不介绍了，由于此题数组还可能为负数，因此滑动窗口不好做。此题使用前缀和的方法可以解决这个问题，因为我们需要找到和为k的连续子数组的个数。通过计算前缀和，我们可以将问题转化为求解两个前缀和之差等于k的情况。

假设数组的前缀和数组为prefixSum，其中prefixSum[i]表示从数组起始位置到第i个位置的元素之和。那么对于任意的两个下标i和j（i < j），如果prefixSum[j] - prefixSum[i] = k，即从第i个位置到第j个位置的元素之和等于k，那么说明从第i+1个位置到第j个位置的连续子数组的和为k。

通过遍历数组，计算每个位置的前缀和，并使用一个哈希表来存储每个前缀和出现的次数。在遍历的过程中，我们检查是否存在prefixSum[j] - k的前缀和，如果存在，说明从某个位置到当前位置的连续子数组的和为k，我们将对应的次数累加到结果中。

这样，通过遍历一次数组，我们可以统计出和为k的连续子数组的个数，并且时间复杂度为$O(n)$，其中n为数组的长度。

```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        dict = defaultdict(int)
        dict[0] = 1
        result = 0
        pre_sum = 0
        for num in nums:
            pre_sum += num
            result += dict.get(pre_sum - k, 0)
            dict[pre_sum] += 1
        return result
```

## [974. 和可被 K 整除的子数组](https://leetcode.cn/problems/subarray-sums-divisible-by-k/)

给定一个整数数组 `nums` 和一个整数 `k` ，返回其中元素之和可被 `k` 整除的（连续、非空） **子数组** 的数目。

**子数组** 是数组的 **连续** 部分。

**示例 1：**

```
输入：nums = [4,5,0,-2,-3,1], k = 5
输出：7
解释：
有 7 个子数组满足其元素之和可被 k = 5 整除：
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
```

**示例 2:**

```
输入: nums = [5], k = 9
输出: 0
```

此题与上一题很像，只不过要求的子数组满足的条件是可以被`k`整除。那么根据上面的代码我们可以写出以下代码：

```python
class Solution:
    def subarraysDivByK(self, nums: List[int], k: int) -> int:
        dict = defaultdict(int)
        dict[0] = 1
        pre_sum = 0
        ans = 0
        for num in nums:
            pre_sum += num
            ans += dict.get((pre_sum - k) % k, 0)
            dict[pre_sum % k] += 1
        return ans
```

## [523. 连续的子数组和](https://leetcode.cn/problems/continuous-subarray-sum/)

给你一个整数数组 `nums` 和一个整数 `k` ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：

- 子数组大小 **至少为 2** ，且
- 子数组元素总和为 `k` 的倍数。

如果存在，返回 `true` ；否则，返回 `false` 。

如果存在一个整数 `n` ，令整数 `x` 符合 `x = n * k` ，则称 `x` 是 `k` 的一个倍数。`0` 始终视为 `k` 的一个倍数。

**示例 1：**

```
输入：nums = [23,2,4,6,7], k = 6
输出：true
解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。
```

**示例 2：**

```
输入：nums = [23,2,6,4,7], k = 6
输出：true
解释：[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。 
42 是 6 的倍数，因为 42 = 7 * 6 且 7 是一个整数。
```

此题就是在上一题的基础上增加了一个限制，要求子数组的长度至少为2，但返回条件简单了，那么我们可以将字典中的值从个数更改为索引，这样就可以得到正确的结果了。

```python
class Solution:
    def checkSubarraySum(self, nums: List[int], k: int) -> bool:
        if len(nums) < 2: return False
        dict = {0: -1}
        pre_sum = 0
        for i, num in enumerate(nums):
            pre_sum += num
            j = dict.get((pre_sum - k) % k, -2)
            if j != -2 and i - j > 1:
                return True
            if pre_sum % k not in dict:
                dict[pre_sum % k] = i
        return False
```

## [1590. 使数组和能被 P 整除](https://leetcode.cn/problems/make-sum-divisible-by-p/)

给你一个正整数数组 `nums`，请你移除 **最短** 子数组（可以为 **空**），使得剩余元素的 **和** 能被 `p` 整除。 **不允许** 将整个数组都移除。

请你返回你需要移除的最短子数组的长度，如果无法满足题目要求，返回 `-1` 。

**子数组** 定义为原数组中连续的一组元素。

**示例 1：**

```
输入：nums = [3,1,4,2], p = 6
输出：1
解释：nums 中元素和为 10，不能被 p 整除。我们可以移除子数组 [4] ，剩余元素的和为 6 。
```

**示例 2：**

```
输入：nums = [6,3,5,2], p = 9
输出：2
解释：我们无法移除任何一个元素使得和被 9 整除，最优方案是移除子数组 [5,2] ，剩余元素为 [6,3]，和为 9 。
```

此题表面上是求移除子数组后剩余数组的和可以被`p`整除，那么我们可以转换一下思路。剩余数组的和可以被`p`整除，那么原始数组对`p`取模与移除的数组对`p`取模必定是相同的，因此我们要求的就转换成了找到最短的子数组，该子数组要求对`p`取模后与整个数组对`p`取模相同，这就基本等同于上一题了。那么根据上面的代码，我们可以写出：

```python
class Solution:
    def minSubarray(self, nums: List[int], p: int) -> int:
        s = sum(nums) % p
        if s == 0: return 0
        dict = {0: -1}
        pre_sum = 0
        ans = len(nums)
        for i, num in enumerate(nums):
            pre_sum += num
            j = dict.get((pre_sum - s) % p, -2)
            if j != -2:
                ans = min(ans, i - j)
            dict[pre_sum % p] = i
        return ans if ans < len(nums) else -1
```

## [1477. 找两个和为目标值且不重叠的子数组](https://leetcode.cn/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/)

给你一个整数数组 `arr` 和一个整数值 `target` 。

请你在 `arr` 中找 **两个互不重叠的子数组** 且它们的和都等于 `target` 。可能会有多种方案，请你返回满足要求的两个子数组长度和的 **最小值** 。

请返回满足要求的最小长度和，如果无法找到这样的两个子数组，请返回 **-1** 。

**示例 1：**

```
输入：arr = [3,2,2,4,3], target = 3
输出：2
解释：只有两个子数组和为 3 （[3] 和 [3]）。它们的长度和为 2 。
```

**示例 2：**

```
输入：arr = [7,3,4,7], target = 7
输出：2
解释：尽管我们有 3 个互不重叠的子数组和为 7 （[7], [3,4] 和 [7]），但我们会选择第一个和第三个子数组，因为它们的长度和 2 是最小值。
```

**示例 3：**

```
输入：arr = [4,3,2,6,2,3,4], target = 6
输出：-1
解释：我们只有一个和为 6 的子数组。
```

对于此题，其相比[560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)题而言多了一个不重叠且长度最小这两个条件，因此我们就需要对其长度进行记录，我们可以使用一个dp[i]数组来表示从0开始到i的位置和为target的最短子数组的长度，那么当我们找到一个新的和为target的子数组的时候，我们就可以进行比较求最小值了。

```python
class Solution:
    def minSumOfLengths(self, arr: List[int], target: int) -> int:
        n = len(arr)
        dp = [n + 1] * (n + 1)
        ans = n + 1
        dict = {0:-1}
        presum = 0
        for i, num in enumerate(arr):
            presum += num
            dict[presum] = i
            if (j := dict.get(presum - target, -2)) > -2:
                dp[i + 1] = min(dp[i], i - j)
                ans = min(ans, dp[j + 1] + i - j)
            else :
                dp[i + 1] = dp[i]
        return ans if ans < n + 1 else -1
```

由于此题的数组全为正数，因此我们也可以使用滑动窗口来求每一个和为target的子数组，这样可以少去一个字典的空间占用。

## [2555. 两个线段获得的最多奖品](https://leetcode.cn/problems/maximize-win-from-two-segments/)

在 **X轴** 上有一些奖品。给你一个整数数组 `prizePositions` ，它按照 **非递减** 顺序排列，其中 `prizePositions[i]` 是第 `i` 件奖品的位置。数轴上一个位置可能会有多件奖品。再给你一个整数 `k` 。

你可以选择两个端点为整数的线段。每个线段的长度都必须是 `k` 。你可以获得位置在任一线段上的所有奖品（包括线段的两个端点）。注意，两个线段可能会有相交。

- 比方说 `k = 2` ，你可以选择线段 `[1, 3]` 和 `[2, 4]` ，你可以获得满足 `1 <= prizePositions[i] <= 3` 或者 `2 <= prizePositions[i] <= 4` 的所有奖品 i 。

请你返回在选择两个最优线段的前提下，可以获得的 **最多** 奖品数目。

**示例 1：**

```
输入：prizePositions = [1,1,2,2,3,3,5], k = 2
输出：7
解释：这个例子中，你可以选择线段 [1, 3] 和 [3, 5] ，获得 7 个奖品。
```

**示例 2：**

```
输入：prizePositions = [1,2,3,4], k = 0
输出：2
解释：这个例子中，一个选择是选择线段 [3, 3] 和 [4, 4] ，获得 2 个奖品。
```

此题的思想与上一题是类似的，都是先求到当前位置时刻的最优值，然后当遇到新的满足条件的值的时候，我们求解答案，然后不断循环。只是此题多了一个可以重叠的条件，但我们求解的过程中是用不到的。同样的我们还是需要使用一个dp[i]数组来表示从0-i的线段长度为k的最多奖品数目，那么当我们更新到下一时刻时，我们就可以求和这个线段与前一个线段来得到最大值了：

```python
class Solution:
    def maximizeWin(self, prizePositions: List[int], k: int) -> int:
        def binary_search_left(prizePositions, left, right, target):
            while left < right:
                mid = (left + right) // 2
                if prizePositions[mid] < target:
                    left = mid + 1
                else:
                    right = mid
            return left
        
        n = len(prizePositions)
        if k * 2 + 1 >= prizePositions[-1] - prizePositions[0]:
            return n
        
        ans = left = right = 0
        dp = [0] * (n + 1)
        for right, p in enumerate(prizePositions):
            if right == 0 or p != prizePositions[right - 1]:
                left = binary_search_left(prizePositions, left, right, p - k)
            ans = max(ans, dp[left] + right - left + 1)
            dp[right + 1] = max(dp[right], right - left + 1)
        return ans
```

同样的，由于此题的数组均为正数，我们同样可以使用滑动窗口（最大最小值之差为k）来求这道题而不是二分法，这样可以进一步降低时间复杂度到$O(N)$。

```python
class Solution:
    def maximizeWin(self, prizePositions: List[int], k: int) -> int:
        n = len(prizePositions)
        if k * 2 + 1 >= prizePositions[-1] - prizePositions[0]:
            return n
        dp = [0] * (n + 1)
        ans = left = 0
        for right, p in enumerate(prizePositions):
            while p - prizePositions[left] > k:
                left += 1
            ans = max(ans, right - left + 1 + dp[left])
            dp[right + 1] = max(dp[right], right - left + 1)
        return ans
```

## [1546. 和为目标值且不重叠的非空子数组的最大数目](https://leetcode.cn/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/)

给你一个数组 `nums` 和一个整数 `target` 。

请你返回 **非空不重叠** 子数组的最大数目，且每个子数组中数字和都为 `target` 。

**示例 1：**

```
输入：nums = [1,1,1,1,1], target = 2
输出：2
解释：总共有 2 个不重叠子数组（加粗数字表示） [1,1,1,1,1] ，它们的和为目标值 2 。
```

**示例 2：**

```
输入：nums = [-1,3,5,1,4,2,-9], target = 6
输出：2
解释：总共有 3 个子数组和为 6 。
([5,1], [4,2], [3,5,1,4,2,-9]) 但只有前 2 个是不重叠的。
```

**示例 3：**

```
输入：nums = [-2,6,6,3,5,4,1,2,8], target = 10
输出：3
```

此题是在上一题上做的扩展，但其实扩展后反而变简单了，对于这种类型，其很像经典的贪心算法中的活动安排问题，我们只需找最先结束的即可，而在此题中，我们只需找最先子数组和为target的然后不断累加即可：

```python
class Solution:
    def maxNonOverlapping(self, nums: List[int], target: int) -> int:
        presum = 0
        dict = {0:-1}
        count = 0
        end = -1
        for i, num in enumerate(nums):
            presum += num
            if dict.get(presum - target, -2) >= end:
                count += 1
                end = i
            dict[presum] = i
        return count
```

## [1031. 两个非重叠子数组的最大和](https://leetcode.cn/problems/maximum-sum-of-two-non-overlapping-subarrays/)

给你一个整数数组 `nums` 和两个整数 `firstLen` 和 `secondLen`，请你找出并返回两个非重叠 **子数组** 中元素的最大和*，*长度分别为 `firstLen` 和 `secondLen` 。

长度为 `firstLen` 的子数组可以出现在长为 `secondLen` 的子数组之前或之后，但二者必须是不重叠的。

子数组是数组的一个 **连续** 部分。

**示例 1：**

```
输入：nums = [0,6,5,2,2,5,1,9,4], firstLen = 1, secondLen = 2
输出：20
解释：子数组的一种选择中，[9] 长度为 1，[6,5] 长度为 2。
```

**示例 2：**

```
输入：nums = [3,8,1,3,2,1,8,9,0], firstLen = 3, secondLen = 2
输出：29
解释：子数组的一种选择中，[3,8,1] 长度为 3，[8,9] 长度为 2。
```

**示例 3：**

```
输入：nums = [2,1,5,6,0,9,5,0,3,8], firstLen = 4, secondLen = 3
输出：31
解释：子数组的一种选择中，[5,6,0,9] 长度为 4，[0,3,8] 长度为 3。
```

此题与[1477. 找两个和为目标值且不重叠的子数组](https://leetcode.cn/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/)的差别是此题求的是两个不重叠子数组的最大值之和，但这两道题（或者说同样的求两个不重叠元素的一些值的时候）的思想是一样的，基本思想都是先求到当前位置时刻的最优值，然后当遇到新的满足条件的值的时候，我们求解答案，然后不断循环。

在这一题中，我们的两个子数组的长度的固定的，但前后位置是不定的，因此我们需要使用两个值来标记当前时刻的最优值，一个是firstLen在前，一个firstLen在后。

```python
class Solution:
    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:
        nums.insert(0, 0)
        n = len(nums)
        for i in range(2, n):
            nums[i] += nums[i - 1]
        result = first = second = 0
        for i in range(firstLen + secondLen, n):
            first = max(first, nums[i - secondLen] - nums[i - firstLen - secondLen])
            second = max(second, nums[i - firstLen] - nums[i - firstLen - secondLen])
            result = max(result, first + nums[i] - nums[i - secondLen], second + nums[i] - nums[i - firstLen])
        return result
```

## [525. 连续数组](https://leetcode.cn/problems/contiguous-array/)

给定一个二进制数组 `nums` , 找到含有相同数量的 `0` 和 `1` 的最长连续子数组，并返回该子数组的长度。

**示例 1:**

```
输入: nums = [0,1]
输出: 2
说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。
```

**示例 2:**

```
输入: nums = [0,1,0]
输出: 2
说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。
```

此题我们同样可以使用前缀和+哈希表来完成。我们可以使用一个计数器来计数从0开始到当前位置1和0出现的相对次数，并把它添加到哈希表中，这样如果有两次都出现了相同的1和0的相对次数，那么两者的索引直接就是1和0出现相同的次数的地方。我们可以求最大的索引差，来得到答案。

```python
class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        dict = defaultdict(list)
        dict[0].append(0)
        count = 0
        for i, num in enumerate(nums):
            count += num * 2 - 1
            # 等价于count += 1 if num == 1 else -1
            dict[count].append(i + 1)
        max_len = 0
        for val in dict.values():
            if val[-1] - val[0] > max_len:
                max_len = val[-1] - val[0]
        return max_len
```

## [面试题 17.05. 字母与数字](https://leetcode.cn/problems/find-longest-subarray-lcci/)

给定一个放有字母和数字的数组，找到最长的子数组，且包含的字母和数字的个数相同。

返回该子数组，若存在多个最长子数组，返回左端点下标值最小的子数组。若不存在这样的数组，返回一个空数组。

**示例 1:**

```
输入: ["A","1","B","C","D","2","3","4","E","5","F","G","6","7","H","I","J","K","L","M"]

输出: ["A","1","B","C","D","2","3","4","E","5","F","G","6","7"]
```

**示例 2:**

```
输入: ["A","A"]

输出: []
```

此题如果读懂题意的话实际只是上一题的简单变形，仍然是统计两个不同类型相同的数目，那么我们可以套用上一题的代码：

```python
class Solution:
    def findLongestSubarray(self, array: List[str]) -> List[str]:
        dict = defaultdict(list)
        dict[0].append(0)
        count = 0
        for i in range(len(array)):
            count += 1 if array[i][0].isdigit() else -1
            dict[count].append(i + 1)
        max_len = 0
        start = 0
        for val in dict.values():
            if val[-1] - val[0] > max_len:
                max_len = val[-1] - val[0]
                start = val[0]
        return array[start:start + max_len]
```

# 股票系列

## [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

**示例 1：**

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**示例 2：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

此题只是求最大的差值，很简单，实现代码如下：

```java
class Solution {
    public int maxProfit(int[] prices) {
        int max_profit = 0;
        int min_price = Integer.MAX_VALUE;
        for (int price : prices) {
            min_price = Math.min(min_price, price);					// 求得最小值
            max_profit = Math.max(max_profit, price - min_price);	// 求得最大差值
        }
        return max_profit;
    }
}
```

## [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 *你能获得的 **最大** 利润* 。

**示例 1：**

```
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
     总利润为 4 + 3 = 7 。
```

**示例 2：**

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     总利润为 4 。
```

**示例 3：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
```

此题既然可以当天买当天卖，且无手续费，那么我不管怎么样每天都买，如果第二天亏了，那就当天卖了，并不影响，只要第二天赚了，那就可以了，因此实现代码也比较容易：

```java
class Solution {
    public int maxProfit(int[] prices) {
        int max_profit = 0;
        for (int i = 1; i < prices.length; i++) {
            if (prices[i] > prices[i - 1])
                max_profit += (prices[i] - prices[i - 1]);		// 第二天赚了就加钱
        }
        return max_profit;
    }
}
```

对于此题，上面的解法就已经够了，但如果想更进一步的探讨一下其更为一般的解法，我们可以使用动态规划了。这个还是不太好想的，因为我们需要将买入和卖出分别建立一个动态规划数组，这样才能不断递推。对于初始值，我们可以令买入为负无穷，卖出为0，这样迭代第一次的时候就是正确的。迭代公式如下：

- $buy = max(buy, sell - price) $

- $sell = max(sell, buy + price)$

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        buy = float('-inf')
        sell = 0
        for price in prices:
            buy = max(buy, sell-price)
            sell = max(sell, buy+price)
        return sell
```

## [714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

给定一个整数数组 `prices`，其中 `prices[i]`表示第 `i` 天的股票价格 ；整数 `fee` 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

**示例 1：**

```
输入：prices = [1, 3, 2, 8, 4, 9], fee = 2
输出：8
解释：能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8
```

**示例 2：**

```
输入：prices = [1,3,7,5,10,3], fee = 3
输出：6
```

此题在上面的基础上增加了手续费，因此就不能随心所欲的买卖股票了，那就需要使用其他的办法了。而对于这种具有时序关系的题目，一个很自然的想法就是动态规划，但这个还有点难，不太好想，需要将买入和卖出分别建立一个动态规划数组，在初始状态时无法卖出，因此卖出的值为0，买入的值为-prices[0]，动态规划迭代公式为见下面代码。

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int[] sell = new int[prices.length];
        int[] buy = new int[prices.length];
        buy[0] = -prices[0];
        for (int i = 1; i < prices.length; i++) {
            buy[i] = Math.max(buy[i - 1], sell[i - 1] - prices[i]);
            sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i] - fee);
        }
        return sell[sell.length - 1];
    }
}
```

化简后可以使用以下代码实现，可以证明使用本次的buy计算，不影响正确性（仔细想想）。

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int sell = 0, buy = -prices[0];
        for (int i = 1; i < prices.length; i++) {
            buy = Math.max(buy, sell - prices[i]);
            sell = Math.max(sell, buy + prices[i] - fee);
        }
        return sell;
    }
}
```

其实回想起来，上一题也可以使用动态规划，但是仔细想一想，上一题使用贪心算法就已经可以解决了，就犯不着再使用动态规划了，而此题贪心算法是无法解决的，因此使用动态规划。下面的题目也是同样，无法使用贪心算法，只能使用动态规划来解决了。

## [309. 买卖股票的最佳时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

给定一个整数数组`prices`，其中第 `prices[i]` 表示第 `*i*` 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

```
输入: prices = [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

**示例 2:**

```
输入: prices = [1]
输出: 0
```

此题相比上一题少了手续费（其实增加上也无所谓），而增加了冷冻期，即卖完后第二天无法买入，因此在使用动态规划的时候，判断买入的时候要从前两天的地方判断，而卖出则不变，但注意其初始条件要从第三天开始了。实现代码如下：

```java
class Solution {
    public int maxProfit(int[] prices) {
        if (prices.length == 1) return 0;
        int[] sell = new int[prices.length];
        int[] buy = new int[prices.length];
        buy[0] = -prices[0];
        buy[1] = Math.max(buy[0], -prices[1]);
        sell[1] = Math.max(sell[0], buy[0] + prices[1]);
        for (int i = 2; i < prices.length; i++) {
            buy[i] = Math.max(buy[i - 1], sell[i - 2] - prices[i]);
            sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]);
        }
        return sell[sell.length - 1];
    }
}
```

此题虽然也可以继续化简，不再使用一个$O(N)$的空间存储sell和buy数组，但意义不大。

## [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

```
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```

**示例 2：**

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3：**

```
输入：prices = [7,6,4,3,1] 
输出：0 
解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
```

**示例 4：**

```
输入：prices = [1]
输出：0
```

其实经过前面两道题的学习，对于不限次数的购买其实我们已经知道其递推公式了，但是当限制次数后，我们就不能再使用前面的递推公式了，我们需要更进一步，将其拆分开来。

前面的递推公式相当于是

- $buy = max(buy, sell - price) $

- $sell = max(sell, buy + price)$

由于并不限次数，因此每次更新buy的时候，都可以使用sell-price来比较，但当限制次数时，我们就得把不同的buy分开，这时递推就稍微有些变换，可以看以下代码。

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        buy1 = buy2 = float('-inf')
        sell1 = sell2 = 0
        for price in prices:
            buy1 = max(buy1, -price)
            sell1 = max(sell1, buy1+price)
            buy2 = max(buy2, sell1-price)
            sell2 = max(sell2, buy2+price)
        return sell2
```

## [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

给你一个整数数组 `prices` 和一个整数 `k` ，其中 `prices[i]` 是某支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 `k` 笔交易。也就是说，你最多可以买 `k` 次，卖 `k` 次。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1：**

```
输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
```

**示例 2：**

```
输入：k = 2, prices = [3,2,6,5,0,3]
输出：7
解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
```

此题就是在上一题的扩充，只是将上一题的buy与sell建立为数组即可，但仔细观察上一题buy1的递推公式与其他的稍有不同，因此我们可以把sell多扩充一个位置，这个位置只放0，这样就统一起来了。

```python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        if not prices: return 0
        buy = [float('-inf')] * k
        sell = [0] * (k+1)
        for p in prices:
            for i in range(k):
                buy[i] = max(buy[i], sell[i] - p)
                sell[i+1] = max(sell[i+1], buy[i] + p)
        return sell[-1]
```

# DP（选择问题）

## [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**示例 1：**

```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

**示例 2：**

```
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

这道题目是要找是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。那么只要找到集合里能够出现 $sum / 2$ 的子集总和，就算是可以分割成两个相同元素和子集了。

这道题目初步看，可以用回溯法解决，即每次判断数字是分割到第一个桶还是第二个桶。但是实际使用回溯法做的时候，会超时，无法通过（通过一些优化或许可以）。因此我们需要想别的办法，由于我们只需要分成两部分，因此我们可以将其视为一个选择问题，比如说我们要从数组中选择一些数字，使其和为$sum / 2$，那么这样就很像0-1背包问题了，我们就可以使用动态规划的思路来解答这道题。

对于dp数组的定义，我们可以定义$dp[j]=True$表示和为$j$是可以实现的，那么递推公式就可以是$dp[j] = dp[j] || dp[j - num]$，对于初始化问题，我们需要定义一个长为$n+1$的$dp$数组，并使$dp[0]=True$，这是因为和为0是一定可以实现的，我们不选数字就行。基于此我们可以写出以下代码：

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        sums = sum(nums)
        if sums & 1: return False
        
        target = sums >> 1
        dp = [False] * (target + 1)
        dp[0] = True
        for num in nums:
            for j in range(target, num - 1, -1):
                dp[j] = dp[j] or dp[j - num]
            if dp[target]: return True
        return False
```

## [698. 划分为k个相等的子集](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/)

给定一个整数数组 `nums` 和一个正整数 `k`，找出是否有可能把这个数组分成 `k` 个非空子集，其总和都相等。

**示例 1：**

```
输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4
输出： True
说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。
```

**示例 2:**

```
输入: nums = [1,2,3,4], k = 3
输出: false
```

 对于此题上上一题的扩展版，但是此题就无法使用动态规划了，因为并不是二选一的问题了，而是多个桶选一个，因此我们只能使用回溯法来解决了。

但是盲目的回溯是会超时的，因此需要进行剪枝，其中在下面的代码中共使用了两种剪枝方法，首先是`bucker[j] - nums[i] < 0`当加入该数字后超过了target那么就不再回溯，另一个是`j > 0 and bucker[j] == bucker[j - 1]`这也是回溯中常用的剪枝方法，但在此处意思不太一样，此处的意思是如果前一个桶与后一个桶的值一样，而num[i]放入前一个桶失败了，那么这个桶也不用放，肯定也是失败的。除此之外，还有一个排序，将大的数字放到前面，这样先让值大的元素选择桶，这样可以增加剪枝的命中率，从而降低回溯的概率。

 ```python
class Solution:
    def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:
        sums = sum(nums)
        if sums % k: return False
        target = sums // k
        nums.sort(reverse=True)
        if nums[-1] > target: return False
        bucker = [target] * k

        def dfs(i, bucker, nums):
            if i == len(nums):
                return True
            for j in range(k):
                if bucker[j] - nums[i] < 0 or (j > 0 and bucker[j] == bucker[j - 1]): continue
                bucker[j] -= nums[i]
                if dfs(i + 1, bucker, nums): return True
                bucker[j] += nums[i]
            return False
        return dfs(0, bucker, nums)
 ```

## [494. 目标和](https://leetcode.cn/problems/target-sum/)

给你一个非负整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

**示例 1：**

```
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```

**示例 2：**

```
输入：nums = [1], target = 1
输出：1
```

此题一看可以使用回溯来解决，但其时间复杂度达到了$O(2^N)$，是肯定会超时的，因此我们要想别的办法。其实此题跟上面的416题有点像，都是选择的问题，每个数可以选择是加还是减，那么我们能不能做一些变换使其可以使用416题的方法呢？那当然是可以的，通过一些简单的数学计算我们就可以成功了。

不妨我们令选出来的加数为left，减数为right，那么有公式left+right=sum,left-right=target，两个联合求解得到left=(sum+target)/2，那么就转换成416题的形式了，根据416题的解答，我们可以写出以下答案：

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        sums = sum(nums) + target
        if sums & 1 or sums < 0: return 0
        target = sums >> 1
        dp = [0] * (target + 1)
        dp[0] = 1
        for num in nums:
            for j in range(target, num - 1, -1):
                dp[j] += dp[j - num]
        return dp[target]
```

## [474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/)

给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。

请你找出并返回 `strs` 的最大子集的长度，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。

如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。

**示例 1：**

```
输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
```

**示例 2：**

```
输入：strs = ["10", "0", "1"], m = 1, n = 1
输出：2
解释：最大的子集是 {"0", "1"} ，所以答案是 2 。
```

此题还是比较难的，很难想到使用动态规划去解答，并且如果没遇到此类二维动态规划，还是很难写出来的。此题其实也是0-1背包问题，我们可以先不考虑1，我们只考虑子集中 **最多** 有 `m` 个 `0` 的情况，那么我们可以像0-1背包问题那样轻松解答。

```python
        dp = [0] * (m+1)
        for s in strs:
            zero_num = s.count("0")
            for i in range(m, zero_num -1, -1):
                dp[i] = max(dp[i], dp[i - zero_num] + 1)
        return dp[-1]
```

这里我们直接使用了缩减维度后的dp策略，如果没有缩减维度时，它应该是二维的。

而对于此题来说，还多了一个1的限制，那么类似的在没有缩减维度时，我们需要使用一个三维数组来作为dp数组，而在缩减维度后需要两个维度来作为dp数组，并且由于都是0-1背包问题，因此遍历需要从后往前遍历，照着可以写出以下代码：

```python
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        dp = [[0] * (n+1) for _ in range(m+1)]
        for s in strs:
            cnt = Counter(s)
            zero_num = cnt["0"]
            one_num = cnt["1"]
            for i in range(m, zero_num -1, -1):
                for j in range(n, one_num -1, -1):
                    if dp[i][j] < dp[i - zero_num][j - one_num] + 1:
                        dp[i][j] = dp[i - zero_num][j - one_num] + 1
        return dp[-1][-1]
```

## [1186. 删除一次得到子数组最大和](https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/)

给你一个整数数组，返回它的某个 **非空** 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。

注意，删除一个元素后，子数组 **不能为空**。

**示例 1：**

```
输入：arr = [1,-2,0,3]
输出：4
解释：我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。
```

**示例 2：**

```
输入：arr = [1,-2,-2,3]
输出：3
解释：我们直接选出 [3]，这就是最大和。
```

**示例 3：**

```
输入：arr = [-1,-1,-1,-1]
输出：-1
解释：最后得到的子数组不能为空，所以我们不能选择 [-1] 并从中删去 -1 来得到 0。
     我们应该直接选择 [-1]，或者选择 [-1, -1] 再从中删去一个 -1。
```

此题实际也是动态规划中的一个选择问题，我们需要选择哪个数字进行删除或不删除，由于此题的要求是可以删除，也可以不删除，那么我们可以定义两列的动态规划数组$dp[i][j]$，当$j=0$时表示不删除元素，当$j=1$时表示可以删除一个元素，那么转移矩阵如下：

- $dp[i][0]=max(dp[i−1][0],0)+arr[i]$
- $dp[i][1]=max(dp[i−1][1]+arr[i],dp[i−1][0])$

对于初始状态，我们需要定义为负无穷，这样我们运算过程中就不会出错。

```python
class Solution:
    def maximumSum(self, arr: List[int]) -> int:
        n = len(arr)
        dp = [[float('-inf')] * 2] + [[0] * 2 for _ in range(n)]
        for i in range(n):
            dp[i + 1][0] = max(dp[i][0], 0) + arr[i]
            dp[i + 1][1] = max(dp[i][0], dp[i][1] + arr[i])
        return max(max(r) for r in dp)
```

由代码我们可以看出，我们并不需要把dp全部存储下来，动态规划数组是可以降维的。降维后的代码如下：

```python
class Solution:
    def maximumSum(self, arr: List[int]) -> int:
        n = len(arr)
        dp = [float('-inf')] * 2
        ans = float('-inf')
        for i in range(n):
            dp[1] = max(dp[0], dp[1] + arr[i])
            dp[0] = max(dp[0], 0) + arr[i]
            ans = max(ans, dp[1], dp[0])
        return ans
```

同时，我们也可以使用递归实现：

```python
from functools import cache
class Solution:
    def maximumSum(self, arr: List[int]) -> int:
        @cache  # 记忆化搜索
        def dfs(i: int, j: int) -> int:
            if i < 0: return -math.inf  # 子数组至少要有一个数，不合法
            if j == 0: return max(dfs(i - 1, 0), 0) + arr[i]
            return max(dfs(i - 1, 1) + arr[i], dfs(i - 1, 0))
        return max(max(dfs(i, 0), dfs(i, 1)) for i in range(len(arr)))
```

如果此题**改变要求，即我们可以删除k次(即至多删除k次)**，那我们的的代码可以变为：

```python
class Solution:
    def maximumSum(self, arr: List[int], k: int) -> int:
        @cache  # 记忆化搜索
        def dfs(i: int, j: int) -> int:
            if i < 0: return -math.inf  # 子数组至少要有一个数，不合法
            if j == 0: return max(dfs(i - 1, 0), 0) + arr[i]
            return max(dfs(i - 1, j) + arr[i], dfs(i - 1, j - 1))
        return max(max(dfs(i, j) for j in range(k + 1)) for i in range(len(arr)))
```

使用循环则代码如下：

```python
class Solution:
    def maximumSum(self, arr: List[int], k: int) -> int:
        n = len(arr)
        dp = [[float('-inf')] * (k + 1)] + [[0] * (k + 1) for _ in range(n)]
        for i in range(n):
            for j in range(k + 1):
                if j == 0:
                    dp[i + 1][j] = max(dp[i][j], 0) + arr[i]
                else:
                    dp[i + 1][j] = max(dp[i][j] + arr[i], dp[i][j - 1])
        return max(max(r) for r in dp)
```

如果此题**改变要求，即至少删除k次**，那么此题的性质就发生了变化，我们只需对数组进行排序，删除掉最小的k个后查看剩余元素还是否由负数，如果有就删除，如果没有就返回结果：

```python
class Solution:
    def maximumSum(self, arr: List[int], k: int) -> int:
        arr.sort()
        n = len(arr)
        for i in range(k, n):
            if arr[i] > 0:
                return sum(arr[i:])
        return arr[-1]
```

如果此题**改变要求，即正好删除k次**，那么我们返回只需返回dp数组的第一行的最大值即可，该行一定是删除了k个数字之和的和了。

# 活动区间问题

## [435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)

给定一个区间的集合 `intervals` ，其中 `intervals[i] = [starti, endi]` 。返回 *需要移除区间的最小数量，使剩余区间互不重叠* 。

**示例 1:**

```
输入: intervals = [[1,2],[2,3],[3,4],[1,3]]
输出: 1
解释: 移除 [1,3] 后，剩下的区间没有重叠。
```

**示例 2:**

```
输入: intervals = [ [1,2], [1,2], [1,2] ]
输出: 2
解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
```

**示例 3:**

```
输入: intervals = [ [1,2], [2,3] ]
输出: 0
解释: 你不需要移除任何区间，因为它们已经是无重叠的了。
```

此题实际就是贪心算法中经典的活动安排问题，即安排最多次数的活动，其经典解法就是对结束时间进行排序，然后贪心的统计最大区间数。

```python
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort(key = lambda x: x[1])
        result = -1
        end = intervals[0][1]
        for interval in intervals:
            if interval[0] < end:
                result += 1
            else:
                end = interval[1]
        return result
```

## [1353. 最多可以参加的会议数目](https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended/)

给你一个数组 `events`，其中 `events[i] = [startDayi, endDayi]` ，表示会议 `i` 开始于 `startDayi` ，结束于 `endDayi` 。

你可以在满足 `startDayi <= d <= endDayi` 中的任意一天 `d` 参加会议 `i` 。在任意一天 `d` 中只能参加一场会议。

请你返回你可以参加的 **最大** 会议数目。

**示例 1：**

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/16/e1.png" alt="img" style="zoom:30%;" />

```
输入：events = [[1,2],[2,3],[3,4]]
输出：3
解释：你可以参加所有的三个会议。
安排会议的一种方案如上图。
第 1 天参加第一个会议。
第 2 天参加第二个会议。
第 3 天参加第三个会议。
```

**示例 2：**

```
输入：events= [[1,2],[2,3],[3,4],[1,2]]
输出：4
```

此题与上一题不同之处在于此题的活动只需参加一天即可，而不是全部参加，因此我们的做法就有所变化。由于每个时间点最多参加一个会议，我们可以从最开始遍历时间。

对于每一个时间点，所有在当前时间及之前时间开始，并且在当前时间还未结束的会议都是可参加的。显然，在所有可参加的会议中，选择结束时间最早的会议是最优的，因为其他会议还有更多的机会可以去参加。

怎样动态获得当前结束时间最早的会议呢？我们可以使用一个小根堆记录所有当前可参加会议的结束时间。在每一个时间点，我们首先将当前时间点开始的会议加入小根堆，再把当前已经结束的会议移除出小根堆（因为已经无法参加了），然后从剩下的会议中选择一个结束时间最早的去参加。

```python
class Solution:
    def maxEvents(self, events: List[List[int]]) -> int:
        events.sort(key=lambda x: x[0])
        length = len(events)
        i = ans = 0
        day = events[0][0]
        heap = []
        while i < length or heap:
            while i < length and events[i][0] == day:
                heapq.heappush(heap, events[i][1])
                i += 1
            while heap:
                end = heapq.heappop(heap)
                if end >= day:
                    ans += 1
                    break
            day += 1
        return ans
```

## [2008. 出租车的最大盈利](https://leetcode.cn/problems/maximum-earnings-from-taxi/)

你驾驶出租车行驶在一条有 `n` 个地点的路上。这 `n` 个地点从近到远编号为 `1` 到 `n` ，你想要从 `1` 开到 `n` ，通过接乘客订单盈利。你只能沿着编号递增的方向前进，不能改变方向。

乘客信息用一个下标从 **0** 开始的二维数组 `rides` 表示，其中 `rides[i] = [starti, endi, tipi]` 表示第 `i` 位乘客需要从地点 `starti` 前往 `endi` ，愿意支付 `tipi` 元的小费。

**每一位** 你选择接单的乘客 `i` ，你可以 **盈利** `endi - starti + tipi` 元。你同时 **最多** 只能接一个订单。

给你 `n` 和 `rides` ，请你返回在最优接单方案下，你能盈利 **最多** 多少元。

**注意：**你可以在一个地点放下一位乘客，并在同一个地点接上另一位乘客。

**示例 1：**

```
输入：n = 5, rides = [[2,5,4],[1,5,1]]
输出：7
解释：我们可以接乘客 0 的订单，获得 5 - 2 + 4 = 7 元。
```

**示例 2：**

```
输入：n = 20, rides = [[1,6,1],[3,10,2],[10,12,3],[11,12,2],[12,15,2],[13,18,1]]
输出：20
解释：我们可以接以下乘客的订单：
- 将乘客 1 从地点 3 送往地点 10 ，获得 10 - 3 + 2 = 9 元。
- 将乘客 2 从地点 10 送往地点 12 ，获得 12 - 10 + 3 = 5 元。
- 将乘客 5 从地点 13 送往地点 18 ，获得 18 - 13 + 1 = 6 元。
我们总共获得 9 + 5 + 6 = 20 元。
```

此题有三种解法，每一种都是比较经典的解法，首先第一种是直接动态规划，这个方法适用于 `n` 较小的情况下，因为其需要创建一个长度为 `n` 的dp数组。对于dp[i]其表示从0-i最大的盈利数目，由于i表示的是结束时间，因此我们需要对数组的结束时间进行从小到大排序，这样才能正确。那么我们就可以写出以下代码了：

```python
class Solution:
    def maxTaxiEarnings(self, n: int, rides: List[List[int]]) -> int:
        rides.sort(key=lambda x: x[1])
        dp = [0] * (n + 1)
        j = 0
        length = len(rides)
        for i in range(1, n + 1):
            dp[i] = dp[i - 1]
            while j < length and rides[j][1] == i:	# 不允许重叠就找等于i-1的情况
                dp[i] = max(dp[i], dp[rides[j][0]] + rides[j][1] - rides[j][0] + rides[j][2])
                j += 1
        return dp[n]
```

在 `n` 比较大的时候，我们就无法采用以上方法了，我们需要重新定义 dp数组的定义，同时创建的长度也不再是 `n` ，而是乘客的数目了（之所以这样定义是因为乘客的数目是少于 `n` 的，且对于之前 `n` 个路上没有乘客的地方，我们是无需浪费空间去定义它的，因此此时我们只是把所有有乘客的位置定义了dp数组）。因此我们还是对数组的结束时间进行从小到大排序，在之前我们直接使用$dp[rides[j][0]]$来获得之前时刻的最大值，由于现在我们只记录有乘客时刻的值，那我们就需要搜索了，而又由于我们对数组进行了排序，因此我们可以使用二分搜索来加速。

```python
class Solution:
    def maxTaxiEarnings(self, n: int, rides: List[List[int]]) -> int:
        def binary_search(rides, high, target):
            left, right = 0, high
            while left < right:
                mid = (left + right) // 2
                if rides[mid][1] <= target:
                    left = mid + 1
                else:
                    right = mid
            return left

        rides.sort(key=lambda x: x[1])
        dp = [0] * (len(rides) + 1)
        for i, (start, end, p) in enumerate(rides):
            dp[i + 1] = max(dp[i], dp[binary_search(rides, i, start)] + end - start + p)	
            # 不允许重叠就把搜索目标该为start - 1
        return dp[-1]
```

除此之外，我们还可以使用贪心+最小堆的方法来解决这道题，但其思路和上面仍然类似。我们将上面改进后的每一个dp[i]都放到堆里并按结束时间排序，这样我们每到了一个乘客的上车时间，我们就可以取出在上车时间之前的全部盈利值，并找最大值，然后加上当前时刻的盈利值再放入堆中。这样也能得到最优解：

```python
class Solution:
    def maxTaxiEarnings(self, n: int, rides: List[List[int]]) -> int:
        rides.sort()
        res = pre_p = 0
        heap = []
        for start, end, p in rides:
            while heap and heap[0][0] <= start:			# 不允许重叠那么就不加等于号
                pre_p = max(pre_p, heapq.heappop(heap)[1])
            res = max(res, pre_p + p + end - start)
            heapq.heappush(heap, (end, pre_p + p + end - start))
        return res
```

对此题的解法比较熟悉后，还可以试试[1235. 规划兼职工作](https://leetcode.cn/problems/maximum-profit-in-job-scheduling/)、[2830. 销售利润最大化（不允许重叠）](https://leetcode.cn/problems/maximize-the-profit-as-the-salesman/)这两道题，解法基本一模一样。此外还有[2054. 两个最好的不重叠活动](https://leetcode.cn/problems/two-best-non-overlapping-events/)可以使用贪心+最小堆的方法来解决，只是只求两个的最大值，就不需要累加了。

## [1751. 最多可以参加的会议数目 II](https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended-ii/)

给你一个 `events` 数组，其中 `events[i] = [startDayi, endDayi, valuei]` ，表示第 `i` 个会议在 `startDayi` 天开始，第 `endDayi` 天结束，如果你参加这个会议，你能得到价值 `valuei` 。同时给你一个整数 `k` 表示你能参加的最多会议数目。

你同一时间只能参加一个会议。如果你选择参加某个会议，那么你必须 **完整** 地参加完这个会议。会议结束日期是包含在会议内的，也就是说你不能同时参加一个开始日期与另一个结束日期相同的两个会议。

请你返回能得到的会议价值 **最大和** 。

**示例 1：**

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/06/screenshot-2021-01-11-at-60048-pm.png" alt="img" style="zoom:40%;" />

```
输入：events = [[1,2,4],[3,4,3],[2,3,1]], k = 2
输出：7
解释：选择绿色的活动会议 0 和 1，得到总价值和为 4 + 3 = 7 。
```

**示例 2：**

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/06/screenshot-2021-01-11-at-60150-pm.png" alt="img" style="zoom:40%;" />

```
输入：events = [[1,2,4],[3,4,3],[2,3,10]], k = 2
输出：10
解释：参加会议 2 ，得到价值和为 10 。
你没法再参加别的会议了，因为跟会议 2 有重叠。你 不 需要参加满 k 个会议。
```

**示例 3：**

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/06/screenshot-2021-01-11-at-60703-pm.png" alt="ig" style="zoom:40%;" />

```
输入：events = [[1,1,1],[2,2,2],[3,3,3],[4,4,4]], k = 3
输出：9
解释：尽管会议互不重叠，你只能参加 3 个会议，所以选择价值最大的 3 个会议。
```

此题是在上一题的基础上增加了限制，即只能参加k次，同时也是在[2054. 两个最好的不重叠活动](https://leetcode.cn/problems/two-best-non-overlapping-events/)上做的扩展，由两次增加到k次，因此我们可以在上一题的基础上进行扩展，之前我们并没有限制次数，现在有了限制之后我们可以参考股票问题的[188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)或DP问题的[1186. 删除一次得到子数组最大和](https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/)的改进那样，列一个n行k列的dp数组，每一列代表最大参加k次，那么我们就可以轻松的写出以下代码了：

```python
class Solution:
    def maxValue(self, events: List[List[int]], k: int) -> int:
        def binary_search(events, high, target):
            left, right = 0, high
            while left < right:
                mid = (left + right) // 2
                if events[mid][1] <= target:
                    left = mid + 1
                else:
                    right = mid
            return left
        
        events.sort(key = lambda x: x[1])
        dp = [[0] * k for _ in range(len(events) + 1)]
        for i, (start, _, p) in enumerate(events):
            j = binary_search(events, i, start - 1)
            dp[i + 1][0] = max(dp[i][0], p)
            for m in range(1, k):
                dp[i + 1][m] = max(dp[i][m], dp[j][m - 1] + p)
        return dp[-1][-1]
```



# 贪心

## [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

**示例 1：**

<img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="1" style="zoom:50%;" />

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

**示例 2：**

```
输入：height = [1,1]
输出：1
```

此题使用双指针加贪心的思想，设两指针$ i$, $j$指向的水槽板高度分别为 $h[i]$ , $h[j]$，此状态下水槽面积为 $S(i,j)$ 。由于可容纳水的高度由两板中的 **短板** 决定，因此可得如下 **面积公式** ：$S(i,j)=min(h[i],h[j])×(j−i)$

在每个状态下，无论长板或短板向中间收窄一格，都会导致水槽 **底边宽度** −1变短：

- 若向内 **移动短板** ，水槽的短板$ min(h[i],h[j])$可能变大，因此下个水槽的面积 **可能增大** 。
- 若向内 **移动长板** ，水槽的短板 $min(h[i],h[j])$不变或变小，因此下个水槽的面积 **一定变小** 。

因此，初始化双指针分列水槽左右两端，循环将短板向内移动直至遇到大于短板的长度，并更新面积最大值，直到两指针相遇时跳出；即可获得最大面积。据此实现的代码如下：

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        i, j = 0, len(height) - 1
        res = min(height[i], height[j]) * (j - i)
        while i < j:
            if height[i] < height[j]:
                i_temp = i + 1
                while i_temp < j and height[i_temp] <= height[i]:
                    i_temp += 1
                res = max(res, min(height[i_temp], height[j]) * (j - i_temp))
                i = i_temp
            else:
                j_temp = j - 1
                while j_temp > i and height[j_temp] <= height[j]:
                    j_temp -= 1
                res = max(res, min(height[i], height[j_temp]) * (j_temp - i))
                j = j_temp
        return res
```

## [857. 雇佣 K 名工人的最低成本](https://leetcode.cn/problems/minimum-cost-to-hire-k-workers/)

有 `n` 名工人。 给定两个数组 `quality` 和 `wage` ，其中，`quality[i]` 表示第 `i` 名工人的工作质量，其最低期望工资为 `wage[i]` 。

现在我们想雇佣 `k` 名工人组成一个 **工资组**。在雇佣 一组 `k` 名工人时，我们必须按照下述规则向他们支付工资：

1. 对工资组中的每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资。
2. 工资组中的每名工人至少应当得到他们的最低期望工资。

给定整数 `k` ，返回 *组成满足上述条件的付费群体所需的最小金额* 。在实际答案的 `10-5` 以内的答案将被接受。

**示例 1：**

```
输入： quality = [10,20,5], wage = [70,50,30], k = 2
输出： 105.00000
解释： 我们向 0 号工人支付 70，向 2 号工人支付 35。
```

**示例 2：**

```
输入： quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3
输出： 30.66667
解释： 我们向 0 号工人支付 4，向 2 号和 3 号分别支付 13.33333。
```

此题题目很难理解，可以认为quality[i]是员工的工作时长，这个人一定会干这么长时间的活，wage[i]则是上面这个人干这么多活的最低薪水，人不介意给更多，那么规则1则指的是同工同酬，干1小时活给的薪水对每个人来说都是一样的。

由于我们要求同工同酬，那么干1小时活给的薪水自然是越低越好，因此我们可以按照1小时活给的薪水也就是wage/quality排序，先取前k个。

但是我们算总价格的时候，是要求工资最小，而工资就等于k个工人的quality之和(sum(quality))乘以他们里面最大的wage/quality。

因此到现在我们取了最小的wage/quality，当sum(quality)并不是最小的，因此不一定是最优解，同时我们参照上一题，在上一题中，边长是不断减小的，高度是不断增高的，这一题我们类比的话就是wage/quality是不断增大的，sum(quality)是不断减小的，这样就可以得到最优解了。

```python
class Solution:
    def mincostToHireWorkers(self, quality: List[int], wage: List[int], k: int) -> float:
        pairs = sorted(zip(quality, wage), key=lambda x: x[1] / x[0])
        heap = [-q for q, _ in pairs[:k]]
        heapq.heapify(heap)
        sum_q = -sum(heap)
        ans = sum_q * pairs[k - 1][1] / pairs[k - 1][0]
        for q, w in pairs[k:]:
            if q < -heap[0]:
                sum_q += q + heapq.heappushpop(heap, -q)
                ans = min(ans, sum_q * w / q)
        return ans
```

# 博弈

## [292. Nim 游戏](https://leetcode.cn/problems/nim-game/)

你和你的朋友，两个人一起玩 [Nim 游戏](https://baike.baidu.com/item/Nim游戏/6737105)：

- 桌子上有一堆石头。
- 你们轮流进行自己的回合， **你作为先手** 。
- 每一回合，轮到的人拿掉 1 - 3 块石头。
- 拿掉最后一块石头的人就是获胜者。

假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 `n` 的情况下赢得游戏。如果可以赢，返回 `true`；否则，返回 `false` 。

**示例 1：**

```
输入：n = 4
输出：false 
解释：以下是可能的结果:
1. 移除1颗石头。你的朋友移走了3块石头，包括最后一块。你的朋友赢了。
2. 移除2个石子。你的朋友移走2块石头，包括最后一块。你的朋友赢了。
3.你移走3颗石子。你的朋友移走了最后一块石头。你的朋友赢了。
在所有结果中，你的朋友是赢家。
```

**示例 2：**

```
输入：n = 1
输出：true
```

**示例 3：**

```
输入：n = 2
输出：true
```

此题是最经典的博弈论类的题目了，**在不知晓博弈论结论前，可以先通过找规律得到猜想。**

根据题意，我们尝试从小范围数据的情况进行讨论：

1. 如果落到先手的局面为「石子数量为 1- 3」的话，那么先手必胜；
2. 如果落到先手的局面为「石子数量为 4」的话，那么先手决策完（无论何种决策），交到后手的局面为「石子数量为 1 - 3」，即此时后手必胜，对应先手必败（到这里我们有一个推论：如果交给先手的局面为 4 的话，那么先手必败）；
3. 如果落到先手的局面为「石子数量为 5 - 7」的话，那么先手可以通过控制选择石子的数量，来使得后手处于「石子数量为 4」的局面（此时后手必败），因此先手必胜；
4. 如果落到先手的局面为「石子数量为 8」的话，由于每次只能选 1 - 3 个石子，因此交由后手的局面为 5 - 7，根据流程 3 我们知道此时先手必败；

那么根据我们简单的讨论，我们可以发现其每一步都是可以由前面的几步得来的，这样我们就可以使用动态规划的思想来解决这道题，我们可以令dp[i]表示i个石头是否能获胜，因此对于我们自己与对手而言，dp都是相同的，那么轮到我们时可以检查dp[i-1],dp[i-2],dp[i-3]来知道对手是否有必输的可能，如果都没有，那么我们就是必输的。据此我们可以写出以下代码：

```python
class Solution:
    def canWinNim(self, n: int) -> bool:
        dp = [False] * (n + 1)
        for i in range(1, n + 1):
            for j in range(max(0, i - 3), i):
                if dp[j] is False:
                    dp[i] = True
                    break
        return dp[n]
```

但对于此题来说，经过简单的找规律我们可以发现是要是4的倍数，那么都是必输的，这也是**巴什博弈**：有一堆n个物品，两个人轮流从这堆物品中取物， 规定每次至少取一个，最多取m个。最后取光者得胜。只要 n 不能整除 m+1 ,那么必然是先手取胜，否则后手取胜。

```python
class Solution:
    def canWinNim(self, n: int) -> bool:
        return n % 4 != 0
```

## [1510. 石子游戏 IV](https://leetcode.cn/problems/stone-game-iv/)

Alice 和 Bob 两个人轮流玩一个游戏，Alice 先手。

一开始，有 `n` 个石子堆在一起。每个人轮流操作，正在操作的玩家可以从石子堆里拿走 **任意** 非零 **平方数** 个石子。

如果石子堆里没有石子了，则无法操作的玩家输掉游戏。

给你正整数 `n` ，且已知两个人都采取最优策略。如果 Alice 会赢得比赛，那么返回 `True` ，否则返回 `False` 。

**示例 1：**

```
输入：n = 1
输出：true
解释：Alice 拿走 1 个石子并赢得胜利，因为 Bob 无法进行任何操作。
```

**示例 2：**

```
输入：n = 2
输出：false
解释：Alice 只能拿走 1 个石子，然后 Bob 拿走最后一个石子并赢得胜利（2 -> 1 -> 0）。
```

**示例 3：**

```
输入：n = 4
输出：true
解释：n 已经是一个平方数，Alice 可以一次全拿掉 4 个石子并赢得胜利（4 -> 0）。
```

此题相当于是上一题的扩展，该题限制了每次取的数目，不再是1，2，3，而是1，4，9，16……，那么我们只需在循环的时候使用该值即可：

```python
class Solution:
    def winnerSquareGame(self, n: int) -> bool:
        dp = [False] * (n + 1)
        for i in range(1, n + 1):
            for k in range(1, int(math.sqrt(i)) + 1):
                if dp[i - k * k] is False:
                    dp[i] = True
                    break
        return dp[n]
```

## [1406. 石子游戏 III](https://leetcode.cn/problems/stone-game-iii/)

Alice 和 Bob 继续他们的石子游戏。几堆石子 **排成一行** ，每堆石子都对应一个得分，由数组 `stoneValue` 给出。

Alice 和 Bob 轮流取石子，**Alice** 总是先开始。在每个玩家的回合中，该玩家可以拿走剩下石子中的的前 **1、2 或 3 堆石子** 。比赛一直持续到所有石头都被拿走。

每个玩家的最终得分为他所拿到的每堆石子的对应得分之和。每个玩家的初始分数都是 **0** 。

比赛的目标是决出最高分，得分最高的选手将会赢得比赛，比赛也可能会出现平局。

假设 Alice 和 Bob 都采取 **最优策略** 。

如果 Alice 赢了就返回 `"Alice"` *，*Bob 赢了就返回 `"Bob"`*，*分数相同返回 `"Tie"` 。

**示例 1：**

```
输入：values = [1,2,3,7]
输出："Bob"
解释：Alice 总是会输，她的最佳选择是拿走前三堆，得分变成 6 。但是 Bob 的得分为 7，Bob 获胜。
```

**示例 2：**

```
输入：values = [1,2,3,-9]
输出："Alice"
解释：Alice 要想获胜就必须在第一个回合拿走前三堆石子，给 Bob 留下负分。
如果 Alice 只拿走第一堆，那么她的得分为 1，接下来 Bob 拿走第二、三堆，得分为 5 。之后 Alice 只能拿到分数 -9 的石子堆，输掉比赛。
如果 Alice 拿走前两堆，那么她的得分为 3，接下来 Bob 拿走第三堆，得分为 3 。之后 Alice 只能拿到分数 -9 的石子堆，同样会输掉比赛。
注意，他们都应该采取 最优策略 ，所以在这里 Alice 将选择能够使她获胜的方案。
```

此题又相当于是前面的改进，其每次拿取的石头数目的动态变化的，同时其还要求我们记录石头的分数，因此我们也需要修改dp数组的定义，同时为了使dp数组表示的含义比较统一，我们统一定义dp[i]表示还剩下$i,i+1,i+2,n-1$堆石头时，**当前玩家比下一位玩家最多能多拿到的石子数目（注意此时依旧是在剩下的石子中定义的）**。这样一来：

- 如果当前玩家选择了一堆石子，那么留给下一位玩家的状态为 dp[i+1]，表示下一位玩家最多最多可以比当前玩家多拿到 dp[i+1]数量的石子。那么当前玩家可以比下一位玩家多拿到 value[i]−dp[i+1]数量的石子；
- 同理，如果当前玩家选择了两堆石子，那么留给下一位玩家的状态为dp[i+2]，当前玩家可以比下一位玩家多拿到 value[i]+value[i+1]−dp[i+2]数量的石子；
- 同理，如果当前玩家选择了三堆石子，那么留给下一位玩家的状态为dp[i+3]，当前玩家可以比下一位玩家多拿到 value[i]+value[i+1]+alue[i+1]−dp[i+3]数量的石子；

因此我们就可以写出状态转移方程为：

$dp[i]=\max(sum(i,j-1)-dp[j])\quad,j\in[i+1,i+3]$

那么据此我们可以写出：

```python
class Solution:
    def stoneGameIII(self, stoneValue: List[int]) -> str:
        n = len(stoneValue)
        stoneValue += [0, 0, 0]
        dp = [0] * (n + 3)
        for i in range(n - 1, -1, -1):
            dp[i] = max(stoneValue[i] - dp[i + 1], stoneValue[i] + stoneValue[i + 1]- dp[i + 2], stoneValue[i] + stoneValue[i + 1] + stoneValue[i + 2]- dp[i + 3])
        return "Alice" if dp[0] > 0 else ("Bob" if dp[0] < 0 else "Tie")
```

## [1140. 石子游戏 II](https://leetcode.cn/problems/stone-game-ii/)

爱丽丝和鲍勃继续他们的石子游戏。许多堆石子 **排成一行**，每堆都有正整数颗石子 `piles[i]`。游戏以谁手中的石子最多来决出胜负。

爱丽丝和鲍勃轮流进行，爱丽丝先开始。最初，`M = 1`。

在每个玩家的回合中，该玩家可以拿走剩下的 **前** `X` 堆的所有石子，其中 `1 <= X <= 2M`。然后，令 `M = max(M, X)`。

游戏一直持续到所有石子都被拿走。

假设爱丽丝和鲍勃都发挥出最佳水平，返回爱丽丝可以得到的最大数量的石头。

**示例 1：**

```
输入：piles = [2,7,9,4,4]
输出：10
解释：如果一开始Alice取了一堆，Bob取了两堆，然后Alice再取两堆。爱丽丝可以得到2 + 4 + 4 = 10堆。如果Alice一开始拿走了两堆，那么Bob可以拿走剩下的三堆。在这种情况下，Alice得到2 + 7 = 9堆。返回10，因为它更大。
```

**示例 2:**

```
输入：piles = [1,2,3,4,5,100]
输出：104
```

此题相当于是上一题的扩展，其每次拿取的石头数目不是3个以内了，而是M个，因此我们就需要做进一步的扩展，我们可以对上一题的$dp[i]$扩展一维变为$dp[i][m]$，其中m的定义与题目中相同，那么m的最大值（极限情况下）为$n/2+2$。

```python
class Solution:
    def stoneGameII(self, piles: List[int]) -> int:
        n = len(piles)
        dp = [[0] * (n // 2 + 2) for _ in range(n)]
        s = 0
        for i in range(n - 1, -1, -1):
            s += piles[i]
            for m in range(1, i // 2 + 2):
                if m * 2 + i >= n:
                    dp[i][m] = s		# 对手一个石头都拿不到
                else:
                    dp[i][m] = s - min(dp[i + x][max(x, m)] for x in range(1, m * 2 + 1))
                    # 减去对手拿到石头分数的最小值，那么自己拿到石头的分数就是最大的。
        return dp[0][1]
```

## [1872. 石子游戏 VIII](https://leetcode.cn/problems/stone-game-viii/)

Alice 和 Bob 玩一个游戏，两人轮流操作， **Alice 先手** 。

总共有 `n` 个石子排成一行。轮到某个玩家的回合时，如果石子的数目 **大于 1** ，他将执行以下操作：

1. 选择一个整数 `x > 1` ，并且 **移除** 最左边的 `x` 个石子。
2. 将 **移除** 的石子价值之 **和** 累加到该玩家的分数中。
3. 将一个 **新的石子** 放在最左边，且新石子的值为被移除石子值之和。

当只剩下 **一个** 石子时，游戏结束。

Alice 和 Bob 的 **分数之差** 为 `(Alice 的分数 - Bob 的分数)` 。 Alice 的目标是 **最大化** 分数差，Bob 的目标是 **最小化** 分数差。

给你一个长度为 `n` 的整数数组 `stones` ，其中 `stones[i]` 是 **从左边起** 第 `i` 个石子的价值。请你返回在双方都采用 **最优** 策略的情况下，Alice 和 Bob 的 **分数之差** 。

**示例 1：**

```
输入：stones = [-1,2,-3,4,-5]
输出：5
解释：
- Alice 移除最左边的 4 个石子，得分增加 (-1) + 2 + (-3) + 4 = 2 ，并且将一个价值为 2 的石子放在最左边。stones = [2,-5] 。
- Bob 移除最左边的 2 个石子，得分增加 2 + (-5) = -3 ，并且将一个价值为 -3 的石子放在最左边。stones = [-3] 。
两者分数之差为 2 - (-3) = 5 。
```

**示例 2：**

```
输入：stones = [7,-6,5,10,5,-2,-6]
输出：13
解释：
- Alice 移除所有石子，得分增加 7 + (-6) + 5 + 10 + 5 + (-2) + (-6) = 13 ，并且将一个价值为 13 的石子放在最左边。stones = [13] 。
两者分数之差为 13 - 0 = 13 。
```

**示例 3：**

```
输入：stones = [-10,-12]
输出：-22
解释：
- Alice 只有一种操作，就是移除所有石子。得分增加 (-10) + (-12) = -22 ，并且将一个价值为 -22 的石子放在最左边。stones = [-22] 。
两者分数之差为 (-22) - 0 = -22 。
```

此题又是对上面两题的扩展，即可以从左边拿任意个石头，但拿完后需要把拿完的和再添加到开头。因此，**最左侧的石子的价值一定是 stones的某一个前缀和**，即**玩家在每一轮获得的分数一定是初始数组 stones的某一个前缀和。**

设$dp(i)$表示当 Alice 可以选择的下标$ u$ 在$ [i,n)$范围内时，Alice 与 Bob分数的最大差值。在进行状态转移时，我们可以考虑 Alice是否选择了$ i$作为下标$ u$；

- 如果 Alice没有选择 i作为下标 u，那么她需要在$ [i+1,n)$的范围内进行选择，因此有状态转移方程：$dp[i]=dp[i+1]$
- 如果 Alice选择了 $i$作为下标 $u$，那么她获得了 $pre[i]$的分数，并且轮到 Bob在剩余的范围 $[i+1,n)$中进行选择。由于 Bob会采用最优策略，因此在$[i+1,n)$的范围内，Bob与 Alice分数的最大差值就为 $dp[i+1]$，因此有状态转移方程：$dp[i]=pre[i]−dp[i+1]$

由于 Alice会采用最优策略，因此状态转移选择二者中的较大值：$dp[i]=max⁡(dp[i+1],pre[i]−dp[i+1])$

```python
class Solution:
    def stoneGameVIII(self, stones: List[int]) -> int:
        n = len(stones)
        presum = list(accumulate(stones, initial = 0))
        dp = [0] * (n + 1)
        dp[n] = presum[n]
        for i in range(n - 1, 1, -1):
            dp[i] = max(dp[i + 1], presum[i] - dp[i + 1])
        return dp[2]
```

由于在石头数目为2的时候是必须全部拿完的，因此返回值是dp[2]。

## [877. 石子游戏](https://leetcode.cn/problems/stone-game/)

Alice 和 Bob 用几堆石子在做游戏。一共有偶数堆石子，**排成一行**；每堆都有 **正** 整数颗石子，数目为 `piles[i]` 。

游戏以谁手中的石子最多来决出胜负。石子的 **总数** 是 **奇数** ，所以没有平局。

Alice 和 Bob 轮流进行，**Alice 先开始** 。 每回合，玩家从行的 **开始** 或 **结束** 处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中 **石子最多** 的玩家 **获胜** 。

假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回 `true` ，当 Bob 赢得比赛时返回 `false` 。

**示例 1：**

```
输入：piles = [5,3,4,5]
输出：true
解释：
Alice 先开始，只能拿前 5 颗或后 5 颗石子 。
假设他取了前 5 颗，这一行就变成了 [3,4,5] 。
如果 Bob 拿走前 3 颗，那么剩下的是 [4,5]，Alice 拿走后 5 颗赢得 10 分。
如果 Bob 拿走后 5 颗，那么剩下的是 [3,4]，Alice 拿走后 4 颗赢得 9 分。
这表明，取前 5 颗石子对 Alice 来说是一个胜利的举动，所以返回 true 。
```

**示例 2：**

```
输入：piles = [3,7,2,3]
输出：true
```

此题与前面题目的不一样在于此题既可以从前面拿，也可以从后面拿，但一次只能拿一个，因此我们就需要一个二维数组dp来解决这道题，同样的，我们定义$dp[i][j]$为下标范围 $[i,j]$ 中，当前玩家与另一个玩家的石子数量之差的最大值。那么我们的状态转移方程为：

$dp[i][j] = max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1])$，其含义是当前玩家可以选择取走 $piles[i]$或$ piles[j]$，然后轮到另一个玩家在剩下的石子堆中取走石子。

```python
class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        dp = [[0] * len(piles) for _ in range(len(piles))]
        for i in range(len(piles) - 1, -1, -1):
            dp[i][i] = piles[i]
            for j in range(i + 1, len(piles)):
                dp[i][j] = max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1])
        return dp[0][-1] > 0
```

从代码来看，我们是可以对dp数组降维的，降维后的代码如下：

```python
class Solution:
    def stoneGame(self, piles: List[int]) -> bool:
        dp = [0] * len(piles)
        for i in range(len(piles) - 1, -1, -1):
            dp[i] = piles[i]
            for j in range(i + 1, len(piles)):
                dp[j] = max(piles[i] - dp[j], piles[j] - dp[j - 1])
        return dp[-1] > 0
```

而对于此题而言，其两个条件：数组的长度是偶数；数组的元素之和是奇数，所以没有平局。决定了先手是必赢的，因此直接返回true即可。

## [1690. 石子游戏 VII](https://leetcode.cn/problems/stone-game-vii/)

石子游戏中，爱丽丝和鲍勃轮流进行自己的回合，**爱丽丝先开始** 。

有 `n` 块石子排成一排。每个玩家的回合中，可以从行中 **移除** 最左边的石头或最右边的石头，并获得与该行中剩余石头值之 **和** 相等的得分。当没有石头可移除时，得分较高者获胜。

鲍勃发现他总是输掉游戏（可怜的鲍勃，他总是输），所以他决定尽力 **减小得分的差值** 。爱丽丝的目标是最大限度地 **扩大得分的差值** 。

给你一个整数数组 `stones` ，其中 `stones[i]` 表示 **从左边开始** 的第 `i` 个石头的值，如果爱丽丝和鲍勃都 **发挥出最佳水平** ，请返回他们 **得分的差值** 。

**示例 1：**

```
输入：stones = [5,3,1,4,2]
输出：6
解释：
- 爱丽丝移除 2 ，得分 5 + 3 + 1 + 4 = 13 。游戏情况：爱丽丝 = 13 ，鲍勃 = 0 ，石子 = [5,3,1,4] 。
- 鲍勃移除 5 ，得分 3 + 1 + 4 = 8 。游戏情况：爱丽丝 = 13 ，鲍勃 = 8 ，石子 = [3,1,4] 。
- 爱丽丝移除 3 ，得分 1 + 4 = 5 。游戏情况：爱丽丝 = 18 ，鲍勃 = 8 ，石子 = [1,4] 。
- 鲍勃移除 1 ，得分 4 。游戏情况：爱丽丝 = 18 ，鲍勃 = 12 ，石子 = [4] 。
- 爱丽丝移除 4 ，得分 0 。游戏情况：爱丽丝 = 18 ，鲍勃 = 12 ，石子 = [] 。
得分的差值 18 - 12 = 6 。
```

**示例 2：**

```
输入：stones = [7,90,5,1,100,10,10,2]
输出：122
```

此题与上一题基本类似，只是上一题得分是石头的分数，这一题是拿掉石头后的分数。我们只需其他算好前缀和即可：

```python
class Solution:
    def stoneGameVII(self, stones: List[int]) -> int:
        n = len(stones)
        dp = [0] * n
        presum = [0] * (n + 1)
        for i in range(n):
            presum[i + 1] = presum[i] + stones[i]
        for i in range(n - 1, -1, -1):
            for j in range(i + 1, n):
                dp[j] = max(presum[j + 1] - presum[i + 1] - dp[j], presum[j] - presum[i] - dp[j - 1])
        return dp[-1]
```

## [1563. 石子游戏 V](https://leetcode.cn/problems/stone-game-v/)

几块石子 **排成一行** ，每块石子都有一个关联值，关联值为整数，由数组 `stoneValue` 给出。

游戏中的每一轮：Alice 会将这行石子分成两个 **非空行**（即，左侧行和右侧行）；Bob 负责计算每一行的值，即此行中所有石子的值的总和。Bob 会丢弃值最大的行，Alice 的得分为剩下那行的值（每轮累加）。如果两行的值相等，Bob 让 Alice 决定丢弃哪一行。下一轮从剩下的那一行开始。

只 **剩下一块石子** 时，游戏结束。Alice 的分数最初为 **`0`** 。

返回 **Alice 能够获得的最大分数** *。*

**示例 1：**

```
输入：stoneValue = [6,2,3,4,5,5]
输出：18
解释：在第一轮中，Alice 将行划分为 [6，2，3]，[4，5，5] 。左行的值是 11 ，右行的值是 14 。Bob 丢弃了右行，Alice 的分数现在是 11 。
在第二轮中，Alice 将行分成 [6]，[2，3] 。这一次 Bob 扔掉了左行，Alice 的分数变成了 16（11 + 5）。
最后一轮 Alice 只能将行分成 [2]，[3] 。Bob 扔掉右行，Alice 的分数现在是 18（16 + 2）。游戏结束，因为这行只剩下一块石头了。
```

**示例 2：**

```
输入：stoneValue = [7,7,7,7,7,7,7]
输出：28
```

**示例 3：**

```
输入：stoneValue = [4]
输出：0
```

此题与上两题也有点类似，其基本思想都是类似的，我们的dp数组的定义跟着改变即可。

```python
class Solution:
    def stoneGameV(self, stoneValue: List[int]) -> int:
        def stone(p1, p2, dp1, dp2):
            return dp1 + p1 if p1 < p2 else dp2 + p2 if p1 > p2 else max(dp1 + p1, dp2 + p2)
        
        n = len(stoneValue)
        dp = [[0] * n for _ in range(n)]
        presum = [0] * (n + 1)
        for i in range(n):
            presum[i + 1] = presum[i] + stoneValue[i]
        for i in range(n - 2, -1, -1):
            for j in range(i + 1, n):
                dp[i][j] = max(stone(presum[x + 1] - presum[i], presum[j + 1] - presum[x + 1], dp[i][x], dp[x + 1][j]) for x in range(i, j))
        return dp[0][-1]
```

但此题的石头数目有点长，时间复杂度$O(N^3)$是无法通过的，我们可以使用一些其他方法降低时间复杂度，但其难度更大，此处就不再列出了。

## [1686. 石子游戏 VI](https://leetcode.cn/problems/stone-game-vi/)

Alice 和 Bob 轮流玩一个游戏，Alice 先手。

一堆石子里总共有 `n` 个石子，轮到某个玩家时，他可以 **移出** 一个石子并得到这个石子的价值。Alice 和 Bob 对石子价值有 **不一样的的评判标准** 。双方都知道对方的评判标准。

给你两个长度为 `n` 的整数数组 `aliceValues` 和 `bobValues` 。`aliceValues[i]` 和 `bobValues[i]` 分别表示 Alice 和 Bob 认为第 `i` 个石子的价值。

所有石子都被取完后，得分较高的人为胜者。如果两个玩家得分相同，那么为平局。两位玩家都会采用 **最优策略** 进行游戏。

请你推断游戏的结果，用如下的方式表示：

- 如果 Alice 赢，返回 `1` 。
- 如果 Bob 赢，返回 `-1` 。
- 如果游戏平局，返回 `0` 。

**示例 1：**

```
输入：aliceValues = [1,3], bobValues = [2,1]
输出：1
解释：
如果 Alice 拿石子 1 （下标从 0开始），那么 Alice 可以得到 3 分。
Bob 只能选择石子 0 ，得到 2 分。
Alice 获胜。
```

**示例 2：**

```
输入：aliceValues = [1,2], bobValues = [3,1]
输出：0
解释：
Alice 拿石子 0 ， Bob 拿石子 1 ，他们得分都为 1 分。
打平。
```

**示例 3：**

```
输入：aliceValues = [2,4,3], bobValues = [1,6,7]
输出：-1
解释：
不管 Alice 怎么操作，Bob 都可以得到比 Alice 更高的得分。
比方说，Alice 拿石子 1 ，Bob 拿石子 2 ， Alice 拿石子 0 ，Alice 会得到 6 分而 Bob 得分为 7 分。
Bob 会获胜。
```

此题开始，其与上面的就不一样了，其是从石头中任意取石头，而不是从左或从右取了。因此我们就不用动态规划也可以解决这道题了。我们可以使用排序+贪心的思想来解决这道题，假设有 2 个石子 $i$和$ j$，Alice和 Bob认为它们的价值分别为 $a_i, b_i$和 $a_j, b_j$。如果 Alice取了 i，而 Bob取了 j，则它们的分数差为 $a_i - b_j$；如果 Alice取了$j$，而 Bob 取了 $i$，则它们的分数差为 $a_j - b_i$。对于 Alice来说，这两个方案，选取哪一种，取决于这两个分数差的差：$(a_i - b_j)-(a_j - b_i)=(a_i+b_i)-(a_j+b_j)$。当这个值 >0 时，Alice会优先选择 $i$，当这个值 <0 时，Alice会优先选择 $j$。因此，Alice在选择时，会优先选择$(a_i+b_i)$大的石头。

我们只需要将两个数组 aliceValues和 bobValues对应的元素相加后倒序排序，然后 Alice和 Bob依次选取，最后计算两人的分数和后进行比较返回结果。

```python
class Solution:
    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:
        values = sorted(zip(aliceValues, bobValues), key=lambda x: x[0] + x[1], reverse=True)
        count = sum(alice if i % 2 == 0 else -bob for i, (alice, bob) in enumerate(values))
        return 1 if count > 0 else -1 if count < 0 else 0
```

## [2029. 石子游戏 IX](https://leetcode.cn/problems/stone-game-ix/)

Alice 和 Bob 再次设计了一款新的石子游戏。现有一行 n 个石子，每个石子都有一个关联的数字表示它的价值。给你一个整数数组 `stones` ，其中 `stones[i]` 是第 `i` 个石子的价值。

Alice 和 Bob 轮流进行自己的回合，**Alice** 先手。每一回合，玩家需要从 `stones` 中移除任一石子。

- 如果玩家移除石子后，导致 **所有已移除石子** 的价值 **总和** 可以被 3 整除，那么该玩家就 **输掉游戏** 。
- 如果不满足上一条，且移除后没有任何剩余的石子，那么 Bob 将会直接获胜（即便是在 Alice 的回合）。

假设两位玩家均采用 **最佳** 决策。如果 Alice 获胜，返回 `true` ；如果 Bob 获胜，返回 `false` 。

**示例 1：**

```
输入：stones = [2,1]
输出：true
解释：游戏进行如下：
- 回合 1：Alice 可以移除任意一个石子。
- 回合 2：Bob 移除剩下的石子。 
已移除的石子的值总和为 1 + 2 = 3 且可以被 3 整除。因此，Bob 输，Alice 获胜。
```

**示例 2：**

```
输入：stones = [2]
输出：false
解释：Alice 会移除唯一一个石子，已移除石子的值总和为 2 。 
由于所有石子都已移除，且值总和无法被 3 整除，Bob 获胜。
```

**示例 3：**

```
输入：stones = [5,1,2,4,3]
输出：false
解释：Bob 总会获胜。其中一种可能的游戏进行方式如下：
- 回合 1：Alice 可以移除值为 1 的第 2 个石子。已移除石子值总和为 1 。
- 回合 2：Bob 可以移除值为 3 的第 5 个石子。已移除石子值总和为 = 1 + 3 = 4 。
- 回合 3：Alices 可以移除值为 4 的第 4 个石子。已移除石子值总和为 = 1 + 3 + 4 = 8 。
- 回合 4：Bob 可以移除值为 2 的第 3 个石子。已移除石子值总和为 = 1 + 3 + 4 + 2 = 10.
- 回合 5：Alice 可以移除值为 5 的第 1 个石子。已移除石子值总和为 = 1 + 3 + 4 + 2 + 5 = 15.
Alice 输掉游戏，因为已移除石子值总和（15）可以被 3 整除，Bob 获胜。
```

此题也是从石头中任意取出一个，同时由于我们只关系和能否被3整除，那么我们可以像之前[1262. 可被三整除的最大和](https://leetcode.cn/problems/greatest-sum-divisible-by-three/)那样，只关心对3的模，而不关心具体的值，那么我们可以对每一个值取模并记录下来。此题难度是很大的，属于博弈论里的内容了，此处仅展示最后代码：

```python
class Solution:
    def stoneGameIX(self, stones: List[int]) -> bool:
        mod = [0] * 3
        for stone in stones:
            mod[stone % 3] += 1
        if mod[0] & 1 == 0: return mod[1] != 0 and mod[2] != 0
        return abs(mod[1] - mod[2]) > 2
```

